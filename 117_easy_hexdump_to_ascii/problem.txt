close this window
jump to content
my subreddits
edit subscriptions

  • popular
  • -all
  • -random
  • -users

 | 

  • AskReddit
  • -worldnews
  • -videos
  • -funny
  • -todayilearned
  • -pics
  • -gaming
  • -movies
  • -news
  • -gifs
  • -mildlyinteresting
  • -aww
  • -Showerthoughts
  • -television
  • -Jokes
  • -science
  • -OldSchoolCool
  • -sports
  • -IAmA
  • -Documentaries
  • -TwoXChromosomes
  • -explainlikeimfive
  • -personalfinance
  • -books
  • -tifu
  • -Futurology
  • -dataisbeautiful
  • -WritingPrompts
  • -nottheonion
  • -food
  • -Music
  • -photoshopbattles
  • -EarthPorn
  • -philosophy
  • -Art
  • -nosleep
  • -GetMotivated
  • -askscience
  • -LifeProTips
  • -space
  • -UpliftingNews
  • -DIY
  • -history
  • -gadgets
  • -creepy
  • -listentothis
  • -blog
  • -announcements
  • -InternetIsBeautiful

more >>
dailyprogrammer dailyprogrammer

  • comments

Want to join? Log in or sign up in seconds.|

  • English

[                    ][]
[ ]limit my search to r/dailyprogrammer

use the following search parameters to narrow your results:

subreddit:subreddit
    find submissions in "subreddit"
author:username
    find submissions by "username"
site:example.com
    find submissions from "example.com"
url:text
    search for "text" in url
selftext:text
    search for "text" in self post contents
self:yes (or self:no)
    include (or exclude) self posts
nsfw:yes (or nsfw:no)
    include (or exclude) results marked as NSFW

e.g. subreddit:aww site:imgur.com dog

see the search faq for details.

advanced search: by author, subreddit...

this post was submitted on  14 Jan 2013
61 points (96% upvoted)
shortlink:  [https://redd.it/16ji]
[                    ][                    ]
[ ]remember mereset password
login
Submissions restricted
Only approved users may post in this community.

dailyprogrammer

subscribeunsubscribe141,927 readers

93 users here now

 1. Challenge #321: Easy
 2. Challenge #321: Intermediate
 3. Challenge #321: Hard
 4. Weekly #25: Escape the trolls

Welcome to r/DailyProgrammer!

First time visitors of Daily Programmer please Read the Wiki to learn
everything about this subreddit.

  • Solution Submission Tutorial
  • Solution Submission Guidelines
  • Code / Peer-Review Guidelines
  • Problem Submission Guidelines
  • Achievements System
  • Community Projects
  • Links to other Programming subreddits
  • Special Thanks

Can't submit solutions?

If you are a new or unverified account, and are unable to post comment replies,
please click here to verify your account. Otherwise, read the Solution
Submission Tutorial for a walkthrough of submitting a solution, or click below
to message the moderators for assistance.

Write your own challenge!

To help the community and write your own challenge to be submitted, head on
over to /r/DailyProgrammer_Ideas and share your project - read the sidebar in
that subreddit for more information.

IRC Channel

Message the Moderators

Challenge List in Chronological Order

created by nottoobadguya community for 6 years
message the moderators

MODERATORS

  • rya111113 1
  • nint221 2
  • Cosmologicon2 3
  • Elite68091 1
  • XenophonOfAthens2 1
  • jnazario2 0
  • Godspiral3 3
  • Blackshell2 0
  • fvandepitte0 0
  • G33kDude1 1
  • about moderation team >>

discussions in r/dailyprogrammer
<>
X
 
58 . 21 comments
[2018-05-04] Challenge #359 [Hard] Primes in Grids
 
42 . 36 comments
[2018-05-02] Challenge #359 [Intermediate] Unwrap Some Text
 
63 . 106 comments
[2018-04-30] Challenge #359 [Easy] Regular Paperfold Sequence Generator
 
65 . 12 comments
[2018-04-27] Challenge #358 [Hard] Puzzle me this
 
46 . 36 comments
[2018-04-25] Challenge #358 [Intermediate] Everyone's A Winner!
 
70 . 75 comments
[2018-04-23] Challenge #358 [Easy] Decipher The Seven Segments
 
52 . 28 comments
[2018-04-20] Challenge #357 [Hard] Continued Fractions
 
54 . 26 comments
[2018-04-19] Challenge #357 [Intermediate] Kolakoski Sequences
 
72 . 114 comments
[2018-04-11] Challenge #356 [Intermediate] Goldbach's Weak Conjecture
 
83 . 78 comments
[2018-03-28] Challenge #355 [Intermediate] Possible Number of Pies

Welcome to Reddit,

the front page of the internet.

Become a Redditor

and subscribe to one of thousands of communities.

x

60
61
62

[01/14/13] Challenge #117 [Easy] Hexdump to ASCII (self.dailyprogrammer)

submitted 5 years ago * by nint221 2

 (Easy): Hexdump to ASCII

Hexadecimal is a base-16 representation of a number. A single byte of
information, as an unsigned integer, can have a value of 0 to 255 in decimal.
This byte can be represented in hexadecimal, from a range of 0x0 to 0xFF in
hexadecimal.

Your job is to open a given file (using the given file name) and print every
byte's hexadecimal value.

Author: PoppySeedPlehzr

Formal Inputs & Outputs

Input Description

As a program command-line argument to the program, accept a valid file name.

Output Description

Print the given file's contents, where each byte of the file must be printed in
hexadecimal form. Your program must print 16 bytes per line, where there is a
space between each hexadecimal byte. Each line must start with the line number,
starting from line 0, and must also count in hexadecimal.

Sample Inputs & Outputs

Sample Input

"MyFile.txt" (This file is an arbitrary file as an example)

Sample Output

00000000 37 7A BC AF 27 1C 00 03 38 67 83 24 70 00 00 00
00000001 00 00 00 00 49 00 00 00 00 00 00 00 64 FC 7F 06
00000002 00 28 12 BC 60 28 97 D5 68 12 59 8C 17 8F FE D8
00000003 0E 5D 2C 27 BC D1 87 F6 D2 BE 9B 92 90 E8 FD BA
00000004 A2 B8 A9 F4 BE A6 B8 53 10 E3 BD 60 05 2B 5C 95
00000005 C4 50 B4 FC 10 DE 58 80 0C F5 E1 C0 AC 36 30 74
00000006 82 8B 42 7A 06 A5 D0 0F C2 4F 7B 27 6C 5D 96 24
00000007 25 4F 3A 5D F4 B2 C0 DB 79 3C 86 48 AB 2D 57 11
00000008 53 27 50 FF 89 02 20 F6 31 C2 41 72 84 F7 C9 00
00000009 01 04 06 00 01 09 70 00 07 0B 01 00 01 23 03 01
0000000A 01 05 5D 00 00 01 00 0C 80 F5 00 08 0A 01 A8 3F
0000000B B1 B7 00 00 05 01 11 0B 00 64 00 61 00 74 00 61
0000000C 00 00 00 14 0A 01 00 68 6E B8 CF BC A0 CD 01 15
0000000D 06 01 00 20 00 00 00 00 00

Challenge Input

Give your program its own binary file, and have it print itself out!

Challenge Input Solution

This is dependent on how you write your code and what platform you are on.

Note

  • As an added bonus, attempt to print out any ASCII strings, if such data is
    found in your given file.

  • 96 comments
  • share
  • save
  • hide
  • report

all 96 comments
sorted by:
best
topnewcontroversialoldrandomq&alive (beta)
 [                    ]

Want to add to the discussion?

Post a comment!

Create an account

[–]drch0 1 23 points24 points25 points 5 years ago (9 children)

C#

public void Easy117(string file)
{
    var grouped = File.ReadAllBytes(file)
        .Select((x, i) => new {Index = i, Value = x})
        .GroupBy(x => x.Index/18);

    foreach (var item in grouped)
    {
        Console.Write("{0:X8} ", item.Key);
        Console.WriteLine(string.Join(" ", item.Select(x => x.Value.ToString("X2"))));
    }
}

  • permalink
  • embed
  • save
  • give gold

[–]taterNuts 6 points7 points8 points 5 years ago (0 children)

damn nice stuff, all of a sudden I don't want to post my C# entry...

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]jeff3030 2 1 point2 points3 points 5 years ago (2 children)

Is that using Linq?

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]usea 3 points4 points5 points 5 years ago (0 children)

Select and GroupBy are Linq functions, yes. Select is basically like Map from
functional languages, and GroupBy is like the sql version (you end up with
key-value pairs where the key is what you grouped on, and the value is a
collection of items that fall into that group).

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]Sonnenhut 0 points1 point2 points 5 years ago (0 children)

Haven't seen C# code since a while, but I'm pretty sure it uses Linq.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–][deleted] 5 years ago (3 children)

[deleted]

[–]drch0 1 1 point2 points3 points 5 years ago (2 children)

The question originally said 18 and apparently was changed to 16 when someone
else pointed it out :S

I would probably implement that loop for the bonus like so:

foreach (var item in grouped)
{
    var linenum = string.Format("{0:X8}", item.Key);
    var hexvalues = string.Join(" ", item.Select(x => x.Value.ToString("X2"))).PadRight(48);
    var textValues = new String(item.Select(x=>(char)x.Value).Select(x => Char.IsLetterOrDigit(x) ? x :'.').ToArray());
    Console.WriteLine("{0} {1}{2}", linenum, hexvalues, textValues);
}

To me, using .PadRight() and Char.IsLetterOrDigit() makes it a bit more clear
of what's going on as opposed to hardcoded ascii values.

  • permalink
  • embed
  • save
  • give gold

[–][deleted] 5 years ago (1 child)

[deleted]

[–]drch0 1 0 points1 point2 points 5 years ago (0 children)

Ah - good point on the printable characters. I think you could check against
Char.IsControl() instead.

  • permalink
  • embed
  • save
  • give gold

[–]nint221 2[S] -1 points0 points1 point 5 years ago (0 children)

Nice! +1 Silver medal for a very small solution!

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]skeeto-9 8 10 points11 points12 points 5 years ago (1 child)

Emacs Lisp,

(defun slurp (file)
  (with-temp-buffer
    (set-buffer-multibyte nil)
    (insert-file-contents-literally file)
    (buffer-string)))

(defun* hexdump (file &optional (width 18))
  (interactive "fFile to dump: ")
  (loop for count upfrom 0
        for byte across (slurp file)
        when (zerop (% count width))
        do (insert (format "\n%08X" (/ count width)))
        do (insert (format " %02X" byte))))

Common Lisp,

(defun hexdump (file &optional (width 18))
  (with-open-file (stream file :element-type '(unsigned-byte 8))
    (loop while (listen stream)
       for count upfrom 0
       when (zerop (mod count width))
       do (format t "~&~8,'0x" (/ count width))
       do (format t " ~2,'0x" (read-byte stream)))))

Clojure,

(defn hexdump
  ([file] (hexdump file 18))
  ([file width]
     (with-open [data (java.io.FileReader. file)]
       (loop [byte (.read data)
              counter 0]
         (when (>= byte 0)
           (if (zero? (mod counter width))
             (printf "\n%08X" (/ counter width)))
           (printf " %02X" byte)
           (recur (.read data) (inc counter)))))))

ANSI C,

void hexdump(char *file, int width) {
    FILE *in = fopen(file, "r");
    int c, counter = 0;
    while ((c = fgetc(in)) > -1) {
        if (counter++ % width == 0)
            printf("\n%08X", counter / width);
        printf(" %02X", c);
    }
    fclose(in);
}

  • permalink
  • embed
  • save
  • give gold

[–]nint221 2[S] 2 points3 points4 points 5 years ago (0 children)

+1 Silver medal for implementing a solution in several languages, so nice!

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]FluffehTheSheep 8 points9 points10 points 5 years ago* (7 children)

In C++:

#include <iostream>
#include <fstream>
#include <iomanip>

using namespace std;

int main()
{
    ifstream file("MyFile.txt");
    // Open file
    char data;
    // Holds each character of file

    for(int i = 0; file.get(data); i++)
    // Write first character to data
    // While not at the end of the file
    {
        if(i % 18 == 0)
        // For every 18th byte
        {
            cout << endl << setw(8) << setfill('0') << hex << i/18 << "\t";
            // Print the line number as hex with 18 character padding
        }

        cout << setw(2) << setfill('0') << hex << (int)data << ' ';
        // Print character as hex with 2 character padding
    }

    file.close();
    // Close file

    return 0;
}

Sample Output:

00000000        48 65 78 61 64 65 63 69 6d 61 6c 20 69 73 20 61 20 62
00000001        61 73 65 2d 31 36 20 72 65 70 72 65 73 65 6e 74 61 74
00000002        69 6f 6e 20 6f 66 20 61 20 6e 75 6d 62 65 72 2e 20 41
00000003        20 73 69 6e 67 6c 65 20 62 79 74 65 20 6f 66 20 69 6e
00000004        66 6f 72 6d 61 74 69 6f 6e 2c 20 61 73 20 61 6e 20 75
00000005        6e 73 69 67 6e 65 64 20 69 6e 74 65 67 65 72 2c 20 63
00000006        61 6e 20 68 61 76 65 20 61 20 76 61 6c 75 65 20 6f 66
00000007        20 30 20 74 6f 20 32 35 35 20 69 6e 20 64 65 63 69 6d
00000008        61 6c 2e 20 54 68 69 73 20 62 79 74 65 20 63 61 6e 20
00000009        62 65 20 72 65 70 72 65 73 65 6e 74 65 64 20 69 6e 20
0000000a        68 65 78 61 64 65 63 69 6d 61 6c 2c 20 66 72 6f 6d 20
0000000b        61 20 72 61 6e 67 65 20 6f 66 20 30 78 30 20 74 6f 20
0000000c        30 78 46 46 20 69 6e 20 68 65 78 61 64 65 63 69 6d 61
0000000d        6c 2e 0a 59 6f 75 72 20 6a 6f 62 20 69 73 20 74 6f 20
0000000e        6f 70 65 6e 20 61 20 67 69 76 65 6e 20 66 69 6c 65 20
0000000f        28 75 73 69 6e 67 20 74 68 65 20 67 69 76 65 6e 20 66
00000010        69 6c 65 20 6e 61 6d 65 29 20 61 6e 64 20 70 72 69 6e
00000011        74 20 65 76 65 72 79 20 62 79 74 65 27 73 20 68 65 78
00000012        61 64 65 63 69 6d 61 6c 20 76 61 6c 75 65 2e

  • permalink
  • embed
  • save
  • give gold

[–]nint221 2[S] 3 points4 points5 points 5 years ago (3 children)

I've never seen comments under the lines in question, ha, nice!

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]bealhorm 4 points5 points6 points 5 years ago (1 child)

I can see why. Our normal pattern is :

Ah! - Huh? - Ah!

His pattern is :

Huh? - Ah!

If you first have the opportunity to read the code and understand it yourself
and later you get the explanation. I like it.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]FluffehTheSheep 2 points3 points4 points 5 years ago (0 children)

Yeah that is pretty much my thought pattern.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]FluffehTheSheep 1 point2 points3 points 5 years ago (0 children)

Thanks. I find it saves time when re-reading code.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]caboose0013 0 points1 point2 points 5 years ago (1 child)

What does (int)data do? Sorry noob here.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]johnsSocks 0 points1 point2 points 5 years ago (0 children)

It typecasts data to an int.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]HandOfTheCEO 7 points8 points9 points 5 years ago* (0 children)

Concise Ruby:

File.open(ARGV.first) do |f|
  f.bytes.each_slice(16).each_with_index do |b,i|
    puts "%08x #{'%02x ' * b.length}" % ([i] + b)
  end
end

Output (run on the program itself):

00000000 46 69 6c 65 2e 6f 70 65 6e 28 41 52 47 56 2e 66
00000001 69 72 73 74 29 20 64 6f 20 7c 66 7c 0a 20 20 66
00000002 2e 62 79 74 65 73 2e 65 61 63 68 5f 73 6c 69 63
00000003 65 28 31 36 29 2e 65 61 63 68 5f 77 69 74 68 5f
00000004 69 6e 64 65 78 20 64 6f 20 7c 62 2c 69 7c 0a 20
00000005 20 20 20 70 75 74 73 20 22 25 30 38 78 20 23 7b
00000006 27 25 30 32 78 20 27 20 2a 20 62 2e 6c 65 6e 67
00000007 74 68 7d 22 20 25 20 28 5b 69 5d 20 2b 20 62 29
00000008 0a 20 20 65 6e 64 0a 65 6e 64 0a

  • permalink
  • embed
  • save
  • give gold

[–]domlebo701 2 5 points6 points7 points 5 years ago* (0 children)

In Scala:

def challenge117Easy(filename: String) = {
  def byteAsHex(value: Byte, padding: Int) = format("%0" + padding + "X", Byte.valueOf(value))

  val fileAsHex = fromFile(filename).mkString.getBytes.map(byteAsHex(_, 2))

  fileAsHex.grouped(18).zipWithIndex.map {
    case (e, i) => (byteAsHex(i.toByte, 8)  +: e).mkString (" ")
  }.mkString("\n")
}

And used like so:

println(challenge117Easy("/tmp/someFile.txt"))

Giving:

00000000 6F 72 67 61 6E 69 7A 61 74 69 6F 6E 20 3A 3D 20 22 64
00000001 62 6F 75 73 61 6D 72 61 22 0A 0A 6E 61 6D 65 20 3A 3D
00000002 20 22 77 6F 72 6B 62 65 6E 63 68 22 0A 0A 76 65 72 73
00000003 69 6F 6E 20 3A 3D 20 22 30 2E 31 2D 53 4E 41 50 53 48
00000004 4F 54 22 0A 0A 73 63 61 6C 61 56 65 72 73 69 6F 6E 20
00000005 3A 3D 20 22 32 2E 31 30 2E 30 22 0A 0A 6C 69 62 72 61
00000006 72 79 44 65 70 65 6E 64 65 6E 63 69 65 73 20 2B 2B 3D
00000007 20 53 65 71 28 20 0A 20 20 22 6F 72 67 2E 73 63 61 6C
00000008 61 74 65 73 74 22 20 25 25 20 22 73 63 61 6C 61 74 65
00000009 73 74 22 20 25 20 22 31 2E 39 2E 31 22 0A 29 0A 0A 73
0000000A 6F 75 72 63 65 44 69 72 65 63 74 6F 72 79 20 69 6E 20
0000000B 54 65 73 74 20 3C 3C 3D 20 62 61 73 65 44 69 72 65 63
0000000C 74 6F 72 79 28 5F 20 2F 20 22 73 72 63 2F 6D 61 69 6E
0000000D 2F 22 29

  • permalink
  • embed
  • save
  • give gold

[–]robin-gvx0 2 4 points5 points6 points 5 years ago (0 children)

Déjà Vu:

local :hexd reversed chars "0123456789abcdef"
hex x:
    get-from hexd % x 16
    get-from hexd floor / x 16
    concat

for x in chars input:
    print\ hex ord x
    print\ " "
print ""

  • permalink
  • embed
  • save
  • give gold

[–]qiwi 3 points4 points5 points 5 years ago (0 children)

Another Python (2) with two things I haven't seen here before: printable
characters is a set, and the iter() functions is used to make reading 16-byte
at a time and numbering them easier:

import sys, string
SIZE = 16

PRINTABLE = set(string.punctuation + string.letters + string.digits + ' ')

# Also equivalent
# PRINTABLE = set(map(chr, range(0x20, 0x7F)))

# iter(callable, sentinel) repeatedly calls callable until it returns the sentinel
# this allows stacking of enumerate() on top of a stream of 16-byte chunks
read = open(sys.argv[1]).read
for lineno, chunk in enumerate(iter(lambda: read(SIZE), '')):
    # The hex area is padded to 3 characters per byte we output, as to line up the
    # printable ASCII area. The * format lets us pass in the padding as a variable
    print "%08X %-*s %s" % (lineno, SIZE*3,
                       ' '.join('%02X' % ord(x) for x in chunk),
                       ''.join(x if x in PRINTABLE else '.' for x in chunk))

  • permalink
  • embed
  • save
  • give gold

[–]Rocksheep 10 points11 points12 points 5 years ago (2 children)

Here is my go in Python

import sys
import os

def convertFileToHex(filename):
    lineCounter = 0
    for (counter, char) in enumerate(open(filename, "r").read()):
        if not (counter) % 4:
            print(" ", end=" ")
        if not counter % 16:
            print("\n%08X  " % lineCounter, end=" ")
            lineCounter += 1
        print("%02X" % ord(char), end=" ")

    #add padding so it fills up the columns :)
    while (counter + 1) % 16:
        print("%02X" % 0, end=" ")
        counter += 1

if len(sys.argv) > 1:
    if os.path.exists(sys.argv[1]):
         convertFileToHex(sys.argv[1])
    else:
         print("Invalid file. Shutting down.")

I added some padding to the back of the output if it was not 16 bytes long

Example output on itself:

00000000   69 6D 70 6F   72 74 20 73   79 73 0A 69   6D 70 6F 72
00000001   74 20 6F 73   0A 0A 64 65   66 20 63 6F   6E 76 65 72
00000002   74 46 69 6C   65 54 6F 48   65 78 28 66   69 6C 65 6E
00000003   61 6D 65 29   3A 0A 09 6C   69 6E 65 43   6F 75 6E 74
00000004   65 72 20 3D   20 30 0A 09   66 6F 72 20   28 63 6F 75
00000005   6E 74 65 72   2C 20 63 68   61 72 29 20   69 6E 20 65
00000006   6E 75 6D 65   72 61 74 65   28 6F 70 65   6E 28 66 69
00000007   6C 65 6E 61   6D 65 2C 20   22 72 22 29   2E 72 65 61
00000008   64 28 29 29   3A 0A 09 09   69 66 20 6E   6F 74 20 28
00000009   63 6F 75 6E   74 65 72 29   20 25 20 34   3A 0A 09 09
0000000A   09 70 72 69   6E 74 28 22   20 22 2C 20   65 6E 64 3D
0000000B   22 20 22 29   0A 09 09 69   66 20 6E 6F   74 20 63 6F
0000000C   75 6E 74 65   72 20 25 20   31 36 3A 0A   09 09 09 70
0000000D   72 69 6E 74   28 22 5C 6E   25 30 38 58   20 20 22 20
0000000E   25 20 6C 69   6E 65 43 6F   75 6E 74 65   72 2C 20 65
0000000F   6E 64 3D 22   20 22 29 0A   09 09 09 6C   69 6E 65 43
00000010   6F 75 6E 74   65 72 20 2B   3D 20 31 0A   09 09 70 72
00000011   69 6E 74 28   22 25 30 32   58 22 20 25   20 6F 72 64
00000012   28 63 68 61   72 29 2C 20   65 6E 64 3D   22 20 22 29
00000013   0A 0A 09 23   61 64 64 20   70 61 64 64   69 6E 67 20
00000014   73 6F 20 69   74 20 66 69   6C 6C 73 20   75 70 20 74
00000015   68 65 20 63   6F 6C 75 6D   6E 73 20 3A   29 0A 09 77
00000016   68 69 6C 65   20 28 63 6F   75 6E 74 65   72 20 2B 20
00000017   31 29 20 25   20 31 36 3A   0A 09 09 70   72 69 6E 74
00000018   28 22 25 30   32 58 22 20   25 20 30 2C   20 65 6E 64
00000019   3D 22 20 22   29 0A 09 09   63 6F 75 6E   74 65 72 20
0000001A   2B 3D 20 31   0A 0A 69 66   20 6C 65 6E   28 73 79 73
0000001B   2E 61 72 67   76 29 20 3E   20 31 3A 0A   09 70 72 69
0000001C   6E 74 28 73   79 73 2E 61   72 67 76 5B   31 5D 29 0A
0000001D   09 69 66 20   6F 73 2E 70   61 74 68 2E   65 78 69 73
0000001E   74 73 28 73   79 73 2E 61   72 67 76 5B   31 5D 29 3A
0000001F   0A 09 09 63   6F 6E 76 65   72 74 46 69   6C 65 54 6F
00000020   48 65 78 28   73 79 73 2E   61 72 67 76   5B 31 5D 29

  • permalink
  • embed
  • save
  • give gold

[–]Draaiorgel 1 point2 points3 points 5 years ago (0 children)

cool!

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]freakmad 0 points1 point2 points 5 years ago (0 children)

Nice touch with enumerate.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]prophile 3 points4 points5 points 5 years ago (0 children)

In Haskell:

module Main where

import Data.Bits
import Data.ByteString(length, index, hGetContents)
import Data.List(genericIndex, intercalate)
import Text.Printf(printf)
import System.IO

hexify :: (Bits a, Integral a) => [a] -> String
hexify x = do c <- x
              part <- [(`shiftR` 8), (.&. 0xF)]
              return $ "0123456789abcdef" `genericIndex` (part c)

groupsOf :: Int -> [a] -> [[a]]
groupsOf n l = case (splitAt n l) of
                 (x, []) -> [x]
                 (x, xs) -> x:(groupsOf n xs)

hexFormat :: String -> String
hexFormat s = concat numberedLines
  where baseLines = groupsOf 36 s
        spacedLines = map (intercalate " " . groupsOf 2) baseLines
        numberedLines = [printf "%08x %s\n" (n :: Int) l | (n, l) <- zip [0..] spacedLines]

hexdump :: (Bits a, Integral a) => [a] -> String
hexdump = hexFormat . hexify

main :: IO ()
main = do contents <- Data.ByteString.hGetContents stdin
          let len = Data.ByteString.length contents
          putStr $ hexdump [contents `index` n | n <- [0..(len-1)]]

  • permalink
  • embed
  • save
  • give gold

[–]usea 3 points4 points5 points 5 years ago (0 children)

Go

package main

import (
    "fmt"
    "io/ioutil"
    "os"
)

func main() {
    args := os.Args[:]
    if len(args) < 2 {
        fmt.Println("need filename")
        return
    }
    filename := args[1]
    b, _ := ioutil.ReadFile(filename)
    for i := 0; i < (len(b)/16)+1; i++ {
        fmt.Printf("%06X", i)
        for j := 0; j < 16; j++ {
            if i*16+j >= len(b) {
                return
            }
            fmt.Printf(" %02X", b[(i*16)+j])
        }
        fmt.Println("")
    }
}

Took me forever to figure out how to pad output. The documentation wasn't very
clear.

Output against source code:

000000 70 61 63 6B 61 67 65 20 6D 61 69 6E 0D 0A 0D 0A
000001 69 6D 70 6F 72 74 20 28 0D 0A 09 22 66 6D 74 22
000002 0D 0A 09 22 69 6F 2F 69 6F 75 74 69 6C 22 0D 0A
000003 09 22 6F 73 22 0D 0A 29 0D 0A 0D 0A 66 75 6E 63
000004 20 6D 61 69 6E 28 29 20 7B 0D 0A 09 61 72 67 73
000005 20 3A 3D 20 6F 73 2E 41 72 67 73 5B 3A 5D 0D 0A
000006 09 69 66 20 6C 65 6E 28 61 72 67 73 29 20 3C 20
000007 32 20 7B 0D 0A 09 09 66 6D 74 2E 50 72 69 6E 74
000008 6C 6E 28 22 6E 65 65 64 20 66 69 6C 65 6E 61 6D
000009 65 22 29 0D 0A 09 09 72 65 74 75 72 6E 0D 0A 09
00000A 7D 0D 0A 09 66 69 6C 65 6E 61 6D 65 20 3A 3D 20
00000B 61 72 67 73 5B 31 5D 0D 0A 09 62 2C 20 5F 20 3A
00000C 3D 20 69 6F 75 74 69 6C 2E 52 65 61 64 46 69 6C
00000D 65 28 66 69 6C 65 6E 61 6D 65 29 0D 0A 09 66 6F
00000E 72 20 69 20 3A 3D 20 30 3B 20 69 20 3C 20 28 6C
00000F 65 6E 28 62 29 2F 31 36 29 2B 31 3B 20 69 2B 2B
000010 20 7B 0D 0A 09 09 66 6D 74 2E 50 72 69 6E 74 66
000011 28 22 25 30 36 58 22 2C 20 69 29 0D 0A 09 09 66
000012 6F 72 20 6A 20 3A 3D 20 30 3B 20 6A 20 3C 20 31
000013 36 3B 20 6A 2B 2B 20 7B 0D 0A 09 09 09 69 66 20
000014 69 2A 31 36 2B 6A 20 3E 3D 20 6C 65 6E 28 62 29
000015 20 7B 0D 0A 09 09 09 09 72 65 74 75 72 6E 0D 0A
000016 09 09 09 7D 0D 0A 09 09 09 66 6D 74 2E 50 72 69
000017 6E 74 66 28 22 20 25 30 32 58 22 2C 20 62 5B 28
000018 69 2A 31 36 29 2B 6A 5D 29 0D 0A 09 09 7D 0D 0A
000019 09 09 66 6D 74 2E 50 72 69 6E 74 6C 6E 28 22 22
00001A 29 0D 0A 09 7D 0D 0A 7D 0D 0A

  • permalink
  • embed
  • save
  • give gold

[–][deleted] 5 points6 points7 points 5 years ago (0 children)

Befunge is cool. (decimal line numbers because eeeeh.)

00v0123456789abcdef
< <    v!%+88: ># v#+1," ",g0+3%+88
^v ,*25_>~:01-`|  >:88+/3+0g,
 >\:.1+\^      @

Run it here: http://www.quirkster.com/iano/js/befunge.html

  • permalink
  • embed
  • save

[–]Sonnenhut 4 points5 points6 points 5 years ago* (5 children)

Java:

package easy.n117;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class N117{
    public static void main(final String[] args) {
        int numberOfDataInRow = 18;
        boolean printAsAscii = false;
        File file = null;

        if(args.length > 0){
            file = new File(args[0]);
        }
        printAsAscii = args.length > 1 && "1".equals(args[1]);
        printFile(file, numberOfDataInRow, printAsAscii);
    }

    private static void printFile(File file, int numberOfDataInRow, boolean asAscii){
        if(file != null){
            FileInputStream fis = null;
            try{
                fis = new FileInputStream(file);

                int data, row = 0;
                for(int byteNo = 0;(data = fis.read()) != -1; byteNo++){
                    if(row == 0 || (byteNo % numberOfDataInRow) == 0){
                        String newLine = row != 0 ? "\n" : "";
                        System.out.printf(newLine + "%08X", row);
                        row++;
                    }
                    System.out.print(" " +
                                (asAscii ? (char)data : Integer.toHexString(data)));
                }
            } catch (FileNotFoundException e) {
                System.out.println("file not found");
            } catch (IOException e){
                System.out.println("error reading file");
            }
        }else{
            System.out.println("please provide a file path");
        }
    }
}

usage(only tried in Eclipse):

output with ascii:

java N117.class C:\MyFile.txt 1

output without ascii:

java N117.class C:\MyFile.txt

1st parameter: the file

2nd parameter: print in ascii

output with ascii:

00000000 L o r e m   i p s u m   d o l o r
00000001 s i t   a m e t ,   c o n s e c t e
00000002 t u r   a d i p i s i c i n g   e l
00000003 i t ,   s e d   d o   e i u s m o d
00000004   t e m p o r   i n c i d i d u n t
00000005   u t   l a b o r e   e t   d o l o
00000006 r e   m a g n a   a l i q u a .   U
00000007 t   e n i m   a d   m i n i m   v e
00000008 n i a m ,   q u i s   n o s t r u d
00000009   e x e r c i t a t i o n   u l l a
0000000A m c o   l a b o r i s   n i s i   u
0000000B t   a l i q u i p   e x   e a   c o
0000000C m m o d o   c o n s e q u a t .   D
0000000D u i s   a u t e   i r u r e   d o l
0000000E o r   i n   r e p r e h e n d e r i
0000000F t   i n   v o l u p t a t e   v e l
00000010 i t   e s s e   c i l l u m   d o l
00000011 o r e   e u   f u g i a t   n u l l
00000012 a   p a r i a t u r .   E x c e p t
00000013 e u r   s i n t   o c c a e c a t
00000014 c u p i d a t a t   n o n   p r o i
00000015 d e n t ,   s u n t   i n   c u l p
00000016 a   q u i   o f f i c i a   d e s e
00000017 r u n t   m o l l i t   a n i m   i
00000018 d   e s t   l a b o r u m .

output without ascii:

00000000 4c 6f 72 65 6d 20 69 70 73 75 6d 20 64 6f 6c 6f 72 20
00000001 73 69 74 20 61 6d 65 74 2c 20 63 6f 6e 73 65 63 74 65
00000002 74 75 72 20 61 64 69 70 69 73 69 63 69 6e 67 20 65 6c
00000003 69 74 2c 20 73 65 64 20 64 6f 20 65 69 75 73 6d 6f 64
00000004 20 74 65 6d 70 6f 72 20 69 6e 63 69 64 69 64 75 6e 74
00000005 20 75 74 20 6c 61 62 6f 72 65 20 65 74 20 64 6f 6c 6f
00000006 72 65 20 6d 61 67 6e 61 20 61 6c 69 71 75 61 2e 20 55
00000007 74 20 65 6e 69 6d 20 61 64 20 6d 69 6e 69 6d 20 76 65
00000008 6e 69 61 6d 2c 20 71 75 69 73 20 6e 6f 73 74 72 75 64
00000009 20 65 78 65 72 63 69 74 61 74 69 6f 6e 20 75 6c 6c 61
0000000A 6d 63 6f 20 6c 61 62 6f 72 69 73 20 6e 69 73 69 20 75
0000000B 74 20 61 6c 69 71 75 69 70 20 65 78 20 65 61 20 63 6f
0000000C 6d 6d 6f 64 6f 20 63 6f 6e 73 65 71 75 61 74 2e 20 44
0000000D 75 69 73 20 61 75 74 65 20 69 72 75 72 65 20 64 6f 6c
0000000E 6f 72 20 69 6e 20 72 65 70 72 65 68 65 6e 64 65 72 69
0000000F 74 20 69 6e 20 76 6f 6c 75 70 74 61 74 65 20 76 65 6c
00000010 69 74 20 65 73 73 65 20 63 69 6c 6c 75 6d 20 64 6f 6c
00000011 6f 72 65 20 65 75 20 66 75 67 69 61 74 20 6e 75 6c 6c
00000012 61 20 70 61 72 69 61 74 75 72 2e 20 45 78 63 65 70 74
00000013 65 75 72 20 73 69 6e 74 20 6f 63 63 61 65 63 61 74 20
00000014 63 75 70 69 64 61 74 61 74 20 6e 6f 6e 20 70 72 6f 69
00000015 64 65 6e 74 2c 20 73 75 6e 74 20 69 6e 20 63 75 6c 70
00000016 61 20 71 75 69 20 6f 66 66 69 63 69 61 20 64 65 73 65
00000017 72 75 6e 74 20 6d 6f 6c 6c 69 74 20 61 6e 69 6d 20 69
00000018 64 20 65 73 74 20 6c 61 62 6f 72 75 6d 2e

This code seems so long compared to others here. :(

Also... first post here!

EDIT: formatting

  • permalink
  • embed
  • save
  • give gold

[–]domlebo701 2 2 points3 points4 points 5 years ago* (3 children)

Java man :P It wouldn't be half as long if you were given some proper lambda
functionality (and could use higher-order functions). Notice how you are forced
to manage how you open and close a file, rather than having that handled for
you.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]Unh0ly_Tigg0 0 2 points3 points4 points 5 years ago (2 children)

Actually, if the

java.nio.file.Files.readAllBytes(file.toPath())

is used (returns a byte array), then opening and closing is handled by the

readAllBytes

method before it even returns...

EDIT: i wish that the auto-code hiding could be turned off per-comment

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]Sonnenhut 1 point2 points3 points 5 years ago (0 children)

Well thanks.

Saw that on the post of "dark_mage".

Unfortunately i don't have jdk 7 installed :)

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]domlebo701 2 0 points1 point2 points 5 years ago (0 children)

Ahh yep. Handy.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]swankystank 0 points1 point2 points 5 years ago (0 children)

Given that there's nothing you can really do on error, your if and 2 catches
aren't really necessary. also, the first 2 vars in main are pointless. fis
doesn't need a separate declaration. import java.io.*. etc.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–][deleted] 2 points3 points4 points 5 years ago* (0 children)

In Go:

I omitted error handling on opening / reading the file, because I'm lazy and to
make the code shorter.
EDIT: fixed the fact it wasn't printing the last line of hex

package main

import (
    "os"
    "io/ioutil"
    "fmt"
)

func main() {
    if len(os.Args) != 2 {
        fmt.Println("Usage: [EXE] [FILENAME]")
        return
    }

    file, _ := os.Open(os.Args[1])
    bytes, _ := ioutil.ReadAll(file)
    for i := 0; i < len(bytes); i++ {
        if i % 18 == 0 {
            fmt.Printf("\n%08x\t", i / 18)
        }
        fmt.Printf("%02x ", bytes[i])
    }
    fmt.Println()
}

  • permalink
  • embed
  • save

[–]lawlrng0 1 2 points3 points4 points 5 years ago* (1 child)

Python with the bonus.

Edit: Changed to 16.

with open(raw_input("Filename: "), 'rb') as data:
    byte = data.read()

byte_list = [[a for a in byte[i:i + 16]] for i in range(0, len(byte), 16)]

for i, line in enumerate(byte_list):
    print '%08x' % i,
    for b in line:
        print '%2s' % b if b.isalpha() else '%02x' % ord(b),
    print

Output:

Filename: george.py
00000000 0d 0a  w  i  t  h 20  o  p  e  n 28  r  a  w 5f
00000001  i  n  p  u  t 28 22  F  i  l  e  n  a  m  e 3a
00000002 20 22 29 2c 20 27  r  b 27 29 20  a  s 20  d  a
00000003  t  a 3a 0d 0a 20 20 20 20  b  y  t  e 20 3d 20
00000004  d  a  t  a 2e  r  e  a  d 28 29 0d 0a 0d 0a  b
00000005  y  t  e 5f  l  i  s  t 20 3d 20 5b 5b  a 20  f
00000006  o  r 20  a 20  i  n 20  b  y  t  e 5b  i 3a  i
00000007 20 2b 20 31 36 5d 5d 20  f  o  r 20  i 20  i  n
00000008 20  r  a  n  g  e 28 30 2c 20  l  e  n 28  b  y
00000009  t  e 29 2c 20 31 36 29 5d 0d 0a 0d 0a  f  o  r
0000000a 20  i 2c 20  l  i  n  e 20  i  n 20  e  n  u  m
0000000b  e  r  a  t  e 28  b  y  t  e 5f  l  i  s  t 29
0000000c 3a 0d 0a 20 20 20 20  p  r  i  n  t 20 27 25 30
0000000d 38  x 27 20 25 20  i 2c 0d 0a 20 20 20 20  f  o
0000000e  r 20  b 20  i  n 20  l  i  n  e 3a 0d 0a 20 20
0000000f 20 20 20 20 20 20  p  r  i  n  t 20 27 25 32  s
00000010 27 20 25 20  b 20  i  f 20  b 2e  i  s  a  l  p
00000011  h  a 28 29 20  e  l  s  e 20 27 25 30 32  x 27
00000012 20 25 20  o  r  d 28  b 29 2c 0d 0a 20 20 20 20
00000013  p  r  i  n  t 0d 0a

  • permalink
  • embed
  • save
  • give gold

[–]nint221 2[S] 2 points3 points4 points 5 years ago (0 children)

+1 Silver medal for doing a solid approach to the bonus challenge!

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]gavinflud0 0 2 points3 points4 points 5 years ago (0 children)

Done using Node.js since I've been learning that for the last couple of months.

Had to create a function to handle the line-count padding since I could find
any simple way to do it in JavaScript.

var fs = require('fs');

fs.readFile(process.argv[2], 'hex', function (err, data) {
  if (err) throw err;

  var output = "", lineCount = 0;
  for (i = 0; i < data.length; i++) {
    if (i === 0) output += pad(lineCount) + " ";
    output += data.charAt(i);
    if (i % 2 !== 0 && i !== 0) output += ' ';
    if ((i + 1) % 36 === 0 && i !== 0) {
      lineCount++;
      output += '\n' + pad(lineCount) + " ";
    }
  }
  console.log(output);
});

function pad(number) {
  var hex = number.toString(16);
  while (hex.length < 8) {
    hex = "0" + hex;
  }
  return hex;
}

Outputs the following:

00000000 4c 6f 72 65 6d 20 69 70 73 75 6d 20 64 6f 6c 6f 72 20
00000001 73 69 74 20 61 6d 65 74 2c 20 63 6f 6e 73 65 63 74 65
00000002 74 75 72 20 61 64 69 70 69 73 63 69 6e 67 20 65 6c 69
00000003 74 2e 20 51 75 69 73 71 75 65 20 6e 65 63 20 64 6f 6c
00000004 6f 72 20 64 69 61 6d 2e 20 50 72 61 65 73 65 6e 74 20
00000005 75 74 20 70 65 6c 6c 65 6e 74 65 73 71 75 65 20 66 65
00000006 6c 69 73 2e 20 4e 75 6e 63 20 6d 61 74 74 69 73 20 6c
00000007 69 62 65 72 6f 20 6e 65 63 20 6c 61 63 75 73 20 69 61
00000008 63 75 6c 69 73 20 65 67 65 73 74 61 73 2e 20 4e 75 6c
00000009 6c 61 6d 20 63 6f 6e 64 69 6d 65 6e 74 75 6d 20 75 6c
0000000a 74 72 69 63 65 73 20 66 61 75 63 69 62 75 73 2e 20 56
0000000b 69 76 61 6d 75 73 20 69 6e 74 65 72 64 75 6d 20 69 70
0000000c 73 75 6d 20 71 75 69 73 20 6c 65 63 74 75 73 20 76 65
0000000d 73 74 69 62 75 6c 75 6d 20 6e 65 63 20 65 6c 65 69 66
0000000e 65 6e 64 20 61 72 63 75 20 75 6c 74 72 69 63 69 65 73
0000000f 2e 20 50 72 6f 69 6e 20 6e 6f 6e 20 6e 69 73 69 20 61
00000010 72 63 75 2c 20 74 69 6e 63 69 64 75 6e 74 20 76 65 68
00000011 69 63 75 6c 61 20 6d 61 73 73 61 2e

  • permalink
  • embed
  • save
  • give gold

[–]tsahyt 2 points3 points4 points 5 years ago (0 children)

Quick and dirty C solution.

#include <stdio.h>
#include <error.h>
#include <errno.h>

static void print_file(FILE* file)
{
    int c;
    unsigned int bytecount, linecount;

    linecount = 0;
    bytecount = 0;

    while((c = getc(file)) != EOF)
    {
        if(bytecount == 0)
        {
            /* start of line, print position */
            printf("%08x  ", linecount);
            ++linecount;
        }

        /* actual char printing */
        printf("%02x ", (unsigned int)c);

        bytecount = (bytecount + 1) % 18;

        if(bytecount == 0) { printf("\n"); }
        else if(bytecount % 6 == 0) { printf(" "); }
    }

    printf("\n"); /* closing newline */
}

int main(int argc, const char *argv[])
{
    FILE* file;

    if(argc != 2) { return 1; }

    file = fopen(argv[1], "r");
    if(file)
    {
        print_file(file);
        fclose(file);
    }
    else { error(1, ENOENT, "Error opening file"); }

    return 0;
}

  • permalink
  • embed
  • save
  • give gold

[–]foreveranewbie 2 points3 points4 points 5 years ago (0 children)

Python:

from sys import argv

def hexdump(file_name):
    fin = open(file_name)
    byte = fin.read(1)
    line = 0
    while byte != "":
        print '%0.2X' % line,
        for i in range(18):
            if byte != '':
                print '%0.2X' % ord(byte),
                byte = fin.read(1)
            else:
                print '00',
        line += 1
        print ''


if __name__ == '__main__':
    hexdump(argv[1])

  • permalink
  • embed
  • save
  • give gold

[–]usea 2 points3 points4 points 5 years ago (1 child)

The description of the output says 18 bytes per line, but the example output
has 16 bytes per line.

  • permalink
  • embed
  • save
  • give gold

[–]nint221 2[S] 0 points1 point2 points 5 years ago (0 children)

Fixed! Thanks for catching that :-)

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]marekkpie 2 points3 points4 points 5 years ago (0 children)

Lua, without bonus:

local PER_LINE = 18

function hexconvert(filename)
  local contents = io.open(filename):read('*a')
  local bytes = { contents:byte(1, contents:len()) }
  local s = ''

  for i = 0, #bytes - 1 do
    if i % PER_LINE == 0 then
      s = s .. string.format('\n%x ', i / PER_LINE)
    end
    s = s .. string.format('%x ', bytes[i + 1])
  end
  s = s .. '\n'
  return s
end

for i = 1, #arg do
  print(arg[i])
  print(hexconvert(arg[i]))
end

  • permalink
  • embed
  • save
  • give gold

[–]redried1 0 2 points3 points4 points 5 years ago (0 children)

A nodeJS + underscore try.

_      = require('underscore'),
_.str = require('underscore.string'),
fs     = require('fs');

_.mixin(_.str.exports());  // Access _.str.fn() as _.fn()

var readStream = fs.createReadStream(process.argv[2], {
    'bufferSize': 18
});

var lineNum = 0;
readStream.on('data', function(chunk){
    process.stdout.write( _.sprintf("%08X  ", ++lineNum) );
    process.stdout.write(_.map(chunk, function(chr){
            return _.sprintf("%02X", chr);
     }).join(" "));
    process.stdout.write("\n");
});

  • permalink
  • embed
  • save
  • give gold

[–]bheinks0 0 2 points3 points4 points 5 years ago* (0 children)

Python

from sys import argv

data = open(argv[1], "rb").read()
blocks = [data[i:i + 16] for i in range(0, len(data), 16)]

for i in range(len(blocks)):
    print("{:08X}".format(i).ljust(12), end = '')
    print(' '.join(["{:02X}".format(byte) for byte in blocks[i]]).ljust(51), end = '')
    print(''.join(["{:c}".format(byte) if byte > 31 and byte < 127 else '.' for byte in blocks[i]]))

Edit: bonus

  • permalink
  • embed
  • save
  • give gold

[–]OniTux 2 points3 points4 points 5 years ago (0 children)

In Java : https://gist.github.com/4581236 (without bonus)

  • permalink
  • embed
  • save
  • give gold

[–]srhb0 1 1 point2 points3 points 5 years ago (0 children)

Haskell, using showHex from Numeric to do the actual hex conversion rather than
bitshuffling. Reads filename from STDIN.

import qualified Data.ByteString.Lazy as B (readFile, unpack)
import Numeric (showHex)
import Data.List.Split (chunksOf)

main :: IO ()
main = do
    fn <- getLine
    f  <- B.unpack `fmap` B.readFile fn

    mapM_ putStrLn $ zipWith (\n l -> n ++ " " ++ l) lno (line f)
  where
    hexPad n = map (pad n . flip showHex "")
    pad n s  = replicate (n - length s) '0' ++ s
    lno      = (hexPad 8) [1..]
    line     = map unwords . chunksOf 18 . (hexPad 2)

  • permalink
  • embed
  • save
  • give gold

[–]math_geek 1 point2 points3 points 5 years ago (0 children)

In Java:

package easy;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;



public class Challenge117 {

    public static void main(String[] args){
    byte[] bytes = null;
        try{
        bytes = Files.readAllBytes(Paths.get(args[0]));
    }catch(Exception e){
        System.out.println("Could not open file: "
                + e.getMessage());
        System.exit(1);
    }
    for(int i=0; i<bytes.length; i++){
        if(i>0 && i%18 ==0)
            System.out.printf("\n");
        if(i%18 == 0)
            System.out.printf("%08X ", i/18);
        if(bytes[i]>= 65 && bytes[i]<=90
           || bytes[i]>=97 && bytes[i]<=122)
            System.out.print((char)bytes[i]);
        else System.out.printf("%02X ", bytes[i]);
    }
    }
}

Run in Netbeans, applied to its own JAR file, with ASCII strings.

Output:

00000000 PK03 04 0A 00 00 08 00 00 0E Z2E B00 00 00 00
00000001 00 00 00 00 00 00 00 00 09 00 04 00 META2D I
00000002 NF2F FE CA 00 00 PK03 04 0A 00 00 08 00 00 0D
00000003 Z2E BFF 96 V35 D0 00 00 00 D0 00 00 00 14 00 00
00000004 00 META2D INF2F MANIFEST
00000005 2E MFManifest2D Versio
00000006 n3A 20 31 2E 30 0D 0A Ant2D Versio
00000007 n3A 20 Apache20 Ant20 31 2E 38 2E
00000008 33 0D 0A Created2D By3A 20 31 2E 37
00000009 2E 30 5F 30 34 2D b32 32 20 28 Oracle20
0000000A Corporation29 0D 0A Clas
0000000B s2D Path3A 20 0D 0A X2D COMMEN
0000000C T3A 20 Main2D Class20 will
0000000D 20 be20 added20 automati
0000000E cally20 by20 build0D 0A Ma
0000000F in2D Class3A 20 easy2E Cha
00000010 llenge31 31 37 0D 0A 0D 0A PK03 04 0A
00000011 00 00 08 00 00 IZ2E B00 00 00 00 00 00 00 00 00
00000012 00 00 00 05 00 00 00 easy2F PK03 04 0A 00
00000013 00 08 00 00 IZ2E BF03 oF1 I04 00 00 I04
00000014 00 00 17 00 00 00 easy2F Challen
00000015 ge31 31 37 2E classCA FE BA BE 00 00 00
00000016 33 00 C0A 00 07 00 23 07 00 24 0A 00 25 00 26 0A 00
00000017 27 00 28 09 00 29 00 2A 08 00 2B 07 00 2C 0A 00 2D 00
00000018 2E 0A 00 2F 00 30 07 00 31 01 00 06 3C init3E
00000019 01 00 03 28 29 V01 00 04 Code01 00 0F Li
0000001A neNumberTable01 00 12 Lo
0000001B calVariableTable01 00
0000001C 04 this01 00 13 Leasy2F Chal
0000001D lenge31 31 37 3B 01 00 04 main01 00
0000001E 16 28 5B Ljava2F lang2F Stri
0000001F ng3B 29 V01 00 01 i01 00 01 I01 00 04 ar
00000020 gs01 00 13 5B Ljava2F lang2F S
00000021 tring3B 01 00 05 bytes01 00 02 5B
00000022 B01 00 04 path01 00 14 Ljava2F n
00000023 io2F file2F Path3B 01 00 0D St
00000024 ackMapTable07 00 19 07 00 32 01
00000025 00 0A Exceptions07 00 33 01 00 0A
00000026 SourceFile01 00 11 Chall
00000027 enge31 31 37 2E java0C 00 0B 00 0C 01
00000028 00 10 java2F lang2F String
00000029 07 00 34 0C 00 35 00 36 07 00 37 0C 00 38 00 39 07 00
0000002A 3A 0C 00 3B 00 3C 01 00 04 25 30 38 X01 00 10 ja
0000002B va2F lang2F Object07 00 3D 0C
0000002C 00 3E 00 3F 07 00 40 0C 00 A00 B01 00 11 eas
0000002D y2F Challenge31 31 37 01 00 12 j
0000002E ava2F nio2F file2F Path01
0000002F 00 13 java2F lang2F Except
00000030 ion01 00 13 java2F nio2F fil
00000031 e2F Paths01 00 03 get01 00 3B 28 L
00000032 java2F lang2F String3B 5B
00000033 Ljava2F lang2F String3B
00000034 29 Ljava2F nio2F file2F Pa
00000035 th3B 01 00 13 java2F nio2F fil
00000036 e2F Files01 00 0C readAllB
00000037 ytes01 00 18 28 Ljava2F nio2F
00000038 file2F Path3B 29 5B B01 00 10 ja
00000039 va2F lang2F System01 00 03 o
0000003A ut01 00 15 Ljava2F io2F Prin
0000003B tStream3B 01 00 0E java2F la
0000003C ng2F Byte01 00 07 valueOf01
0000003D 00 13 28 B29 Ljava2F lang2F By
0000003E te3B 01 00 13 java2F io2F Prin
0000003F tStream01 00 06 printf01 00
00000040 3C 28 Ljava2F lang2F Strin
00000041 g3B 5B Ljava2F lang2F Obje
00000042 ct3B 29 Ljava2F io2F Print
00000043 Stream3B 00 21 00 0A 00 07 00 00 00 00 00
00000044 02 00 01 00 0B 00 0C 00 01 00 0D 00 00 00 2F 00 01 00
00000045 01 00 00 00 05 2A B7 00 01 B1 00 00 00 02 00 0E 00 00
00000046 00 06 00 01 00 00 00 11 00 0F 00 00 00 0C 00 01 00 00
00000047 00 05 00 10 00 11 00 00 00 09 00 12 00 13 00 02 00 0D
00000048 00 00 00 A6 00 07 00 04 00 00 00 35 2A 04 32 03 BD 00
00000049 02 B8 00 03 M2C B8 00 04 L03 3E 1D 2B BE A2 00 1F
0000004A B2 00 05 12 06 04 BD 00 07 Y03 2B 1D 33 B8 00 08 S
0000004B B6 00 09 W84 03 01 A7 FF E1 B1 00 00 00 03 00 0E 00
0000004C 00 00 1A 00 06 00 00 00 15 00 0B 00 16 00 10 00 17 00
0000004D 18 00 18 00 2E 00 17 00 34 00 1B 00 0F 00 00 00 2A 00
0000004E 04 00 12 00 22 00 14 00 15 00 03 00 00 00 35 00 16 00
0000004F 17 00 00 00 10 00 25 00 18 00 19 00 01 00 0B 00 2A 00
00000050 1A 00 1B 00 02 00 1C 00 00 00 0F 00 02 FE 00 12 07 00
00000051 1D 07 00 1E 01 FA 00 21 00 1F 00 00 00 04 00 01 00 20
00000052 00 01 00 21 00 00 00 02 00 22 PK01 02 14 03 0A 00
00000053 00 08 00 00 0E Z2E B00 00 00 00 00 00 00 00 00 00
00000054 00 00 09 00 04 00 00 00 00 00 00 00 10 00 ED A00 00
00000055 00 00 META2D INF2F FE CA 00 00 PK01
00000056 02 14 03 0A 00 00 08 00 00 0D Z2E BFF 96 V35 D0
00000057 00 00 00 D0 00 00 00 14 00 00 00 00 00 00 00 00 00 00
00000058 00 A4 81 2B 00 00 00 META2D INF2F MA
00000059 NIFEST2E MFPK01 02 14 03 0A 00 00
0000005A 08 00 00 IZ2E B00 00 00 00 00 00 00 00 00 00 00
0000005B 00 05 00 00 00 00 00 00 00 00 00 10 00 ED A2D 01 00
0000005C 00 easy2F PK01 02 14 03 0A 00 00 08 00 00
0000005D IZ2E BF03 oF1 I04 00 00 I04 00 00 17 00
0000005E 00 00 00 00 00 00 00 00 00 00 A4 81 P01 00 00 ea
0000005F sy2F Challenge31 31 37 2E cl
00000060 assPK05 06 00 00 00 00 04 00 04 00 F5 00 00
00000061 00 CE 05 00 00 00 00

  • permalink
  • embed
  • save
  • give gold

[–]jeff3030 2 1 point2 points3 points 5 years ago (0 children)

Here is my solution, in Python, with the bonus. I'll note that the description
says 18 bytes per line but the sample output shows 16 per line, so I went with
the latter (it can easily be tweaked in this code).

import itertools

input_file = "Segfault.class"

ascii_strings=[]

bytes_per_line = 16
min_ascii_str_len = 4

curr_ascii_str = []
curr_byte_line = []

line_num = 0

val_to_hex = {0: '0', 1: '1', 2: '2', 3: '3', 4: '4',
              5: '5', 6: '6', 7: '7', 8: '8', 9: '9',
              10: 'A', 11: 'B', 12: 'C', 13: 'D',
              14: 'E', 15: 'F'}

def to_hex(byte, min_digits=2):
    hex_digits = []
    while (byte > 0):
        hex_digits.insert(0, val_to_hex[byte % 16])
        byte /= 16
    return "".join(hex_digits).zfill(min_digits)

def to_hex_str(byte, min_digits=2):
    return to_hex(ord(byte), min_digits)

with open(input_file, "rb") as f:
    while True:
        byte = f.read(1)
        end = not byte
        # Do stuff with byte.
        if (not end):
            byte_ord = ord(byte)
            curr_byte_line.append(byte)

        if (not end and byte_ord >= 32 and byte_ord <= 126):
            curr_ascii_str.append(byte)
        else:
            if (len(curr_ascii_str) >= min_ascii_str_len):
                ascii_strings.append("".join(curr_ascii_str))
            curr_ascii_str = []

        if (len(curr_byte_line) == bytes_per_line or end):
            enc_line = map(to_hex_str, curr_byte_line)
            print(("{:s}"+"".join(itertools.repeat(" {:s}", len(curr_byte_line)))).format(to_hex(line_num,8),*enc_line))
            curr_byte_line = []
            line_num += 1

        if end:
            break

    if (len(curr_ascii_str) >= min_ascii_str_len):
        ascii_strings.append("".join(curr_ascii_str))

print("\n")
for ascii_str in ascii_strings:
    print(ascii_str)

For my file input, I used the Java .class file that is generated by compiling
the following source code using javac from JDK 6 update 23 (found on reddit
sometime a while back):

/*
 * Code for generating a segmentation fault in Java 1.6. Tested on Sun Java compiler for Ubuntu 10.04-10.10, i386/amd64. And SunOS.
 * Written by daedalusinfinity "cinnamon bun" gmail "dot" com
 */

public class Segfault
{
        public static void main( String[] args )
        {
                Object[] yoDawgIHeardYouLikedSegfaults = new Object[1], soIPutAnObjectArrayInYourObjectArray = yoDawgIHeardYouLikedSegfaults;
                while( yoDawgIHeardYouLikedSegfaults != null )
                {
                        soIPutAnObjectArrayInYourObjectArray[0] = new Object[1];
                        soIPutAnObjectArrayInYourObjectArray = (Object[]) soIPutAnObjectArrayInYourObjectArray[0];
                }
                System.out.println( "So you could segfault while you... what the hell?" );
        }
}

For the bonus part (ASCII strings), I tried to emulate the behavior of the GNU
strings program, which considers a minimum length of 4 printable characters to
be a string, and for the set of printable characters I used this.

Output:

00000000 CA FE BA BE 00 00 00 32 00 20 0A 00 02 00 11 07
00000001 00 12 07 00 13 09 00 14 00 15 08 00 16 0A 00 17
00000002 00 18 07 00 19 01 00 06 3C 69 6E 69 74 3E 01 00
00000003 03 28 29 56 01 00 04 43 6F 64 65 01 00 0F 4C 69
00000004 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65 01 00 04
00000005 6D 61 69 6E 01 00 16 28 5B 4C 6A 61 76 61 2F 6C
00000006 61 6E 67 2F 53 74 72 69 6E 67 3B 29 56 01 00 0D
00000007 53 74 61 63 6B 4D 61 70 54 61 62 6C 65 01 00 0A
00000008 53 6F 75 72 63 65 46 69 6C 65 01 00 0D 53 65 67
00000009 66 61 75 6C 74 2E 6A 61 76 61 0C 00 08 00 09 01
0000000A 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65
0000000B 63 74 01 00 13 5B 4C 6A 61 76 61 2F 6C 61 6E 67
0000000C 2F 4F 62 6A 65 63 74 3B 07 00 1A 0C 00 1B 00 1C
0000000D 01 00 31 53 6F 20 79 6F 75 20 63 6F 75 6C 64 20
0000000E 73 65 67 66 61 75 6C 74 20 77 68 69 6C 65 20 79
0000000F 6F 75 2E 2E 2E 20 77 68 61 74 20 74 68 65 20 68
00000010 65 6C 6C 3F 07 00 1D 0C 00 1E 00 1F 01 00 08 53
00000011 65 67 66 61 75 6C 74 01 00 10 6A 61 76 61 2F 6C
00000012 61 6E 67 2F 53 79 73 74 65 6D 01 00 03 6F 75 74
00000013 01 00 15 4C 6A 61 76 61 2F 69 6F 2F 50 72 69 6E
00000014 74 53 74 72 65 61 6D 3B 01 00 13 6A 61 76 61 2F
00000015 69 6F 2F 50 72 69 6E 74 53 74 72 65 61 6D 01 00
00000016 07 70 72 69 6E 74 6C 6E 01 00 15 28 4C 6A 61 76
00000017 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B 29 56
00000018 00 21 00 07 00 02 00 00 00 00 00 02 00 01 00 08
00000019 00 09 00 01 00 0A 00 00 00 1D 00 01 00 01 00 00
0000001A 00 05 2A B7 00 01 B1 00 00 00 01 00 0B 00 00 00
0000001B 06 00 01 00 00 00 06 00 09 00 0C 00 0D 00 01 00
0000001C 0A 00 00 00 66 00 03 00 03 00 00 00 28 04 BD 00
0000001D 02 4C 2B 4D 2B C6 00 17 2C 03 04 BD 00 02 53 2C
0000001E 03 32 C0 00 03 C0 00 03 4D A7 FF EB B2 00 04 12
0000001F 05 B6 00 06 B1 00 00 00 02 00 0B 00 00 00 1A 00
00000020 06 00 00 00 0A 00 07 00 0B 00 0B 00 0D 00 12 00
00000021 0E 00 1F 00 10 00 27 00 11 00 0E 00 00 00 0C 00
00000022 02 FD 00 07 07 00 03 07 00 03 17 00 01 00 0F 00
00000023 00 00 02 00 10


<init>
Code
LineNumberTable
main
([Ljava/lang/String;)V
StackMapTable
SourceFile
Segfault.java
java/lang/Object
[Ljava/lang/Object;
1So you could segfault while you... what the hell?
Segfault
java/lang/System
Ljava/io/PrintStream;
java/io/PrintStream
println
(Ljava/lang/String;)V
L+M+

  • permalink
  • embed
  • save
  • give gold

[–]DannyP72 1 point2 points3 points 5 years ago* (0 children)

Ruby

def hex(input)
  count, line = 0, 0
  input.each_byte do |x|
    if count%18 == 0
      puts ""
      print line.to_s(16).rjust(8,"0")
      line += 1
    end
    print " #{x.to_s(16)}"
    count += 1
  end
  puts ""
end

input = File.read(ARGV[0])
hex(input)

  • permalink
  • embed
  • save
  • give gold

[–]AgoAndAnon0 1 1 point2 points3 points 5 years ago (1 child)

Hah. I needed to do this for a tool I use in my workplace, which retrieves
files stored in our Oracle DB as hex, writes them to a file, and then converts
those hex files to binary files. Here's a one-line piece of bash script that I
use for files which don't have line numbers.

perl -i -ne 'print chr hex $1 while /([0-9a-f]{2})/ig' filename

  • permalink
  • embed
  • save
  • give gold

[–]nint221 2[S] 0 points1 point2 points 5 years ago (0 children)

Hey hey, even more cool at how tiny this is! I don't want our coding challenges
to focus on "make code as tiny as possible", but I'll give you a +1 silver
medal regardless. Nice work!

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]xsdc 1 point2 points3 points 5 years ago (0 children)

dirty, horrible PowerShell

<code>

Function Get-Hex {
param(
[Parameter(Mandatory=$true)]
[String]$file
)
    $fs = (Get-Item $file -Force).OpenRead()
    [Byte[]]$bytes = new-object Byte[] $fs.Length
    $fs.Read($bytes,0,[Convert]::ToInt32($fs.Length))| out-Null
    $i= 0;$line=0
    $sb = new-object System.Text.StringBuilder
    $sb.Append($line.ToString("X8")) | out-Null
    foreach ($byte in $bytes) {
        $maybe = [System.Text.Encoding]::Ascii.GetString($byte)
        if ([String]::IsNullOrWhitespace($maybe) -or $maybe -eq '?') {
            $sb.Append([String]::Format(" {0:X2}", $byte))| out-Null
        }else {
            $sb.Append(" $maybe")| out-Null
        }
        $i++
        if ($i % 18 -eq 0) {
            $line++
            $sb.AppendLine()| out-Null
            $sb.Append($line.ToString("X8"))| out-Null
        }
    }
    $sb.ToString();
}

<input> (my desktop.ini)

[.ShellClassInfo]
LocalizedResourceName=@%SystemRoot%\system32\shell32.dll,-21769
IconResource=%SystemRoot%\system32\imageres.dll,-183

<output>

00000000 FF FE 0D   0A   [   .   S   h   e   l
00000001 l   C   l   a   s   s   I   n   f
00000002 o   ]   0D   0A   L   o   c   a   l
00000003 i   z   e   d   R   e   s   o   u
00000004 r   c   e   N   a   m   e   =   @
00000005 %   S   y   s   t   e   m   R   o
00000006 o   t   %   \   s   y   s   t   e
00000007 m   3   2   \   s   h   e   l   l
00000008 3   2   .   d   l   l   ,   -   2
00000009 1   7   6   9   0D   0A   I   c   o
0000000A n   R   e   s   o   u   r   c   e
0000000B =   %   S   y   s   t   e   m   R
0000000C o   o   t   %   \   s   y   s   t
0000000D e   m   3   2   \   i   m   a   g
0000000E e   r   e   s   .   d   l   l   ,
0000000F -   1   8   3   0D   0A

  • permalink
  • embed
  • save
  • give gold

[–]zakrn 1 point2 points3 points 5 years ago (1 child)

MFC

CFile tmpFile;
CString strOut;
CStringArray aHex;
if( tmpFile.Open( strIn, CFile::modeRead ) )
{
    int iLineCount = 1;
    int iByteCount = 1;
    char pBuf[2];
    memset( &pBuf[0], 0, 2 );
    while( tmpFile.Read( pBuf, 1 ) )
    {
        CString strByte;
        int q = pBuf[0];
        strByte.Format( _T("%02x"), q );
        strByte.MakeUpper();

        if( iByteCount%16 == 0 )
        {
            aHex.Add( strByte );
            strOut.Format( _T("%08x"), iLineCount );
            for( int i =0 ; i < aHex.GetSize(); i++ )
            {
                strOut.AppendFormat( _T(" %s"), aHex[i] );
            }
            PrintString( strOut );
            aHex.RemoveAll();

            iLineCount++;
            iByteCount = 1;
        }
        else
        {
            aHex.Add( strByte );
            iByteCount++;
        }
    }
}

  • permalink
  • embed
  • save
  • give gold

[–]drch0 1 0 points1 point2 points 5 years ago (0 children)

I think that will only output full 16-byte blocks. If a file were 20 bytes, it
wouldn't output the last 4.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]HilgerZzZ 1 point2 points3 points 5 years ago* (0 children)

Python:

def toHex(f):
    data = open(f).read()
    stringSoFar = ''
    line = 1
    for byte in data:
        byte = hex(ord(byte))[2:].upper()
        if len(byte) == 1:
            byte = '0' + byte
        stringSoFar += ' %s' % byte
        if len(stringSoFar) % 48 == 0:
            hexLine = '0' * (8 - len(hex(line)[2:])) + hex(line)[2:]
            print hexLine + stringSoFar + '\n'
            line += 1
            stringSoFar = ''
    if stringSoFar != '':
        hexLine = '0' * (8 - len(hex(line)[2:])) + hex(line)[2:]
        print hexLine + stringSoFar

Output of itself:

00000001 66 20 3D 20 27 74 6F 48 65 78 2E 70 79 27 0A 0A

00000002 64 65 66 20 74 6F 48 65 78 28 66 29 3A 0A 20 20

00000003 20 20 64 61 74 61 20 3D 20 6F 70 65 6E 28 66 29

00000004 2E 72 65 61 64 28 29 0A 20 20 20 20 73 74 72 69

00000005 6E 67 53 6F 46 61 72 20 3D 20 27 27 0A 20 20 20

00000006 20 6C 69 6E 65 20 3D 20 31 0A 20 20 20 20 66 6F

00000007 72 20 62 79 74 65 20 69 6E 20 64 61 74 61 3A 0A

00000008 20 20 20 20 20 20 20 20 62 79 74 65 20 3D 20 68

00000009 65 78 28 6F 72 64 28 62 79 74 65 29 29 5B 32 3A

0000000a 5D 2E 75 70 70 65 72 28 29 0A 20 20 20 20 20 20

0000000b 20 20 69 66 20 6C 65 6E 28 62 79 74 65 29 20 3D

0000000c 3D 20 31 3A 0A 20 20 20 20 20 20 20 20 20 20 20

0000000d 20 62 79 74 65 20 3D 20 27 30 27 20 2B 20 62 79

0000000e 74 65 0A 20 20 20 20 20 20 20 20 73 74 72 69 6E

0000000f 67 53 6F 46 61 72 20 2B 3D 20 27 20 25 73 27 20

00000010 25 20 62 79 74 65 0A 20 20 20 20 20 20 20 20 69

00000011 66 20 6C 65 6E 28 73 74 72 69 6E 67 53 6F 46 61

00000012 72 29 20 25 20 34 38 20 3D 3D 20 30 3A 0A 20 20

00000013 20 20 20 20 20 20 20 20 20 20 68 65 78 4C 69 6E

00000014 65 20 3D 20 27 30 27 20 2A 20 28 38 20 2D 20 6C

00000015 65 6E 28 68 65 78 28 6C 69 6E 65 29 5B 32 3A 5D

00000016 29 29 20 2B 20 68 65 78 28 6C 69 6E 65 29 5B 32

00000017 3A 5D 0A 20 20 20 20 20 20 20 20 20 20 20 20 70

00000018 72 69 6E 74 20 68 65 78 4C 69 6E 65 20 2B 20 73

00000019 74 72 69 6E 67 53 6F 46 61 72 20 2B 20 27 5C 6E

0000001a 27 0A 20 20 20 20 20 20 20 20 20 20 20 20 6C 69

0000001b 6E 65 20 2B 3D 20 31 0A 20 20 20 20 20 20 20 20

0000001c 20 20 20 20 73 74 72 69 6E 67 53 6F 46 61 72 20

0000001d 3D 20 27 27 0A 20 20 20 20 69 66 20 73 74 72 69

0000001e 6E 67 53 6F 46 61 72 20 21 3D 20 27 27 3A 0A 20

0000001f 20 20 20 20 20 20 20 68 65 78 4C 69 6E 65 20 3D

00000020 20 27 30 27 20 2A 20 28 38 20 2D 20 6C 65 6E 28

00000021 68 65 78 28 6C 69 6E 65 29 5B 32 3A 5D 29 29 20

00000022 2B 20 68 65 78 28 6C 69 6E 65 29 5B 32 3A 5D 0A

00000023 20 20 20 20 20 20 20 20 70 72 69 6E 74 20 68 65

00000024 78 4C 69 6E 65 20 2B 20 73 74 72 69 6E 67 53 6F

00000025 46 61 72 0A 0A 74 6F 48 65 78 28 66 29 0A

  • permalink
  • embed
  • save
  • give gold

[–]RainbowNowOpen 1 point2 points3 points 5 years ago* (1 child)

A solution in C:

#include <stdio.h>

int main(int argc, char **argv) {
  FILE *f = fopen(argv[1], "r");
  int c, cc, lc;
  while ((c=fgetc(f)) != EOF) {
    if (!(cc % 16)) printf("%08X", lc);
    printf(" %02X", c);
    if (cc++ % 16 == 15) { printf("\n"); ++lc; }
  }
  if (cc % 16) printf("\n");
  return 0;
}

Output, using random bytes as input: (my program is called '117')

$ head -c 88 /dev/random > rnd.out
$ ./117 rnd.out
00000000 AC 8E 67 DF B3 9E 6F 11 F7 10 B1 D5 11 F8 AE 89
00000001 E8 81 CC 5B DC 07 85 E9 DE A7 FC 22 62 F0 5E 17
00000002 A4 D9 0B BA 3B EE 8C A2 C2 B9 81 A0 9B 5D D0 40
00000003 FD BE 7F F6 FF 94 38 EA E5 3A 6F 70 89 B5 CF 74
00000004 56 D7 7D A3 78 29 3F 84 16 32 76 4C FB 70 5C C9
00000005 3F FC F2 7D 27 3C 5A 9D

  • permalink
  • embed
  • save
  • give gold

[–]RainbowNowOpen 0 points1 point2 points 5 years ago (0 children)

Same as above, in C, now with ASCII printing. I wanted to format the ASCII part
like a traditional hex dump, so short final lines was primary challenge.

#include <stdio.h>

int main(int argc, char **argv) {
  FILE *f = fopen(argv[1], "r");
  int c, cc, lc;
  char a[17];
  a[16] = 0;
  while ((c=fgetc(f)) != EOF) {
    if (!(cc % 16)) printf("%08X", lc);
    printf(" %02X", c);
    a[cc%16] = c > 31 && c < 127 ? c : '.';
    if (cc++ % 16 == 15) { printf(" %s\n", a); ++lc; }
  }
  if (cc % 16) {
    a[cc%=16] = 0;
    while (cc++ < 16) printf("   ");
    printf(" %s\n", a);
  }
  return 0;
}

Output, given its own source as input: (tailing the output to save space here)

$ ./117 117.c | tail -n 13
00008010 63 20 3C 20 31 32 37 20 3F 20 63 20 3A 20 27 2E c < 127 ? c : '.
00008011 27 3B 0A 09 09 20 20 20 20 69 66 20 28 63 63 2B ';...    if (cc+
00008012 2B 20 25 20 31 36 20 3D 3D 20 31 35 29 20 7B 20 + % 16 == 15) {
00008013 70 72 69 6E 74 66 28 22 20 25 73 5C 6E 22 2C 20 printf(" %s\n",
00008014 61 29 3B 20 2B 2B 6C 63 3B 20 7D 0A 09 09 20 20 a); ++lc; }...
00008015 7D 0A 09 09 20 20 69 66 20 28 63 63 20 25 20 31 }...  if (cc % 1
00008016 36 29 20 7B 0A 09 09 20 20 09 61 5B 63 63 25 3D 6) {...  .a[cc%=
00008017 31 36 5D 20 3D 20 30 3B 0A 09 09 20 20 09 77 68 16] = 0;...  .wh
00008018 69 6C 65 20 28 63 63 2B 2B 20 3C 20 31 36 29 20 ile (cc++ < 16)
00008019 70 72 69 6E 74 66 28 22 20 20 20 22 29 3B 0A 09 printf("   ");..
0000801A 09 20 20 09 70 72 69 6E 74 66 28 22 20 25 73 5C .  .printf(" %s\
0000801B 6E 22 2C 20 61 29 3B 0A 09 09 20 20 7D 0A 09 09 n", a);...  }...
0000801C 20 20 72 65 74 75 72 6E 20 30 3B 0A 09 09 7D      return 0;...}

Output, given its own binary as input: (again, tailing to save space)

$ ./117 117 | tail -n 13
00008224 0D 00 00 00 0E 00 00 00 00 00 00 40 09 00 00 00 ...........@....
00008225 08 00 00 00 0A 00 00 00 0B 00 00 00 0C 00 00 00 ................
00008226 0D 00 00 00 20 00 5F 70 76 61 72 73 00 5F 4E 58 .... ._pvars._NX
00008227 41 72 67 63 00 5F 4E 58 41 72 67 76 00 5F 5F 5F Argc._NXArgv.___
00008228 70 72 6F 67 6E 61 6D 65 00 5F 5F 6D 68 5F 65 78 progname.__mh_ex
00008229 65 63 75 74 65 5F 68 65 61 64 65 72 00 5F 65 6E ecute_header._en
0000822A 76 69 72 6F 6E 00 5F 6D 61 69 6E 00 73 74 61 72 viron._main.star
0000822B 74 00 5F 5F 5F 73 74 61 63 6B 5F 63 68 6B 5F 66 t.___stack_chk_f
0000822C 61 69 6C 00 5F 5F 5F 73 74 61 63 6B 5F 63 68 6B ail.___stack_chk
0000822D 5F 67 75 61 72 64 00 5F 65 78 69 74 00 5F 66 67 _guard._exit._fg
0000822E 65 74 63 00 5F 66 6F 70 65 6E 00 5F 70 72 69 6E etc._fopen._prin
0000822F 74 66 00 64 79 6C 64 5F 73 74 75 62 5F 62 69 6E tf.dyld_stub_bin
00008230 64 65 72 00                                     der.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]kirsybuu0 1 1 point2 points3 points 5 years ago (3 children)

D Language!

No bonus:

import std.stdio;
void main(string[] argv) {
    size_t i = 0;
    foreach(line; File(argv[1], "r").byChunk(18)) {
        writefln("%10d | %(%2x %)", i, line);
        i++;
    }
}

Bonus:

import std.stdio;
void main(string[] argv) {
    size_t i = 0;
    foreach(line; File(argv[1], "r").byChunk(18)) {
        writef("%10d | ", i);
        foreach(b ; line) {
            import std.ascii;
            if (isPrintable(b)) writef("\'%c ", b);
            else                writef("%2x ", b);
        }
        writeln();
        i++;
    }
}

Sample output with bonus:

         0 | 'i 'm 'p 'o 'r 't '  's 't 'd '. 's 't 'd 'i 'o ';  a
         1 |  a 'v 'o 'i 'd '  'm 'a 'i 'n '( 's 't 'r 'i 'n 'g '[
         2 | '] '  'a 'r 'g 'v ') '  '{  a '  '  '  '  's 'i 'z 'e
         3 | '_ 't '  'i '  '= '  '0 ';  a '  '  '  '  'f 'o 'r 'e
         4 | 'a 'c 'h '( 'u 'b 'y 't 'e '[ '] '  'l 'i 'n 'e '; '
         5 | 'F 'i 'l 'e '( 'a 'r 'g 'v '[ '1 '] ', '  '" 'r '" ')
         6 | '. 'b 'y 'C 'h 'u 'n 'k '( '1 '8 ') ') '  '{  a '  '
         7 | '  '  '  '  '  '  'w 'r 'i 't 'e 'f '( '" '% '1 '0 'd
         8 | '  '| '  '" ', '  'i ') ';  a '  '  '  '  '  '  '  '
         9 |  a '  '  '  '  '  '  '  '  'f 'o 'r 'e 'a 'c 'h '( 'b
        10 | '  '; '  'l 'i 'n 'e ') '  '{  a '  '  '  '  '  '  '
        11 | '  '  '  '  '  'i 'm 'p 'o 'r 't '  's 't 'd '. 'a 's
        12 | 'c 'i 'i ';  a '  '  '  '  '  '  '  '  '  '  '  '  'i
        13 | 'f '  '( 'i 's 'P 'r 'i 'n 't 'a 'b 'l 'e '( 'b ') ')
        14 | '  'w 'r 'i 't 'e 'f '( '" '\ '' '% 'c '  '" ', '  'c
        15 | 'a 's 't '( 'c 'h 'a 'r ') '  'b ') ';  a '  '  '  '
        16 | '  '  '  '  '  '  '  '  'e 'l 's 'e '  '  '  '  '  '
        17 | '  '  '  '  '  '  '  '  '  '  'w 'r 'i 't 'e 'f '( '"
        18 | '% '2 'x '  '" ', '  'b ') ';  a '  '  '  '  '  '  '
        19 | '  '}  a '  '  '  '  '  '  '  '  'w 'r 'i 't 'e 'l 'n
        20 | '( ') ';  a '  '  '  '  '  '  '  '  'i '+ '+ ';  a '
        21 | '  '  '  '}  a '}  a  a 'v 'o 'i 'd '  'm 'a 'i 'n 'N
        22 | 'o 'B 'o 'n 'u 's '( 's 't 'r 'i 'n 'g '[ '] '  'a 'r
        23 | 'g 'v ') '  '{  a '  '  '  '  's 'i 'z 'e '_ 't '  'i
        24 | '  '= '  '0 ';  a '  '  '  '  'f 'o 'r 'e 'a 'c 'h '(
        25 | 'u 'b 'y 't 'e '[ '] '  'l 'i 'n 'e '; '  'F 'i 'l 'e
        26 | '( 'a 'r 'g 'v '[ '1 '] ', '  '" 'r '" ') '. 'b 'y 'C
        27 | 'h 'u 'n 'k '( '1 '8 ') ') '  '{  a '  '  '  '  '  '
        28 | '  '  'w 'r 'i 't 'e 'f 'l 'n '( '" '% '1 '0 'd '  '|
        29 | '  '% '( '% '2 'x '  '% ') '" ', '  'i ', '  'l 'i 'n
        30 | 'e ') ';  a '  '  '  '  '  '  '  '  'i '+ '+ ';  a '
        31 | '  '  '  '}  a '}

Same output without bonus:

         0 | 69 6d 70 6f 72 74 20 73 74 64 2e 73 74 64 69 6f 3b  a
         1 |  a 76 6f 69 64 20 6d 61 69 6e 32 28 73 74 72 69 6e 67
         2 | 5b 5d 20 61 72 67 76 29 20 7b  a 20 20 20 20 73 69 7a
         3 | 65 5f 74 20 69 20 3d 20 30 3b  a 20 20 20 20 66 6f 72
         4 | 65 61 63 68 28 75 62 79 74 65 5b 5d 20 6c 69 6e 65 3b
         5 | 20 46 69 6c 65 28 61 72 67 76 5b 31 5d 2c 20 22 72 22
         6 | 29 2e 62 79 43 68 75 6e 6b 28 31 38 29 29 20 7b  a 20
         7 | 20 20 20 20 20 20 20 77 72 69 74 65 66 28 22 25 31 30
         8 | 64 20 7c 20 22 2c 20 69 29 3b  a 20 20 20 20 20 20 20
         9 | 20  a 20 20 20 20 20 20 20 20 66 6f 72 65 61 63 68 28
        10 | 62 20 3b 20 6c 69 6e 65 29 20 7b  a 20 20 20 20 20 20
        11 | 20 20 20 20 20 20 69 6d 70 6f 72 74 20 73 74 64 2e 61
        12 | 73 63 69 69 3b  a 20 20 20 20 20 20 20 20 20 20 20 20
        13 | 69 66 20 28 69 73 50 72 69 6e 74 61 62 6c 65 28 62 29
        14 | 29 20 77 72 69 74 65 66 28 22 5c 27 25 63 20 22 2c 20
        15 | 62 29 3b  a 20 20 20 20 20 20 20 20 20 20 20 20 65 6c
        16 | 73 65 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
        17 | 77 72 69 74 65 66 28 22 25 32 78 20 22 2c 20 62 29 3b
        18 |  a 20 20 20 20 20 20 20 20 7d  a 20 20 20 20 20 20 20
        19 | 20 77 72 69 74 65 6c 6e 28 29 3b  a 20 20 20 20 20 20
        20 | 20 20 69 2b 2b 3b  a 20 20 20 20 7d  a 7d  a  a 76 6f
        21 | 69 64 20 6d 61 69 6e 28 73 74 72 69 6e 67 5b 5d 20 61
        22 | 72 67 76 29 20 7b  a 20 20 20 20 73 69 7a 65 5f 74 20
        23 | 69 20 3d 20 30 3b  a 20 20 20 20 66 6f 72 65 61 63 68
        24 | 28 75 62 79 74 65 5b 5d 20 6c 69 6e 65 3b 20 46 69 6c
        25 | 65 28 61 72 67 76 5b 31 5d 2c 20 22 72 22 29 2e 62 79
        26 | 43 68 75 6e 6b 28 31 38 29 29 20 7b  a 20 20 20 20 20
        27 | 20 20 20 77 72 69 74 65 66 6c 6e 28 22 25 31 30 64 20
        28 | 7c 20 25 28 25 32 78 20 25 29 22 2c 20 69 2c 20 6c 69
        29 | 6e 65 29 3b  a 20 20 20 20 20 20 20 20 69 2b 2b 3b  a
        30 | 20 20 20 20 7d  a 7d

  • permalink
  • embed
  • save
  • give gold

[–]leonardo_m 0 points1 point2 points 5 years ago (1 child)

Your "No bonus" version with some changes:

import std.algorithm, std.range, std.typecons, std.traits, std.array;

struct Enumerate(R) {
    R r;
    int i;
    alias r this;

    @property Tuple!(typeof(this.i), typeof(R.init.front)) front() {
        return typeof(return)(i, this.r.front);
    }

    void popFront() {
        this.r.popFront();
        this.i++;
    }
}

Enumerate!R enumerate(R)(R range, int start=0) if (isInputRange!R) {
    return Enumerate!R(range, start);
}

// --------------------------

import std.stdio, std.ascii;

void main(in string[] args) {
    foreach (i, line; File(args[1], "rb").byChunk(18).enumerate())
        writefln("%10d | %(%02X %)", i, line);
}

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]kirsybuu0 1 0 points1 point2 points 5 years ago (0 children)

I do wish an enumerate() like that was in std.range because of things like
byChunk() which don't enumerate by themselves. I tried to keep it simple.

Also, I didn't know about doing %02X, that's closer to the problem
specifications than %2x.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]nint221 2[S] 0 points1 point2 points 5 years ago (0 children)

So though you didn't follow the exact formatting, you still did a very nice
clean solution with an awesome approach to the bonus formatting. +1 silver
medal!

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]Rup-Inc 1 point2 points3 points 5 years ago (0 children)

My solution in c++, I might of done better if I removed the for loop and just
used the lineNumber count for working out when do place new lines.

#include <iostream>
#include <fstream>
#include <iomanip>

void putChar(std::fstream::int_type ch) {
    if (ch < 0) return; // end of file handling
    std::cout << std::setw(2) << ch << " ";
}

int main(int argc, char* argv[]) {
    if (argc != 2) {
        std::cout << "Please specify a input file" << std::endl; return 1;
    }

    std::fstream file(argv[1], std::ios::in | std::ios::binary);
    unsigned int lineNum = 0;

    // set up the output stream
    std::cout << std::hex << std::setfill('0');

    while (!file.eof()) {
        std::cout << std::setw(sizeof(lineNum)*2) << lineNUm << " ";
        for (int i = 0; i < 16; i++) {
            putChar(file.get());
        }
        std::cout << std::endl;
        lineNum += 16;
    }
}

  • permalink
  • embed
  • save
  • give gold

[–]fishbot 1 point2 points3 points 5 years ago (1 child)

Python:

#!/usr/bin/env python

import sys
if len(sys.argv) > 1:
  f = open(sys.argv[1], 'rb')
  count = 0
  while True:
    line = f.read(16)
    if line == b'': break
    h = ["{:02x}".format(i) for i in line]
    print("{:08x} {}".format(count, ' '.join(h)))
    count = count + 1
  f.close()
else:
  print("Usage:\n117e.py <fn>")

Output of ./117e.py 117e.py:

00000000 23 21 2f 75 73 72 2f 62 69 6e 2f 65 6e 76 20 70
00000001 79 74 68 6f 6e 0a 0a 69 6d 70 6f 72 74 20 73 79
00000002 73 0a 69 66 20 6c 65 6e 28 73 79 73 2e 61 72 67
00000003 76 29 20 3e 20 31 3a 0a 09 66 20 3d 20 6f 70 65
00000004 6e 28 73 79 73 2e 61 72 67 76 5b 31 5d 2c 20 27
00000005 72 62 27 29 0a 09 63 6f 75 6e 74 20 3d 20 30 0a
00000006 09 77 68 69 6c 65 20 54 72 75 65 3a 0a 09 09 6c
00000007 69 6e 65 20 3d 20 66 2e 72 65 61 64 28 31 36 29
00000008 0a 09 09 69 66 20 6c 69 6e 65 20 3d 3d 20 62 27
00000009 27 3a 20 62 72 65 61 6b 0a 09 09 68 20 3d 20 5b
0000000a 22 7b 3a 30 32 78 7d 22 2e 66 6f 72 6d 61 74 28
0000000b 69 29 20 66 6f 72 20 69 20 69 6e 20 6c 69 6e 65
0000000c 5d 0a 09 09 70 72 69 6e 74 28 22 7b 3a 30 38 78
0000000d 7d 20 7b 7d 22 2e 66 6f 72 6d 61 74 28 63 6f 75
0000000e 6e 74 2c 20 27 20 27 2e 6a 6f 69 6e 28 68 29 29
0000000f 29 0a 09 09 63 6f 75 6e 74 20 3d 20 63 6f 75 6e
00000010 74 20 2b 20 31 0a 09 66 2e 63 6c 6f 73 65 28 29
00000011 0a 65 6c 73 65 3a 0a 09 70 72 69 6e 74 28 22 55
00000012 73 61 67 65 3a 5c 6e 31 31 37 2e 70 79 20 3c 66
00000013 6e 3e 22 29 0a

  • permalink
  • embed
  • save
  • give gold

[–]fishbot 0 points1 point2 points 5 years ago (0 children)

After thinking about if for a few minutes, here is an update with the bonus:
Python (3):

#!/usr/bin/env python

import sys
if len(sys.argv) > 1:
  f = open(sys.argv[1], 'rb')
  count = 0
  while True:
    line = f.read(16)
    if line == b'': break
    h = ["{:02x}".format(i) for i in line]
    a = ["{}".format(chr(i))\
        if i > 31 and i < 127 else "{:02x}".format(i) for i in line]
    print("{:08x}    {}    {}".\
        format(count, ' '.join(h), ' '.join(a)))
    count = count + 1
  f.close()
else:
  print("Usage:\n117e.py <fn>")

Output (The last line is screwed up, but it's bed time):

00000000    23 21 2f 75 73 72 2f 62 69 6e 2f 65 6e 76 20 70    # ! / u s r / b i n / e n v   p
00000001    79 74 68 6f 6e 0a 0a 69 6d 70 6f 72 74 20 73 79    y t h o n 0a 0a i m p o r t   s y
00000002    73 0a 69 66 20 6c 65 6e 28 73 79 73 2e 61 72 67    s 0a i f   l e n ( s y s . a r g
00000003    76 29 20 3e 20 31 3a 0a 09 66 20 3d 20 6f 70 65    v )   >   1 : 0a 09 f   =   o p e
00000004    6e 28 73 79 73 2e 61 72 67 76 5b 31 5d 2c 20 27    n ( s y s . a r g v [ 1 ] ,   '
00000005    72 62 27 29 0a 09 63 6f 75 6e 74 20 3d 20 30 0a    r b ' ) 0a 09 c o u n t   =   0 0a
00000006    09 77 68 69 6c 65 20 54 72 75 65 3a 0a 09 09 6c    09 w h i l e   T r u e : 0a 09 09 l
00000007    69 6e 65 20 3d 20 66 2e 72 65 61 64 28 31 36 29    i n e   =   f . r e a d ( 1 6 )
00000008    0a 09 09 69 66 20 6c 69 6e 65 20 3d 3d 20 62 27    0a 09 09 i f   l i n e   = =   b '
00000009    27 3a 20 62 72 65 61 6b 0a 09 09 68 20 3d 20 5b    ' :   b r e a k 0a 09 09 h   =   [
0000000a    22 7b 3a 30 32 78 7d 22 2e 66 6f 72 6d 61 74 28    " { : 0 2 x } " . f o r m a t (
0000000b    69 29 20 66 6f 72 20 69 20 69 6e 20 6c 69 6e 65    i )   f o r   i   i n   l i n e
0000000c    5d 0a 09 09 61 20 3d 20 5b 22 7b 7d 22 2e 66 6f    ] 0a 09 09 a   =   [ " { } " . f o
0000000d    72 6d 61 74 28 63 68 72 28 69 29 29 5c 0a 09 09    r m a t ( c h r ( i ) ) \ 0a 09 09
0000000e    09 09 69 66 20 69 20 3e 20 33 31 20 61 6e 64 20    09 09 i f   i   >   3 1   a n d
0000000f    69 20 3c 20 31 32 37 20 65 6c 73 65 20 22 7b 3a    i   <   1 2 7   e l s e   " { :
00000010    30 32 78 7d 22 2e 66 6f 72 6d 61 74 28 69 29 20    0 2 x } " . f o r m a t ( i )
00000011    66 6f 72 20 69 20 69 6e 20 6c 69 6e 65 5d 0a 09    f o r   i   i n   l i n e ] 0a 09
00000012    09 70 72 69 6e 74 28 22 7b 3a 30 38 78 7d 20 20    09 p r i n t ( " { : 0 8 x }
00000013    20 20 7b 7d 20 20 20 20 7b 7d 22 2e 5c 0a 09 09        { }         { } " . \ 0a 09 09
00000014    09 09 66 6f 72 6d 61 74 28 63 6f 75 6e 74 2c 20    09 09 f o r m a t ( c o u n t ,
00000015    27 20 27 2e 6a 6f 69 6e 28 68 29 2c 20 27 20 27    '   ' . j o i n ( h ) ,   '   '
00000016    2e 6a 6f 69 6e 28 61 29 29 29 0a 09 09 63 6f 75    . j o i n ( a ) ) ) 0a 09 09 c o u
00000017    6e 74 20 3d 20 63 6f 75 6e 74 20 2b 20 31 0a 09    n t   =   c o u n t   +   1 0a 09
00000018    66 2e 63 6c 6f 73 65 28 29 0a 65 6c 73 65 3a 0a    f . c l o s e ( ) 0a e l s e : 0a
00000019    09 70 72 69 6e 74 28 22 55 73 61 67 65 3a 5c 6e    09 p r i n t ( " U s a g e : \ n
0000001a    31 31 37 65 2e 70 79 20 3c 66 6e 3e 22 29 0a    1 1 7 e . p y   < f n > " ) 0a

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]sireWilliam 1 point2 points3 points 5 years ago* (0 children)

JAVA - How to paste so elegantly like you guys @_@?

import java.io.File;
import java.util.Scanner;

public class Easy_117 {
public static void main(String[] args) throws Exception {
    Scanner input = new Scanner(System.in);

    System.out.println("Available options:");
    System.out.println("1. Convert from hex to ascii");
    System.out.println("2. Convert from ascii to hex");
    System.out.print("Select your option: ");
    String selection = input.nextLine();

    if(selection.equalsIgnoreCase("1") || selection.equalsIgnoreCase("2")) {
        System.out.print("Please enter the absolute path of the textfile to be read: ");
        String filePath = input.nextLine();

        File textFile = new File(filePath);

        if(textFile.exists()) {
            Scanner fileReader = new Scanner(textFile);

            String result = "";//Ascii line to append to
            int hexLINECounter = 0;
            int hexFILECounter = 0;
            int addNewLineHex = 0;

            while(fileReader.hasNext()) {
                String line = fileReader.nextLine();//Get current line string

                if(selection.equalsIgnoreCase("1")) {
                    String[] splittedLine = line.split(" ");//Split by white space

                    for(int i = 0; i < splittedLine.length; i++) {
                        if(splittedLine[i].length() == 2) {//Will skip anything with a length less or more than 2
                            String hexToString = String.valueOf((char) Integer.parseInt(splittedLine[i], 16));
                            result+= hexToString;
                        }
                    }
                }
                else {
                    if(line.length() == 0) {//Means it is a new line break
                        addNewLineHex++;
                    }
                    else {
                        for(int i = 0; i < line.length(); i++) {
                            //Check if it is the beginning of a new line
                            if(hexLINECounter == 0) {//Beginning of a new line, add 00000000 format in front
                                result += insertFiller(hexFILECounter) + " ";
                            }

                            while(addNewLineHex > 0) {
                                result += "0A ";//New line hex
                                hexLINECounter++;
                                addNewLineHex--;

                                if(hexLINECounter >= 16) {
                                    result += "\n";
                                    hexLINECounter = 0;
                                    hexFILECounter++;

                                    result += insertFiller(hexFILECounter) + " ";
                                }
                            }

                            result += Integer.toHexString(Integer.valueOf(line.charAt(i))) + " ";
                            hexLINECounter++;

                            if(hexLINECounter >= 16) {
                                result += "\n";
                                hexLINECounter = 0;
                                hexFILECounter++;
                            }

                            if(i == line.length() - 1) {//End of the line
                                addNewLineHex++;
                            }
                        }
                    }
                }
            }

            System.out.println();
            System.out.println();

            if(selection.equalsIgnoreCase("1")) {
                System.out.println("Displaying file data in ascii...");
            }
            else {
                System.out.println("Displaying file data in hex...");
            }

            System.out.println("----------------------------------------");
            System.out.println(result);
            System.out.println("----------------------------------------");
            System.out.println("Ending process...");

            fileReader.close();
        }
        else {
            System.out.println("Congratulations! You has passed the test, please proceed to the next room to have your cake.");
        }
    }
    else {
        System.out.println("Congratulations! You has passed the test, please proceed to the next room to have your cake.");
    }
}

public static String insertFiller(int hexFILECounter) {
    String filler = Integer.toHexString(hexFILECounter);
    while(filler.length() < 8) { filler = "0" + filler; }//Filler
    return filler;
}
}

First parameter: ascii to hex or hex to ascii Second parameter: absolute path
of the textfile

ASCII TO HEX SAMPLE Sample textfile:

Daily programmer
from
reddit







Why the white spaces?!
Because I can put white spaces.

Output:

00000000 44 61 69 6c 79 20 70 72 6f 67 72 61 6d 6d 65 72
00000001 0A 66 72 6f 6d 0A 72 65 64 64 69 74 0A 0A 0A 0A
00000002 0A 0A 0A 0A 57 68 79 20 74 68 65 20 77 68 69 74
00000003 65 20 73 70 61 63 65 73 3f 21 0A 42 65 63 61 75
00000004 73 65 20 49 20 63 61 6e 20 70 75 74 20 77 68 69
00000005 74 65 20 73 70 61 63 65 73 2e

Vice versa same.

  • permalink
  • embed
  • save
  • give gold

[–]JacobTomaw0 0 1 point2 points3 points 5 years ago (1 child)

Go, but it feels like I cheated.

package main

import "os"
import "encoding/hex"
import "io/ioutil"

func main() {
    if len(os.Args) != 2 {
        println("Please provide a file name")
    } else {
        contents, _ := ioutil.ReadFile(os.Args[1])
        println(hex.Dump(contents))
    }
}

  • permalink
  • embed
  • save
  • give gold

[–]nint221 2[S] 0 points1 point2 points 5 years ago (0 children)

Just make sure the formatting is correct, and you're good to go! :-)

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]Valarauka_ 1 point2 points3 points 5 years ago (0 children)

Minimalistic python, with formatting and line numbers:

import sys
with open(sys.argv[1], 'rb') as f:
    for i, data in enumerate(iter(lambda:f.read(16), '')):
        print ' '.join(['%08X'%i] + ['%02X'%ord(c) for c in data])

Output on self:

00000000 69 6D 70 6F 72 74 20 73 79 73 0A 77 69 74 68 20
00000001 6F 70 65 6E 28 73 79 73 2E 61 72 67 76 5B 31 5D
00000002 2C 20 27 72 62 27 29 20 61 73 20 66 3A 0A 20 20
00000003 20 20 66 6F 72 20 69 2C 20 64 61 74 61 20 69 6E
00000004 20 65 6E 75 6D 65 72 61 74 65 28 69 74 65 72 28
00000005 6C 61 6D 62 64 61 3A 66 2E 72 65 61 64 28 31 36
00000006 29 2C 20 27 27 29 29 3A 0A 20 20 20 20 20 20 20
00000007 20 70 72 69 6E 74 20 27 20 27 2E 6A 6F 69 6E 28
00000008 5B 27 25 30 38 58 27 25 69 5D 20 2B 20 5B 27 25
00000009 30 32 58 27 25 6F 72 64 28 63 29 20 66 6F 72 20
0000000A 63 20 69 6E 20 64 61 74 61 5D 29 0A

  • permalink
  • embed
  • save
  • give gold

[–]spacedhat 1 point2 points3 points 5 years ago* (0 children)

C; although after seeing skeeto's, i like his implementation.

#include<stdio.h>

int main(int* sysarg, char* sysargv[]){
    FILE* readfile = fopen(sysargv[1], "r");
    int lineC, charC = 0;
    int readC = fgetc(readfile);
    printf("%08X ", lineC);
    while( readC != EOF ){
        if(charC > 16){
            charC = 1;
            lineC += 1;
            printf("\n%08X ", lineC);}
        printf("%02X ", readC);
        readC = fgetc(readfile);
        charC += 1;
    }
   fclose(readfile);
   return 0;
}

Edit: I meant to say his implementation, not "this"

  • permalink
  • embed
  • save
  • give gold

[–]Stinzorga 1 point2 points3 points 5 years ago (0 children)

VB, any and all feedback welcome.

Module Module1

    Sub Main()

        Dim filePathName As String = Console.ReadLine()
        Dim streamReader As System.IO.Stream = New System.IO.StreamReader(filePathName).BaseStream

        Dim count As Integer = 0
        While Not streamReader.Position < count

            If count Mod 16 = 0 Then
                Console.Out.Write(String.Format("{0}{1}  ", System.Environment.NewLine, Hex(count / 16).PadLeft(7, "0")))
            End If

            Console.Out.Write(String.Format("{0} ", Hex(streamReader.ReadByte()).PadLeft(2)))
            count += 1

        End While

        streamReader.Dispose()
        Console.ReadLine()

    End Sub

End Module

Sample Output:

0000000  49 20 73 74 69 6C 6C 20 64 6F 6E 27 74 20 75 6E
0000001  64 65 72 73 74 61 6E 64 20 63 6F 6D 70 6C 65 74
0000002  65 6C 79 2E 20 20 49 74 20 73 65 65 6D 73 2F 66
0000003  65 65 6C 73 20 6C 69 6B 65 20 74 68 65 72 65 27
0000004  73 20 73 6F 6D 65 74 68 69 6E 67 20 74 68 61 74
0000005  20 49 27 6D 20 6E 6F 74 20 62 65 69 6E 67 20 74
0000006  6F 6C 64 2E 20 20 49 74 20 6A 75 73 74 20 64 6F
0000007  65 73 6E 27 74 20 61 6C 6C 20 61 64 64 20 75 70
0000008  20 74 6F 20 6D 65 2E 20 20 49 20 6D 65 61 6E 2C
0000009  20 69 74 20 6A 75 73 74 20 68 69 74 20 79 6F 75
000000A  20 61 6C 6C 20 6F 66 20 61 20 73 75 64 64 65 6E
000000B  20 69 6E 20 44 65 63 65 6D 62 65 72 20 61 72 6F
000000C  75 6E 64 20 74 68 61 74 20 74 69 6D 65 20 77 65
000000D  20 66 6F 75 67 68 74 20 61 6E 64 20 79 6F 75 20
000000E  68 61 76 65 6E 27 74 20 72 65 61 6C 6C 79 20 62
000000F  65 65 6E 20 74 68 65 20 73 61 6D 65 20 73 69 6E
0000010  63 65 20 74 68 65 6E 2E 20 3A 28  D  A  D  A 49

  • permalink
  • embed
  • save
  • give gold

[–]phoric 1 point2 points3 points 5 years ago* (0 children)

Python 2, no bonus. A bit verbose, but I had fun figuring it out without using
too much Python 'magic', and keeping it (hopefully) readable. View on Github.

Edit: Added command line argument for specifying input file

#!/usr/bin/env python

# Challenge #117 [easy] Hexdump to ASCII
# http://redd.it/16jiuq

import sys, os

def hexconvert(filename):
    """ Accept a filename and return a hex list of it's characters """
    hexlist = []
    file = open(filename, 'r')
    while file:
        try:
            hexbyte = hex(ord(file.read(1)))[2:]
            if len(hexbyte) == 1:
                hexbyte = '0' + hexbyte
            hexlist.append(hexbyte)
        except TypeError:
            break
    return hexlist


def linecounter(bytelist):
    """ Return a list of formatted line numbers """
    linecount = 0
    result = []
    for charcount,char in enumerate(bytelist):
        if (charcount % 16) == 0:
            linecount += 1
            result.append(hex(linecount)[2:].zfill(8))
    return result


def hexlines(linenumbers, bytelist):
    """ Combine line #'s and hex bytes into list of formatted output strings """
    outputlist = []
    for line in range(len(linenumbers)):
        newstring = str(linenumbers[line])
        hexend = (line+1)*16
        for char in (bytelist[line*16:hexend]):
            newstring = newstring + ' ' + char
        outputlist.append(newstring)
    return outputlist


if __name__ == '__main__':
    if len(sys.argv) > 1 and os.path.exists(sys.argv[1]):
        filename = sys.argv[1]
    else:
        print "Input file not specified or doesn't exist."
        sys.exit()

    hexchars = hexconvert(filename)
    linenumbers = linecounter(hexchars)

    for line in hexlines(linenumbers, hexchars):
        print line

Output of itself:

00000001 23 21 2f 75 73 72 2f 62 69 6e 2f 65 6e 76 20 70
00000002 79 74 68 6f 6e 32 0a 0a 23 20 43 68 61 6c 6c 65
00000003 6e 67 65 20 23 31 31 37 20 5b 65 61 73 79 5d 20
00000004 48 65 78 64 75 6d 70 20 74 6f 20 41 53 43 49 49
00000005 0a 23 20 68 74 74 70 3a 2f 2f 72 65 64 64 2e 69
00000006 74 2f 31 36 6a 69 75 71 0a 0a 69 6d 70 6f 72 74
00000007 20 73 79 73 2c 20 6f 73 0a 0a 64 65 66 20 68 65
00000008 78 63 6f 6e 76 65 72 74 28 66 69 6c 65 6e 61 6d
00000009 65 29 3a 0a 20 20 20 20 22 22 22 20 41 63 63 65
0000000a 70 74 20 61 20 66 69 6c 65 6e 61 6d 65 20 61 6e
0000000b 64 20 72 65 74 75 72 6e 20 61 20 68 65 78 20 6c
0000000c 69 73 74 20 6f 66 20 69 74 27 73 20 63 68 61 72
0000000d 61 63 74 65 72 73 20 22 22 22 0a 20 20 20 20 68
0000000e 65 78 6c 69 73 74 20 3d 20 5b 5d 0a 20 20 20 20
0000000f 66 69 6c 65 20 3d 20 6f 70 65 6e 28 66 69 6c 65
00000010 6e 61 6d 65 2c 20 27 72 27 29 0a 20 20 20 20 77
00000011 68 69 6c 65 20 66 69 6c 65 3a 0a 20 20 20 20 20
00000012 20 20 20 74 72 79 3a 0a 20 20 20 20 20 20 20 20
00000013 20 20 20 20 68 65 78 62 79 74 65 20 3d 20 68 65
00000014 78 28 6f 72 64 28 66 69 6c 65 2e 72 65 61 64 28
00000015 31 29 29 29 5b 32 3a 5d 0a 20 20 20 20 20 20 20
00000016 20 20 20 20 20 69 66 20 6c 65 6e 28 68 65 78 62
00000017 79 74 65 29 20 3d 3d 20 31 3a 0a 20 20 20 20 20
00000018 20 20 20 20 20 20 20 20 20 20 20 68 65 78 62 79
00000019 74 65 20 3d 20 27 30 27 20 2b 20 68 65 78 62 79
0000001a 74 65 0a 20 20 20 20 20 20 20 20 20 20 20 20 68
0000001b 65 78 6c 69 73 74 2e 61 70 70 65 6e 64 28 68 65
0000001c 78 62 79 74 65 29 0a 20 20 20 20 20 20 20 20 65
0000001d 78 63 65 70 74 20 54 79 70 65 45 72 72 6f 72 3a
0000001e 0a 20 20 20 20 20 20 20 20 20 20 20 20 62 72 65
0000001f 61 6b 0a 20 20 20 20 72 65 74 75 72 6e 20 68 65
00000020 78 6c 69 73 74 0a 0a 0a 64 65 66 20 6c 69 6e 65
00000021 63 6f 75 6e 74 65 72 28 62 79 74 65 6c 69 73 74
00000022 29 3a 0a 20 20 20 20 22 22 22 20 52 65 74 75 72
00000023 6e 20 61 20 6c 69 73 74 20 6f 66 20 66 6f 72 6d
00000024 61 74 74 65 64 20 6c 69 6e 65 20 6e 75 6d 62 65
00000025 72 73 20 22 22 22 0a 20 20 20 20 6c 69 6e 65 63
00000026 6f 75 6e 74 20 3d 20 30 0a 20 20 20 20 72 65 73
00000027 75 6c 74 20 3d 20 5b 5d 0a 20 20 20 20 66 6f 72
00000028 20 63 68 61 72 63 6f 75 6e 74 2c 63 68 61 72 20
00000029 69 6e 20 65 6e 75 6d 65 72 61 74 65 28 62 79 74
0000002a 65 6c 69 73 74 29 3a 0a 20 20 20 20 20 20 20 20
0000002b 69 66 20 28 63 68 61 72 63 6f 75 6e 74 20 25 20
0000002c 31 36 29 20 3d 3d 20 30 3a 0a 20 20 20 20 20 20
0000002d 20 20 20 20 20 20 6c 69 6e 65 63 6f 75 6e 74 20
0000002e 2b 3d 20 31 0a 20 20 20 20 20 20 20 20 20 20 20
0000002f 20 72 65 73 75 6c 74 2e 61 70 70 65 6e 64 28 68
00000030 65 78 28 6c 69 6e 65 63 6f 75 6e 74 29 5b 32 3a
00000031 5d 2e 7a 66 69 6c 6c 28 38 29 29 0a 20 20 20 20
00000032 72 65 74 75 72 6e 20 72 65 73 75 6c 74 0a 0a 0a
00000033 64 65 66 20 68 65 78 6c 69 6e 65 73 28 6c 69 6e
00000034 65 6e 75 6d 62 65 72 73 2c 20 62 79 74 65 6c 69
00000035 73 74 29 3a 0a 20 20 20 20 22 22 22 20 43 6f 6d
00000036 62 69 6e 65 20 6c 69 6e 65 20 23 27 73 20 61 6e
00000037 64 20 68 65 78 20 62 79 74 65 73 20 69 6e 74 6f
00000038 20 6c 69 73 74 20 6f 66 20 66 6f 72 6d 61 74 74
00000039 65 64 20 6f 75 74 70 75 74 20 73 74 72 69 6e 67
0000003a 73 20 22 22 22 0a 20 20 20 20 6f 75 74 70 75 74
0000003b 6c 69 73 74 20 3d 20 5b 5d 0a 20 20 20 20 66 6f
0000003c 72 20 6c 69 6e 65 20 69 6e 20 72 61 6e 67 65 28
0000003d 6c 65 6e 28 6c 69 6e 65 6e 75 6d 62 65 72 73 29
0000003e 29 3a 0a 20 20 20 20 20 20 20 20 6e 65 77 73 74
0000003f 72 69 6e 67 20 3d 20 73 74 72 28 6c 69 6e 65 6e
00000040 75 6d 62 65 72 73 5b 6c 69 6e 65 5d 29 0a 20 20
00000041 20 20 20 20 20 20 68 65 78 65 6e 64 20 3d 20 28
00000042 6c 69 6e 65 2b 31 29 2a 31 36 0a 20 20 20 20 20
00000043 20 20 20 66 6f 72 20 63 68 61 72 20 69 6e 20 28
00000044 62 79 74 65 6c 69 73 74 5b 6c 69 6e 65 2a 31 36
00000045 3a 68 65 78 65 6e 64 5d 29 3a 0a 20 20 20 20 20
00000046 20 20 20 20 20 20 20 6e 65 77 73 74 72 69 6e 67
00000047 20 3d 20 6e 65 77 73 74 72 69 6e 67 20 2b 20 27
00000048 20 27 20 2b 20 63 68 61 72 0a 20 20 20 20 20 20
00000049 20 20 6f 75 74 70 75 74 6c 69 73 74 2e 61 70 70
0000004a 65 6e 64 28 6e 65 77 73 74 72 69 6e 67 29 0a 20
0000004b 20 20 20 72 65 74 75 72 6e 20 6f 75 74 70 75 74
0000004c 6c 69 73 74 0a 0a 0a 69 66 20 5f 5f 6e 61 6d 65
0000004d 5f 5f 20 3d 3d 20 27 5f 5f 6d 61 69 6e 5f 5f 27
0000004e 3a 0a 20 20 20 20 69 66 20 6c 65 6e 28 73 79 73
0000004f 2e 61 72 67 76 29 20 3e 20 31 20 61 6e 64 20 6f
00000050 73 2e 70 61 74 68 2e 65 78 69 73 74 73 28 73 79
00000051 73 2e 61 72 67 76 5b 31 5d 29 3a 0a 20 20 20 20
00000052 20 20 20 20 66 69 6c 65 6e 61 6d 65 20 3d 20 73
00000053 79 73 2e 61 72 67 76 5b 31 5d 0a 20 20 20 20 65
00000054 6c 73 65 3a 0a 20 20 20 20 20 20 20 20 70 72 69
00000055 6e 74 20 22 49 6e 70 75 74 20 66 69 6c 65 20 6e
00000056 6f 74 20 73 70 65 63 69 66 69 65 64 20 6f 72 20
00000057 64 6f 65 73 6e 27 74 20 65 78 69 73 74 2e 22 0a
00000058 20 20 20 20 20 20 20 20 73 79 73 2e 65 78 69 74
00000059 28 29 0a 0a 20 20 20 20 68 65 78 63 68 61 72 73
0000005a 20 3d 20 68 65 78 63 6f 6e 76 65 72 74 28 66 69
0000005b 6c 65 6e 61 6d 65 29 0a 20 20 20 20 6c 69 6e 65
0000005c 6e 75 6d 62 65 72 73 20 3d 20 6c 69 6e 65 63 6f
0000005d 75 6e 74 65 72 28 68 65 78 63 68 61 72 73 29 0a
0000005e 0a 20 20 20 20 66 6f 72 20 6c 69 6e 65 20 69 6e
0000005f 20 68 65 78 6c 69 6e 65 73 28 6c 69 6e 65 6e 75
00000060 6d 62 65 72 73 2c 20 68 65 78 63 68 61 72 73 29
00000061 3a 0a 20 20 20 20 20 20 20 20 70 72 69 6e 74 20
00000062 6c 69 6e 65 0a

  • permalink
  • embed
  • save
  • give gold

[–]justHereForFood 1 point2 points3 points 5 years ago (0 children)

In C: (sorry I'm posting so late):

https://gist.github.com/4568625

  • permalink
  • embed
  • save
  • give gold

[–]Toizi 1 point2 points3 points 5 years ago (0 children)

C

code:

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]){

    char c;
    unsigned int charCount = 0, lineCount = 0;
    char *fileName;
    FILE *pFile;

    if(argc != 2){
        puts("wrong number of arguments");
        return 0;
    }

    fileName = argv[1];
    pFile = fopen(fileName, "r");
    if(!pFile){
        puts("error opening file");
        return 0;
    }

    while((c = fgetc(pFile)) != EOF){

        if((charCount % 16) == 0)
            printf("\n%08X", lineCount++);

        ++charCount;
        printf(" %02X", (unsigned int)c);
    }
    puts("");

    fclose(pFile);
    return 0;
}

output with code as input:

00000000 23 69 6E 63 6C 75 64 65 20 3C 73 74 64 69 6F 2E
00000001 68 3E 0A 23 69 6E 63 6C 75 64 65 20 3C 73 74 64
00000002 6C 69 62 2E 68 3E 0A 0A 69 6E 74 20 6D 61 69 6E
00000003 28 69 6E 74 20 61 72 67 63 2C 20 63 68 61 72 20
00000004 2A 61 72 67 76 5B 5D 29 7B 0A 0A 09 63 68 61 72
00000005 20 63 3B 0A 09 75 6E 73 69 67 6E 65 64 20 69 6E
00000006 74 20 63 68 61 72 43 6F 75 6E 74 20 3D 20 30 2C
00000007 20 6C 69 6E 65 43 6F 75 6E 74 20 3D 20 30 3B 0A
00000008 09 63 68 61 72 20 2A 66 69 6C 65 4E 61 6D 65 3B
00000009 0A 09 46 49 4C 45 20 2A 70 46 69 6C 65 3B 0A 09
0000000A 0A 09 69 66 28 61 72 67 63 20 21 3D 20 32 29 7B
0000000B 0A 09 09 70 75 74 73 28 22 77 72 6F 6E 67 20 6E
0000000C 75 6D 62 65 72 20 6F 66 20 61 72 67 75 6D 65 6E
0000000D 74 73 22 29 3B 0A 09 09 72 65 74 75 72 6E 20 30
0000000E 3B 0A 09 7D 0A 09 0A 09 66 69 6C 65 4E 61 6D 65
0000000F 20 3D 20 61 72 67 76 5B 31 5D 3B 0A 09 70 46 69
00000010 6C 65 20 3D 20 66 6F 70 65 6E 28 66 69 6C 65 4E
00000011 61 6D 65 2C 20 22 72 22 29 3B 0A 09 69 66 28 21
00000012 70 46 69 6C 65 29 7B 0A 09 09 70 75 74 73 28 22
00000013 65 72 72 6F 72 20 6F 70 65 6E 69 6E 67 20 66 69
00000014 6C 65 22 29 3B 0A 09 09 72 65 74 75 72 6E 20 30
00000015 3B 0A 09 7D 0A 0A 09 77 68 69 6C 65 28 28 63 20
00000016 3D 20 66 67 65 74 63 28 70 46 69 6C 65 29 29 20
00000017 21 3D 20 45 4F 46 29 7B 0A 0A 09 09 69 66 28 28
00000018 63 68 61 72 43 6F 75 6E 74 20 25 20 31 36 29 20
00000019 3D 3D 20 30 29 0A 09 09 09 70 72 69 6E 74 66 28
0000001A 22 5C 6E 25 30 38 58 22 2C 20 6C 69 6E 65 43 6F
0000001B 75 6E 74 2B 2B 29 3B 0A 0A 09 09 2B 2B 63 68 61
0000001C 72 43 6F 75 6E 74 3B 0A 09 09 70 72 69 6E 74 66
0000001D 28 22 20 25 30 32 58 22 2C 20 28 75 6E 73 69 67
0000001E 6E 65 64 20 69 6E 74 29 63 29 3B 0A 09 7D 0A 09
0000001F 70 75 74 73 28 22 22 29 3B 0A 09 0A 09 66 63 6C
00000020 6F 73 65 28 70 46 69 6C 65 29 3B 0A 09 72 65 74
00000021 75 72 6E 20 30 3B 0A 7D 0A

  • permalink
  • embed
  • save
  • give gold

[–][deleted] 1 point2 points3 points 5 years ago* (0 children)

javascript

function f(a,b){return a.charAt(b)?((b|=0)%16?'':'\n'+(1e9+(b>>4).toString(16)).slice(-8))+' '+('0'+a.charCodeAt(b).toString(16)).slice(-2)+f(a,b+1):''}

output:

> f("\0 abcde 12378\n~\0 abcde 12378\n~\0 abcde 12378\n~");
"
00000000 00 20 61 62 63 64 65 20 31 32 33 37 38 0a 7e 00
00000001 20 61 62 63 64 65 20 31 32 33 37 38 0a 7e 00 20
00000002 61 62 63 64 65 20 31 32 33 37 38 0a 7e"

  • permalink
  • embed
  • save

[–]dark_mage 2 points3 points4 points 5 years ago* (4 children)

Java:

public class Hexdump {

    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println("Use: hexdump <filename>");
            System.exit(1);
        }

        Path path = Paths.get(args[0]);
        byte [] data = null;

        try {
            data = Files.readAllBytes(path);
        } catch (IOException e) {
            System.out.println("Error: Could not open file.");
            System.exit(1);
        }

        for (int i = 0; i < data.length; i++) {
            if ((i % 18) == 0) {
                System.out.print(String.format("%08X", i / 18) + " ");
            }

            System.out.print(String.format("%02X", data[i]));

            if ((i % 18) == 17) {
                System.out.println();
            } else {
                System.out.print(" ");
            }
        }
    }

}

Sample output:

00000000 48 65 6C 6C 6F 20 74 68 65 72 65 21 0D 0A 0D 0A 54 68
00000001 69 73 20 69 73 20 61 20 74 65 78 74 20 74 65 73 74 0D
00000002 0A 0D 0A 0D 0A 43 68 61 6C 6C 65 6E 67 65 20 31 31 37
00000003 0D 0A 45 61 61 61 73 79

  • permalink
  • embed
  • save
  • give gold

[–]Sonnenhut 4 points5 points6 points 5 years ago (3 children)

you can use:

System.out.printf("%08X", i / 18) + " ");

instead of

System.out.print(String.format("%08x", i / 18).toUpperCase() + " ");

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]dark_mage 0 points1 point2 points 5 years ago (2 children)

Nice.

This is my first post here. Am I allowed to change the post content?

Edit: Also my space padding got messed up a lil bit. Still trying to figure out
how to paste the code properly.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]domlebo701 2 0 points1 point2 points 5 years ago (1 child)

Yeah man, it's not that formal :P

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]dark_mage 1 point2 points3 points 5 years ago (0 children)

Alright, it didn't seem, but just in case. Already edited to use Sonnenhut's
suggestion.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]liloboy 1 point2 points3 points 5 years ago (1 child)

In Python:

fn = 'ka.exe' #filename
f = open(fn, 'rb')

while f:
    byte = f.read(1)
    if not byte:
        break
    temp = ord(byte)
    out = hex(temp)[2:]
    if len(out) == 1:
        out = '0' + out

    print out + ' ',

  • permalink
  • embed
  • save
  • give gold

[–]domlebo701 2 2 points3 points4 points 5 years ago (0 children)

This only prints the file contents as bytes, space separated. Needs to truncate
to 18, and the line number. Nice though -

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]robin-gvx0 2 0 points1 point2 points 5 years ago (3 children)

In Python 3:

import sys

with open(sys.argv[1], 'rb') as f:
    print(' '.join('{:02x}'.format(c) for c in f.read()))

  • permalink
  • embed
  • save
  • give gold

[–]domlebo701 2 1 point2 points3 points 5 years ago (1 child)

No line numbers or padding? Very cool though - Python 3 is so terse.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]robin-gvx0 2 1 point2 points3 points 5 years ago (0 children)

No line numbers or anything, I tried to keep it minimalistic on purpose. The
Python 2 equivalent would be:

import sys

with open(sys.argv[1], 'rb') as f:
    print ' '.join('%02x' % ord(c) for c in f.read())

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]nint221 2[S] 0 points1 point2 points 5 years ago (0 children)

Hardcore formatting is hardcore: +1 silver medal!

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]ctangent 0 points1 point2 points 5 years ago* (0 children)

python. Can do a hex dump or ascii dump (with -a):

#! /usr/bin/python

def ascii_to_hex(ascii):
    return hex(ord(ascii))[2:].zfill(2)

def hexdump(filename, ascii_mode):
    '''
    filename - the name of the file to dump
    ascii_mode - boolean, true if each byte will be
                 output in ascii, false if each byte
                 will be output in hex
    '''
    try:
        file_in = open(filename, 'r')
    except IOError:
        print 'File {} does not exist!'.format(filename)
        exit(1)
    line_counter = 0
    line_buffer = []
    for byte in file_in.read():
        if ascii_mode:
            line_buffer.append(byte)
        else:
            line_buffer.append(ascii_to_hex(byte))
        if len(line_buffer) % 16 == 0:
            print hex(line_counter)[2:].zfill(8) + " {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {}".format(*line_buffer)
            line_counter += 1
            line_buffer = []
    if len(line_buffer) != 0:
        format_str = hex(line_counter)[2:].zfill(8) + " "
        for x in line_buffer:
            format_str += '{} '
        print format_str.format(*line_buffer)

def main():
    from optparse import OptionParser
    usage = "usage: daily117 [options] filename"
    parser = OptionParser(usage=usage)
    parser.add_option("-a", "--ascii", dest="ascii_mode",
                      help="Output dump in ASCII", action="store_true",
                      default=False)
    (options, args) = parser.parse_args()
    if len(args) != 1:
        print usage
        exit(1)
    hexdump(args[0], options.ascii_mode)

if __name__ == "__main__":
    main()

  • permalink
  • embed
  • save
  • give gold

[–]Overv 0 points1 point2 points 5 years ago (0 children)

C++

#include <iostream>
#include <fstream>
#include <vector>

int main(int argc, const char* argv[]) {
    if (argc != 2) {
        std::cerr << "Usage: 117easy.exe <filename>" << std::endl;
        return 1;
    }

    std::ifstream file(argv[1], std::ios::binary | std::ios::ate);
    if (!file.is_open()) {
        std::cerr << "Specified file not found!" << std::endl;
        return 1;
    }

    std::streamoff fileSize = file.tellg();
    file.seekg(0, std::ios::beg);

    std::vector<char> buffer(fileSize);
    file.read(&buffer[0], fileSize);

    for (int i = 0; i < fileSize; i++) {
        if (i % 16 == 0) {
            if (i > 0) printf("\n");
            printf("%08X ", i / 16);
        }

        if (buffer[i] >= ' ' && buffer[i] <= '~')
            printf("%c  ", buffer[i]);
        else
            printf("%02X ", buffer[i]);
    }

    printf("\n");

    file.close();

    return 0;
}

  • permalink
  • embed
  • save
  • give gold

[–]halcyon425 0 points1 point2 points 5 years ago (0 children)

Python. I wrote my own implementation, then looked through the amazing stuff
here.
Borrowed some ideas from /u/Valarauka_ and revised mine.

import sys, string

BYTE_LIMIT = 16
PRINTABLES = set(string.punctuation + string.letters + string.digits + ' ')

# Converts a line to a space separated hexadecimal string
# Packs 16 bytes of hex, returns hex string
def to_hex(line):
    return "".join("%02X " % ord(char) for char in line)

# Converts a string into printables
def to_string(line):
    return "".join(c if c in PRINTABLES else '.' for c in line)

# ASCII hex-dump of file
def main(filename):
    num  = 0
    with open(filename, "rb") as r:
        for line in iter(lambda: r.read(BYTE_LIMIT), ""):
            print "%08X %-*s %s" % (num, BYTE_LIMIT * 3, to_hex(line), to_string(line))
            num += 1

if __name__ == "__main__":
    if len(sys.argv) > 1: main(sys.argv[1])
    else: main(sys.argv[0])

Output of self:

00000000 69 6D 70 6F 72 74 20 73 79 73 2C 20 73 74 72 69  import sys, stri
00000001 6E 67 0D 0A 0D 0A 42 59 54 45 5F 4C 49 4D 49 54  ng....BYTE_LIMIT
00000002 20 3D 20 31 36 0D 0A 50 52 49 4E 54 41 42 4C 45   = 16..PRINTABLE
00000003 53 20 3D 20 73 65 74 28 73 74 72 69 6E 67 2E 70  S = set(string.p
00000004 75 6E 63 74 75 61 74 69 6F 6E 20 2B 20 73 74 72  unctuation + str
00000005 69 6E 67 2E 6C 65 74 74 65 72 73 20 2B 20 73 74  ing.letters + st
00000006 72 69 6E 67 2E 64 69 67 69 74 73 20 2B 20 27 20  ring.digits + '
00000007 27 29 0D 0A 0D 0A 23 20 43 6F 6E 76 65 72 74 73  ')....# Converts
00000008 20 61 20 6C 69 6E 65 20 74 6F 20 61 20 73 70 61   a line to a spa
00000009 63 65 20 73 65 70 61 72 61 74 65 64 20 68 65 78  ce separated hex
0000000A 61 64 65 63 69 6D 61 6C 20 73 74 72 69 6E 67 0D  adecimal string.
0000000B 0A 23 20 50 61 63 6B 73 20 31 36 20 62 79 74 65  .# Packs 16 byte
0000000C 73 20 6F 66 20 68 65 78 2C 20 72 65 74 75 72 6E  s of hex, return
0000000D 73 20 68 65 78 20 73 74 72 69 6E 67 0D 0A 64 65  s hex string..de
0000000E 66 20 74 6F 5F 68 65 78 28 6C 69 6E 65 29 3A 0D  f to_hex(line):.
0000000F 0A 20 20 20 20 72 65 74 75 72 6E 20 22 22 2E 6A  .    return "".j
00000010 6F 69 6E 28 22 25 30 32 58 20 22 20 25 20 6F 72  oin("%02X " % or
00000011 64 28 63 68 61 72 29 20 66 6F 72 20 63 68 61 72  d(char) for char
00000012 20 69 6E 20 6C 69 6E 65 29 0D 0A 0D 0A 23 20 43   in line)....# C
00000013 6F 6E 76 65 72 74 73 20 61 20 73 74 72 69 6E 67  onverts a string
00000014 20 69 6E 74 6F 20 70 72 69 6E 74 61 62 6C 65 73   into printables
00000015 0D 0A 64 65 66 20 74 6F 5F 73 74 72 69 6E 67 28  ..def to_string(
00000016 6C 69 6E 65 29 3A 0D 0A 20 20 20 20 72 65 74 75  line):..    retu
00000017 72 6E 20 22 22 2E 6A 6F 69 6E 28 63 20 69 66 20  rn "".join(c if
00000018 63 20 69 6E 20 50 52 49 4E 54 41 42 4C 45 53 20  c in PRINTABLES
00000019 65 6C 73 65 20 27 2E 27 20 66 6F 72 20 63 20 69  else '.' for c i
0000001A 6E 20 6C 69 6E 65 29 0D 0A 0D 0A 23 20 41 53 43  n line)....# ASC
0000001B 49 49 20 68 65 78 2D 64 75 6D 70 20 6F 66 20 66  II hex-dump of f
0000001C 69 6C 65 0D 0A 64 65 66 20 6D 61 69 6E 28 66 69  ile..def main(fi
0000001D 6C 65 6E 61 6D 65 29 3A 0D 0A 20 20 20 20 6E 75  lename):..    nu
0000001E 6D 20 20 3D 20 30 0D 0A 20 20 20 20 77 69 74 68  m  = 0..    with
0000001F 20 6F 70 65 6E 28 66 69 6C 65 6E 61 6D 65 2C 20   open(filename,
00000020 22 72 62 22 29 20 61 73 20 72 3A 0D 0A 20 20 20  "rb") as r:..
00000021 20 20 20 20 20 66 6F 72 20 6C 69 6E 65 20 69 6E       for line in
00000022 20 69 74 65 72 28 6C 61 6D 62 64 61 3A 20 72 2E   iter(lambda: r.
00000023 72 65 61 64 28 42 59 54 45 5F 4C 49 4D 49 54 29  read(BYTE_LIMIT)
00000024 2C 20 22 22 29 3A 0D 0A 20 20 20 20 20 20 20 20  , ""):..
00000025 20 20 20 20 70 72 69 6E 74 20 22 25 30 38 58 20      print "%08X
00000026 25 2D 2A 73 20 25 73 22 20 25 20 28 6E 75 6D 2C  %-*s %s" % (num,
00000027 20 42 59 54 45 5F 4C 49 4D 49 54 20 2A 20 33 2C   BYTE_LIMIT * 3,
00000028 20 74 6F 5F 68 65 78 28 6C 69 6E 65 29 2C 20 74   to_hex(line), t
00000029 6F 5F 73 74 72 69 6E 67 28 6C 69 6E 65 29 29 0D  o_string(line)).
0000002A 0A 20 20 20 20 20 20 20 20 20 20 20 20 6E 75 6D  .            num
0000002B 20 2B 3D 20 31 0D 0A 0D 0A 69 66 20 5F 5F 6E 61   += 1....if __na
0000002C 6D 65 5F 5F 20 3D 3D 20 22 5F 5F 6D 61 69 6E 5F  me__ == "__main_
0000002D 5F 22 3A 0D 0A 20 20 20 20 69 66 20 6C 65 6E 28  _":..    if len(
0000002E 73 79 73 2E 61 72 67 76 29 20 3E 20 31 3A 20 6D  sys.argv) > 1: m
0000002F 61 69 6E 28 73 79 73 2E 61 72 67 76 5B 31 5D 29  ain(sys.argv[1])
00000030 0D 0A 20 20 20 20 65 6C 73 65 3A 20 6D 61 69 6E  ..    else: main
00000031 28 73 79 73 2E 61 72 67 76 5B 30 5D 29           (sys.argv[0])

  • permalink
  • embed
  • save
  • give gold

[–]ae7c 0 points1 point2 points 5 years ago (0 children)

I'm a little late to the party, but here's my solution in Python:

import sys, string

def hex_dump(file_name):
    try:
        _file = open(file_name, 'rb')
    except IOError:
        raise IOError, "no such file or directory"
        sys.exit()

    data = [str(hex(ord(i)))[2:].upper().zfill(2) for i in _file.read()]
    _file.close()
    return data

def print_hex(data, ascii):
    if ascii:
        ascii_table = [str(hex(ord(i)))[2:].upper().zfill(2) for i in list(string.printable[:-5])]
        data = map(lambda x: chr(int(x, 16)) if x in ascii_table else x, data)

    for ch, i in enumerate(range(0, len(data), 16)):
        print str(hex(ch+1))[2:].upper().zfill(8) + ' ' + ' '.join(data[i: i+16])

if __name__ == "__main__":
    file_name = sys.argv[1]
    if len(sys.argv) > 2:
        ascii = sys.argv[2].lower().startswith('ascii')
    else:
        ascii = False

    print_hex(hex_dump(file_name), ascii)

Regular Output:

python hexdump.py test.txt

00000001 54 68 69 73 20 69 73 20 61 20 54 65 73 74 20 46
00000002 69 6C 65 2E 2E 2E 0D 0A 54 65 73 74 20 46 69 6C
00000003 65 20 50 6C 65 61 73 65 20 49 67 6E 6F 72 65 0D
00000004 0A 54 45 53 54 49 4E 47 20 54 45 53 54 49 4E 47
00000005 20 54 45 53 54 49 4E 47 20 54 45 53 54

Ascii Output:

python hexdump.py test.txt ascii

00000001 T h i s   i s   a   T e s t   F
00000002 i l e . . . 0D 0A T e s t   F i l
00000003 e   P l e a s e   I g n o r e 0D
00000004 0A T E S T I N G   T E S T I N G
00000005   T E S T I N G   T E S T

  • permalink
  • embed
  • save
  • give gold

[–]kstecs 0 points1 point2 points 5 years ago* (0 children)

C.

#include <stdio.h>
#include <stdlib.h>

enum { BPL = 16 }; /* Bytes to output per line. */

void
hexdump(FILE *fp)
{
    unsigned char bytes[BPL];
    unsigned long line;
    unsigned nread;
    unsigned i;

    for (line = 0; (nread = fread(bytes, 1, BPL, fp)); ++line) {
        printf("%08lX\t", line);
        for (i = 0; i < nread; ++i)
            printf("%02X ", bytes[i]);
        putchar('\n');
    }
}

int
main(int argc, char *argv[])
{
    FILE *fp;
    char *fname;
    unsigned stat;
    unsigned i;

    stat = EXIT_SUCCESS;

    if (argc < 2) {
        fprintf(stderr, "?no filenames\n");
        return EXIT_FAILURE;
    }

    for (i = 1; (fname = argv[i]); ++i) {
        if (!(fp = fopen(fname, "r"))) {
            perror(fname);
            stat = EXIT_FAILURE;
            continue;
        }

        hexdump(fp);
    }

    return stat;
}

  • permalink
  • embed
  • save
  • give gold

[–]beginners-mind0 0 0 points1 point2 points 5 years ago (0 children)

A clojure solution. hex dump and ascii. An example of the output when it is ran
on iteself.

(defn hex-format [byte]
  (if (= byte -1)
    "--"
    (format "%02X" byte)))

(defn print-row [num hex]
  (let [ascii (for [ch hex]
                (cond
                 (= ch 10) "."
                 (= ch -1) "."
                 :else (str (char ch))))]
    (println
     (format "%08X" num)
     (clojure.string/join " " (map hex-format hex))
     (apply str ascii))))

(defn hex-dump [file width]
  (with-open [rdr (clojure.java.io/reader file)]
    (loop [counter 0
           row (take width (repeatedly #(.read rdr)))]
      (if-not (= (first row) -1)
        (do
          (print-row counter row)
          (recur (inc counter) (take width (repeatedly #(.read rdr)))))))))

(hex-dump "/home/jrock/hexdump.clj" 18)

  • permalink
  • embed
  • save
  • give gold

[–][deleted] 0 points1 point2 points 5 years ago (0 children)

C#

Maybe a bit late. If someone still sees this I would appreciate constructive
criticism.

string filePath = "..\\..\\sample.txt";

if(File.Exists(filePath)){
    byte[] sampleInput = File.ReadAllBytes(filePath);

    int lineCount = 0;
    Console.Write("{0:D6}", lineCount);

    int itemsInLine = 0;
    foreach (byte b in sampleInput)
    {
        Console.Write(" {0:X2}", b);
        if (++itemsInLine >= 16)
        {
            itemsInLine = 0;
            Console.Write("\n{0:D6}", ++lineCount);
        }
    }
}

  • permalink
  • embed
  • save

[–]phlip9 0 points1 point2 points 5 years ago (0 children)

Python

import sys
from itertools import zip_longest

def hexdump(s):
    data = open(s, 'rb').read()
    hexbytes = map('{:02X}'.format, data)
    split = zip_longest(*[iter(hexbytes)]*16, fillvalue='')
    for count, nums in enumerate(split):
        print('{:08X}'.format(count), " ".join(nums))
    print(data.decode(encoding='ascii', errors='ignore'))

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print(sys.argv[0], "[file]")
        exit(1)
    hexdump(sys.argv[1])

printing itself out:

00000000 69 6D 70 6F 72 74 20 73 79 73 0A 66 72 6F 6D 20
00000001 69 74 65 72 74 6F 6F 6C 73 20 69 6D 70 6F 72 74
00000002 20 7A 69 70 5F 6C 6F 6E 67 65 73 74 0A 0A 64 65
00000003 66 20 68 65 78 64 75 6D 70 28 73 29 3A 0A 20 20
00000004 20 20 64 61 74 61 20 3D 20 6F 70 65 6E 28 73 2C
00000005 20 27 72 62 27 29 2E 72 65 61 64 28 29 0A 20 20
00000006 20 20 68 65 78 62 79 74 65 73 20 3D 20 6D 61 70
00000007 28 27 7B 3A 30 32 58 7D 27 2E 66 6F 72 6D 61 74
00000008 2C 20 64 61 74 61 29 0A 20 20 20 20 73 70 6C 69
00000009 74 20 3D 20 7A 69 70 5F 6C 6F 6E 67 65 73 74 28
0000000A 2A 5B 69 74 65 72 28 68 65 78 62 79 74 65 73 29
0000000B 5D 2A 31 36 2C 20 66 69 6C 6C 76 61 6C 75 65 3D
0000000C 27 27 29 0A 20 20 20 20 66 6F 72 20 63 6F 75 6E
0000000D 74 2C 20 6E 75 6D 73 20 69 6E 20 65 6E 75 6D 65
0000000E 72 61 74 65 28 73 70 6C 69 74 29 3A 0A 20 20 20
0000000F 20 20 20 20 20 70 72 69 6E 74 28 27 7B 3A 30 38
00000010 58 7D 27 2E 66 6F 72 6D 61 74 28 63 6F 75 6E 74
00000011 29 2C 20 22 20 22 2E 6A 6F 69 6E 28 6E 75 6D 73
00000012 29 29 0A 20 20 20 20 70 72 69 6E 74 28 64 61 74
00000013 61 2E 64 65 63 6F 64 65 28 65 6E 63 6F 64 69 6E
00000014 67 3D 27 61 73 63 69 69 27 2C 20 65 72 72 6F 72
00000015 73 3D 27 69 67 6E 6F 72 65 27 29 29 0A 0A 69 66
00000016 20 5F 5F 6E 61 6D 65 5F 5F 20 3D 3D 20 27 5F 5F
00000017 6D 61 69 6E 5F 5F 27 3A 0A 20 20 20 20 69 66 20
00000018 6C 65 6E 28 73 79 73 2E 61 72 67 76 29 20 3C 20
00000019 32 3A 0A 20 20 20 20 20 20 20 20 70 72 69 6E 74
0000001A 28 73 79 73 2E 61 72 67 76 5B 30 5D 2C 20 22 5B
0000001B 66 69 6C 65 5D 22 29 0A 20 20 20 20 20 20 20 20
0000001C 65 78 69 74 28 31 29 0A 20 20 20 20 68 65 78 64
0000001D 75 6D 70 28 73 79 73 2E 61 72 67 76 5B 31 5D 29
0000001E 0A

  • permalink
  • embed
  • save
  • give gold

[–]flightcrank 0 points1 point2 points 5 years ago (0 children)

coded in C:

very easy in c with the printf fucntion that can print hex and add padding.

#include <stdio.h>

#define SIZE 16

int main() {

    unsigned char f_buff[SIZE];

    //open file to process
    FILE *fp;
    fp = fopen("app","rb");//open as binary

    if (fp == NULL) {

        printf("error opening file. does enable1.txt exist ?");
        return 1; // exit program
    }

    int count = 0;

    //read file 1 byte at a time
    while(feof(fp) == 0) {

        int i;
        int r = fread(&f_buff, sizeof(char), SIZE, fp);

        count++;

        printf("%08X: ", count);

        //print out each byte in the buffer in hex
        for(i = 0; i < r; i++) {

            printf("%02X ", f_buff[i]);
        }

        printf("\n");
    }

    //close file
    fclose(fp);

    return 0;
}

  • permalink
  • embed
  • save
  • give gold

[–]ittybittykittyloaf 0 points1 point2 points 5 years ago* (0 children)

C with challenge input & bonus. Malloc used because, damnit, I'm going to use
malloc and linked lists, in everything, until I'm not afraid of pointers
anymore.

Edit: variable naming is shit. I originally wanted to obfuscate it, at the end,
and then was too excited to delay posting it.

Makefile:

all: 117easy.o
    gcc 117easy.o -o 117easy

117easy.o: 117easy.c
    gcc -Wall -Wextra -ggdb -c 117easy.c

clean:
    rm -f *.o
    rm -f 117easy

117easy.c:

#include <stdio.h>
#include <string.h>
#include <malloc.h>

int main(int argc, char* argv[]) {
    argc = argc;
    FILE* f = fopen(argv[0], "rb");
    if (!f) { printf("%s not found\n", argv[0]); return 1; }

    unsigned char* s =
        (unsigned char*)malloc(16 * sizeof(unsigned char));
    if (!s) { fclose(f); printf("malloc() failure!\n"); return 1; }
    memset(s, 0, 16 * sizeof(unsigned char));

    int c = 0, n = 0, i = 0, l = 0;
    while ((c = fgetc(f)) != EOF) {
        s[n % 16] = c;

        if (n % 16 == 15) {
            printf("%08d ", l);
            for (i = 0; i < 16; i++)
                printf("%02X ", s[i]);
            for (i = 0; i < 16; i++) {
                (s[i] >= 32 && s[i] <= 126) ?
                    printf("%c", s[i])  :
                    printf(".");
            }

            l++;
            printf("\n");
        }

        n++;
    }

    int lo = n % 16;
    if (lo) {
        printf("%08d ", l);
        for (i = 0; i < lo; i++)
            printf("%02X ", s[i]);
        for (i = 0; i < 16 - lo; i++)
            printf(".. ");
        for (i = 0; i < lo; i++) {
            (s[i] >= 32 && s[i] <= 126) ?
                printf("%c", s[i])  :
                printf(".");
        }

        l++;
        printf("\n");
    }

    if (f) fclose(f);
    if (s) free(s);

    return 0;
}

Output snippet:

00000553 00 00 00 00 00 00 00 00 04 00 F1 FF C2 00 00 00 ................
00000554 94 8A 04 08 00 00 00 00 01 00 11 00 D0 00 00 00 ................
00000555 10 9F 04 08 00 00 00 00 01 00 14 00 00 00 00 00 ................
00000556 00 00 00 00 00 00 00 00 04 00 F1 FF DC 00 00 00 ................
00000557 0C 9F 04 08 00 00 00 00 00 00 12 00 ED 00 00 00 ................
00000558 14 9F 04 08 00 00 00 00 01 00 15 00 F6 00 00 00 ................
00000559 08 9F 04 08 00 00 00 00 00 00 12 00 09 01 00 00 ................
00000560 00 A0 04 08 00 00 00 00 01 00 17 00 1F 01 00 00 ................
00000561 40 89 04 08 02 00 00 00 12 00 0D 00 2F 01 00 00 @.........../...
00000562 42 89 04 08 00 00 00 00 12 02 0D 00 46 01 00 00 B...........F...
00000563 00 00 00 00 00 00 00 00 20 00 00 00 62 01 00 00 ........ ...b...
00000564 38 A0 04 08 00 00 00 00 20 00 18 00 6D 01 00 00 8....... ...m...
00000565 00 00 00 00 00 00 00 00 12 00 00 00 7F 01 00 00 ................
00000566 00 00 00 00 00 00 00 00 12 00 00 00 8F 01 00 00 ................
00000567 40 A0 04 08 00 00 00 00 10 00 18 00 96 01 00 00 @...............
00000568 00 00 00 00 00 00 00 00 12 00 00 00 A8 01 00 00 ................
00000569 48 89 04 08 00 00 00 00 12 00 0E 00 AE 01 00 00 H...............
00000570 00 00 00 00 00 00 00 00 12 00 00 00 C0 01 00 00 ................
00000571 38 A0 04 08 00 00 00 00 10 00 18 00 CD 01 00 00 8...............
00000572 00 00 00 00 00 00 00 00 12 00 00 00 DD 01 00 00 ................
00000573 00 00 00 00 00 00 00 00 20 00 00 00 EC 01 00 00 ........ .......
00000574 3C A0 04 08 00 00 00 00 11 02 18 00 F9 01 00 00 <...............
00000575 64 89 04 08 04 00 00 00 11 00 0F 00 08 02 00 00 d...............
00000576 00 00 00 00 00 00 00 00 12 00 00 00 25 02 00 00 ............%...
00000577 D0 88 04 08 61 00 00 00 12 00 0D 00 35 02 00 00 ....a.......5...
00000578 00 00 00 00 00 00 00 00 12 00 00 00 46 02 00 00 ............F...
00000579 00 00 00 00 00 00 00 00 12 00 00 00 58 02 00 00 ............X...
00000580 00 00 00 00 00 00 00 00 12 00 00 00 6B 02 00 00 ............k...
00000581 44 A0 04 08 00 00 00 00 10 00 19 00 70 02 00 00 D...........p...
00000582 C0 84 04 08 00 00 00 00 12 00 0D 00 77 02 00 00 ............w...
00000583 60 89 04 08 04 00 00 00 11 00 0F 00 7E 02 00 00 `...........~...
00000584 00 00 00 00 00 00 00 00 12 00 00 00 8F 02 00 00 ................
00000585 40 A0 04 08 00 00 00 00 10 00 19 00 9B 02 00 00 @...............
00000586 AC 85 04 08 20 03 00 00 12 00 0D 00 A0 02 00 00 .... ...........
00000587 00 00 00 00 00 00 00 00 20 00 00 00 B4 02 00 00 ........ .......
00000588 40 A0 04 08 00 00 00 00 11 02 18 00 C0 02 00 00 @...............
00000589 00 00 00 00 00 00 00 00 20 00 00 00 DA 02 00 00 ........ .......
00000590 D0 83 04 08 00 00 00 00 12 00 0B 00 00 63 72 74 .............crt
00000591 73 74 75 66 66 2E 63 00 5F 5F 4A 43 52 5F 4C 49 stuff.c.__JCR_LI
00000592 53 54 5F 5F 00 64 65 72 65 67 69 73 74 65 72 5F ST__.deregister_
00000593 74 6D 5F 63 6C 6F 6E 65 73 00 72 65 67 69 73 74 tm_clones.regist
00000594 65 72 5F 74 6D 5F 63 6C 6F 6E 65 73 00 5F 5F 64 er_tm_clones.__d
00000595 6F 5F 67 6C 6F 62 61 6C 5F 64 74 6F 72 73 5F 61 o_global_dtors_a
00000596 75 78 00 63 6F 6D 70 6C 65 74 65 64 2E 36 33 38 ux.completed.638
00000597 32 00 5F 5F 64 6F 5F 67 6C 6F 62 61 6C 5F 64 74 2.__do_global_dt
00000598 6F 72 73 5F 61 75 78 5F 66 69 6E 69 5F 61 72 72 ors_aux_fini_arr
00000599 61 79 5F 65 6E 74 72 79 00 66 72 61 6D 65 5F 64 ay_entry.frame_d
00000600 75 6D 6D 79 00 5F 5F 66 72 61 6D 65 5F 64 75 6D ummy.__frame_dum
00000601 6D 79 5F 69 6E 69 74 5F 61 72 72 61 79 5F 65 6E my_init_array_en
00000602 74 72 79 00 31 31 37 65 61 73 79 2E 63 00 5F 5F try.117easy.c.__
00000603 46 52 41 4D 45 5F 45 4E 44 5F 5F 00 5F 5F 4A 43 FRAME_END__.__JC
00000604 52 5F 45 4E 44 5F 5F 00 5F 5F 69 6E 69 74 5F 61 R_END__.__init_a
00000605 72 72 61 79 5F 65 6E 64 00 5F 44 59 4E 41 4D 49 rray_end._DYNAMI
00000606 43 00 5F 5F 69 6E 69 74 5F 61 72 72 61 79 5F 73 C.__init_array_s
00000607 74 61 72 74 00 5F 47 4C 4F 42 41 4C 5F 4F 46 46 tart._GLOBAL_OFF
00000608 53 45 54 5F 54 41 42 4C 45 5F 00 5F 5F 6C 69 62 SET_TABLE_.__lib
00000609 63 5F 63 73 75 5F 66 69 6E 69 00 5F 5F 69 36 38 c_csu_fini.__i68
00000610 36 2E 67 65 74 5F 70 63 5F 74 68 75 6E 6B 2E 62 6.get_pc_thunk.b
00000611 78 00 5F 49 54 4D 5F 64 65 72 65 67 69 73 74 65 x._ITM_deregiste
00000612 72 54 4D 43 6C 6F 6E 65 54 61 62 6C 65 00 64 61 rTMCloneTable.da
00000613 74 61 5F 73 74 61 72 74 00 70 72 69 6E 74 66 40 ta_start.printf@
00000614 40 47 4C 49 42 43 5F 32 2E 30 00 66 72 65 65 40 @GLIBC_2.0.free@
00000615 40 47 4C 49 42 43 5F 32 2E 30 00 5F 65 64 61 74 @GLIBC_2.0._edat
00000616 61 00 66 63 6C 6F 73 65 40 40 47 4C 49 42 43 5F a.fclose@@GLIBC_
00000617 32 2E 31 00 5F 66 69 6E 69 00 6D 61 6C 6C 6F 63 2.1._fini.malloc
00000618 40 40 47 4C 49 42 43 5F 32 2E 30 00 5F 5F 64 61 @@GLIBC_2.0.__da
00000619 74 61 5F 73 74 61 72 74 00 70 75 74 73 40 40 47 ta_start.puts@@G
00000620 4C 49 42 43 5F 32 2E 30 00 5F 5F 67 6D 6F 6E 5F LIBC_2.0.__gmon_
00000621 73 74 61 72 74 5F 5F 00 5F 5F 64 73 6F 5F 68 61 start__.__dso_ha
00000622 6E 64 6C 65 00 5F 49 4F 5F 73 74 64 69 6E 5F 75 ndle._IO_stdin_u
00000623 73 65 64 00 5F 5F 6C 69 62 63 5F 73 74 61 72 74 sed.__libc_start
00000624 5F 6D 61 69 6E 40 40 47 4C 49 42 43 5F 32 2E 30 _main@@GLIBC_2.0
00000625 00 5F 5F 6C 69 62 63 5F 63 73 75 5F 69 6E 69 74 .__libc_csu_init
00000626 00 66 6F 70 65 6E 40 40 47 4C 49 42 43 5F 32 2E .fopen@@GLIBC_2.
00000627 31 00 6D 65 6D 73 65 74 40 40 47 4C 49 42 43 5F 1.memset@@GLIBC_
00000628 32 2E 30 00 70 75 74 63 68 61 72 40 40 47 4C 49 2.0.putchar@@GLI
00000629 42 43 5F 32 2E 30 00 5F 65 6E 64 00 5F 73 74 61 BC_2.0._end._sta
00000630 72 74 00 5F 66 70 5F 68 77 00 66 67 65 74 63 40 rt._fp_hw.fgetc@
00000631 40 47 4C 49 42 43 5F 32 2E 30 00 5F 5F 62 73 73 @GLIBC_2.0.__bss
00000632 5F 73 74 61 72 74 00 6D 61 69 6E 00 5F 4A 76 5F _start.main._Jv_
00000633 52 65 67 69 73 74 65 72 43 6C 61 73 73 65 73 00 RegisterClasses.
00000634 5F 5F 54 4D 43 5F 45 4E 44 5F 5F 00 5F 49 54 4D __TMC_END__._ITM
00000635 5F 72 65 67 69 73 74 65 72 54 4D 43 6C 6F 6E 65 _registerTMClone
00000636 54 61 62 6C 65 00 5F 69 6E 69 74 00 .. .. .. .. Table._init.

  • permalink
  • embed
  • save
  • give gold

[–][deleted] -1 points0 points1 point 5 years ago* (0 children)

PHP:

<?php
    $handle = @fopen("test.dat", "r");
    $lineno = 0;

    while (!feof($handle)) {
        echo (strtoupper(str_pad(dechex($lineno++),8,"0",STR_PAD_LEFT))." ");
        $x=0;

        while(!feof($handle)&&$x<16){
            echo(strtoupper(bin2hex(fread ($handle , 1 )))." ");
            $x++;
        }
        echo("<br />");
    }
?>

Some friendly critiquing would be appreciated.

  • permalink
  • embed
  • save

  • about
  • blog
  • about
  • advertising
  • careers

  • help
  • site rules
  • Reddit help center
  • wiki
  • reddiquette
  • mod guidelines
  • contact us

  • apps & tools
  • Reddit for iPhone
  • Reddit for Android
  • mobile website
  • buttons

  • <3
  • reddit gold
  • redditgifts

Use of this site constitutes acceptance of our User Agreement and Privacy
Policy. (C) 2018 reddit inc. All rights reserved.

REDDIT and the ALIEN Logo are registered trademarks of reddit inc.

Advertise - technology

[pixel]

π Rendered by PID 6993 on app-433  at 2018-05-07 20:21:18.985866+00:00 running
37be41a country code: CH.

