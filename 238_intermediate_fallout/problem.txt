 
r/dailyprogrammer
log insign upsign in
Reddit Feeds

  • popular
  • all
  • 

Sign up and stay connected to your favorite communities.

sign uplog in
 
r/

dailyprogrammer

Posts
159
Posted by
u/jnazario
2 years ago

[2015-10-28] Challenge #238 [Intermediate] Fallout Hacking Game

Description

The popular video games Fallout 3 and Fallout: New Vegas have a computer
"hacking" minigame where the player must correctly guess the correct password
from a list of same-length words. Your challenge is to implement this game
yourself.

The game operates similarly to the classic board game [Mastermind](http://
en.wikipedia.org/wiki/Mastermind_(board_game)). The player has only 4 guesses
and on each incorrect guess the computer will indicate how many letter
positions are correct.

For example, if the password is MIND and the player guesses MEND, the game will
indicate that 3 out of 4 positions are correct (M_ND). If the password is
COMPUTE and the player guesses PLAYFUL, the game will report 0/7. While some of
the letters match, they're in the wrong position.

Ask the player for a difficulty (very easy, easy, average, hard, very hard),
then present the player with 5 to 15 words of the same length. The length can
be 4 to 15 letters. More words and letters make for a harder puzzle. The player
then has 4 guesses, and on each incorrect guess indicate the number of correct
positions.

Here's an example game:

Difficulty (1-5)? 3
SCORPION
FLOGGING
CROPPERS
MIGRAINE
FOOTNOTE
REFINERY
VAULTING
VICARAGE
PROTRACT
DESCENTS
Guess (4 left)? migraine
0/8 correct
Guess (3 left)? protract
2/8 correct
Guess (2 left)? croppers
8/8 correct
You win!

You can draw words from our favorite dictionary file: enable1.txt. Your program
should completely ignore case when making the position checks.

There may be ways to increase the difficulty of the game, perhaps even making
it impossible to guarantee a solution, based on your particular selection of
words. For example, your program could supply words that have little letter
position overlap so that guesses reveal as little information to the player as
possible.

Credit

This challenge was created by user u/skeeto. If you have any challenge ideas
please share them on r/dailyprogrammer_ideas and there's a good chance we'll
use them.

146 comments
share
96% Upvoted
Sort by
best
 
best
 
top
 
new
 
controversial
 
old
 
q&a
hyrulia
13 points·2 years ago·edited 2 years ago

Python3.5

from random import choice, sample


def get_words(d):
    difficulty = {1: (4, 5, 6), 2: (7, 8), 3: (9, 10, 11), 4: (12, 13), 5: (14, 15)}

    with open('enable1.txt', 'r') as file:
        b = choice(difficulty[d])
        words = [x for x in map(str.strip, file.readlines()) if len(x) == b]
        return sample(words, b + 1)


def guess(secret, i):
    word = input('Guess (' + str(4 - i) + ' left)? ')
    return len([(x, y) for x, y in zip(secret, word) if x == y])


def play():
    d = int(input('Difficulty (1-5)? '))
    words = get_words(d)
    print('\n'.join(map(str.upper, words)))
    secret = choice(words)
    l = len(secret)

    for i in range(4):
        g = guess(secret, i)
        if g == l:
            print('You win !')
            return
        else:
            print(g, '/', l, 'correct')

    print('You lose, the word was', secret)

play()

share
Save
boxofkangaroos
1 011 points·2 years ago

I believe you can replace

for word in words:
    print(word)

with

print "\n".join(word)

share
Save
RangeruDangeru
8 points·2 years ago

Or, if you want to avoid the join:

print(*words, sep='\n')

share
Save
hyrulia
3 points·2 years ago

Yes that's true, thx

share
Save
supercodes
6 points·2 years ago

Short and concise solution, like the difficulty map, might even steal it.

A few notes:

You should replace

[choice(words) for x in range(b + 1)]

with

random.sample(words, b)

because choosing randomly every time may cause you to get duplicate words in
the list.

Also, zip returns a list already so there should be no reason to list() it as
well, unless I'm missing something.

share
Save
hyrulia
2 points·2 years ago

I didn't know about the sample function, i learned something new. Thank you.

And yes it was my bad for the list(zip)

share
Save
marchelzo
2 points·2 years ago

In Python3, a lot of functions which returned lists in Python2 were changed to
return specialized generator objects, so depending on what you want to do, it
is sometimes necessary to use an explicit conversion to list. For example:

z = zip([1, 2, 3], ['a', 'b', 'c'])
z.append((4, 'd'))

# this is an error, because zip returns a zip object, which does
# not have a .append method.

share
Save
supercodes
1 point·2 years ago

Ah, thanks for telling me, I did not know that. Haven't gotten into python 3
yet. :)

share
Save
lukz
2 011 points·2 years ago

Z80 assembly

I created rather minimal variant, has 8 fixed 3-letter words. It chooses one
randomly, which you have to guess. It does not count 4 attempts, you can count
that yourself ;-). The program ends when you guess the password correctly.

The program is for Sharp MZ-800 and I use several functions from ROM (3 input
line, 6 print new line, 0ch print space, 18h print text). You can run the
program from monitor using G1200 command.

Program length is 102 bytes (including data).

Screenshot

  .org 1200h
  ; print available words
  ld de,words
  ld b,8
print:
  call 0ch    ; print space
  rst 18h     ; print word
  inc e
  inc e
  inc e
  inc e
  djnz print  ; repeat 8 times

  ; choose password
  ld a,r
  and 1ch
  add a,words
  ld h,12h
  ld l,a      ; select random word

; ask for input until password is correct
loop:
  ld de,1300h ; input buffer
  call 6      ; new line
  call 3      ; read user input
  push hl
  ld bc,300h  ; b=3
test:
  ld a,(de)
  inc e
  cp (hl)
  jr nz,$+3
  inc c       ; correct letter, +1
  inc l
  djnz test   ; test word

  pop hl
  ld a,c
  cp 3
  jr z,win
  add a,'0'   ; number -> ascii
  call 12h    ; print character
  jr loop

win:
  ld de,msg
  rst 18h
  ret

msg:
  .db "MATCH",13
words:
  .db "AND",13,"ARE",13,"OUR",13,"HAS",13,"ASK",13,"HOW",13,"CAN",13,"FOR",13

share
Save
smls
1 07 points·2 years ago·edited 2 years ago

Perl 6 - difficulty levels based on letter overlaps

This is a drop-in replacement for the get-words function in my Perl 6 solution.

Rather than simply choosing random words of a certain length, it also requires
a minimum number of total letter overlaps between them.

sub get-words ($difficulty) {
    my %setting =
        1 => (4     , 7),
        2 => (5..6  , 5),
        3 => (7..8  , 3),
        4 => (9..11 , 1),
        5 => (12..15, 0),
    ;
    my ($length, $similarity) = %setting{$difficulty}».pick;

    my @dict = 'enable1.txt'.IO.lines.grep(*.chars == $length);

    my @words = @dict.pick($length + 1)
        until letter-overlaps(@words) >= $similarity;
    @words;
}

sub letter-overlaps (*@words) {
    [+] ([Z] @words».fc».comb).map({ .elems - .Set.elems })
}

I used a naive brute-force implementation - it simply keeps choosing random
sets of words of the correct length, until it finds a set that fulfils the
overlap condition.

Here's an example of a set with 6 total letter overlaps (indicated by
asterisks) which was found for difficulty 2:

GLUGS -> GLUGS
LOCAL -> LOCAL
CASKY -> CASKY
NATTY -> N*TT*
SAULT -> S*ULT
SAITH -> **I*H

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Comments welcome! And I'd love to see other people's approaches (in any
programming language!) to choosing "easier" sets for lower difficulty levels,
than a random choice would provide.

share
Save
wannabuildastrawman
1 point·2 years ago

I'm interested in the overlaps based difficulty. I tried to implement it, but
couldn't come up with anything but a brute force implementation such as yours.
Would anyone be willing to try to make a more efficient version of it?

share
Save
Epthelyn
6 points·2 years ago

Java
Got carried away and ended up making the output as close as possible to the
actual in-game display, which comes somewhat at the cost of usability since the
input values for the scanner at each step for a given word are 3*(3000+n^2) in
hexidecimal. Still, it looks pretty and you can count to 15 instead.

Long enough to put into pastebin because of the messing around to get the
display:

http://pastebin.com/Eq8hssG6

And, of course, and example output for what would be the last two guesses for
an "Average" level terminal:

        4 ATTEMPT(S) LEFT: # # # #
        0x0BB8 ;^ASCENSIONS^@/ 0x18E7 /]^;]])]@^]//@/
        0x0BB9 @/]];)@];)]@^/] 0x1BB8 ^^;;))@)/]^;]]@
        0x0BC0 @)^);;)/);@/;]^ 0x1EE9 )@MARKETABLE)@)
        0x0BD3 ^)MAKEWEIGHT]@@ 0x2280 ^];));;]@@];;/;
        0x0BF8 )^/)^/)@);)^^]^ 0x2683 /;)^@)^))/^;^@;
        0x0C35 )]);]);;]^;^@;/ 0x2AF8 ]@PHONEMATIC^;]
        0x0C90 )^DISSEVERED)]^ 0x2FE5 @@/;@/];)]@;@@@
        0x0D0F )])/@;/^@]]/]^] 0x3550 );;;;)/));/@@^;
        0x0DB8 @;/^/@^@;;//@/^ 0x3B3F ^]ARCHEGONIA)]]
        0x0E91 ]/WORKFORCES]^) 0x41B8 ^;/)//^@;@@]/;^
        0x0FA0 )/]]^@^))@);)]@ 0x48C1 )]^/;)]]]/]^/;;
        0x10EB ;)@));)@)@;;]^^ 0x5060 ;]GONOCOCCUS@])
        0x1278 @/HAIRSTYLES/;/ 0x589B ;^/]^)@^/@;;@@)
        0x144D ];)/]^/;]^);)@@ 0x6178 /^^^/;;/^])@/^]
        0x1670 ;/@)/@^^;^@@@]] 0x6AFD )/QUITCLAIMS);/
        Make a selection (0 - 9)
        0
        > ASCENSIONS
        > Entry denied
        > 1/10 correct.






        3 ATTEMPT(S) LEFT: # # #
        0x0BB8 )@ASCENSIONS^)/ 0x18E7 /^^^///];;///)@
        0x0BB9 ;/^)]@^)]])^@/) 0x1BB8 )^;@)/^/)@@;;^;
        0x0BC0 ;@@/^^@]@;;/@]^ 0x1EE9 ;@MARKETABLE]])
        0x0BD3 ))MAKEWEIGHT/^; 0x2280 );/);/@)@]@;;;;
        0x0BF8 ;/^;]]])@)]/);) 0x2683 @]@;/]/@]^;)@^/
        0x0C35 )^/]^;@;^]/@@@/ 0x2AF8 //PHONEMATIC//)
        0x0C90 ]/DISSEVERED@@; 0x2FE5 /]^)@;;^^/;^@;;
        0x0D0F ;];^@;)@)/;;]@/ 0x3550 /;;;;]]@]@^@@@@
        0x0DB8 ]]^)/))@)/))];; 0x3B3F @;ARCHEGONIA//;
        0x0E91 ;]WORKFORCES;@) 0x41B8 )@]///@]);]@^//
        0x0FA0 @]@)@///]^;@^)) 0x48C1 ]/)@@^/;/)@^;/@
        0x10EB ]@^;^]]/)];;@/^ 0x5060 ;)GONOCOCCUS@]@
        0x1278 @]HAIRSTYLES@;@ 0x589B ]@]];^^/^^^]/))
        0x144D ^^)/;]];^)]])@@ 0x6178 )@/]];//^@)@@]@
        0x1670 ];^)]^)@/@@)]/] 0x6AFD /;QUITCLAIMS/^@
        Make a selection (0 - 9)
        3
        > WORKFORCES
        > Exact match!
        > Please wait while system is accessed.

share
Save
errorseven
2 points·2 years ago

Your post inspired me to go above and beyond with the visuals, admittedly I'm
not done yet as I'm planning to make it print the display one char at a time
like in the game, but check out my latest solution! (Written in AutoHotkey not
Java but I think you'll appreciate it) https://www.reddit.com/user/errorseven/

share
Save
Epthelyn
1 point·2 years ago

Ooh, nice work. I'll look back later to see if you've made any progress with
that!

share
Save
smls
1 05 points·2 years ago

Perl 6

(translation of hyrulia's Python 3.5 solution)

sub get-words ($difficulty) {
    my %lengths = 1 => 4..6,   2 => 7..8,  3 => 9..11,
                  4 => 12..13, 5 => 14..15;

    my $length = %lengths{$difficulty}.pick;

    'enable1.txt'.IO.lines.grep(*.chars == $length).pick($length + 1);
}

sub guess ($secret, $i) {
    my $word = prompt "Guess ({4 - $i} left)? ";
    ($secret.fc.comb Z $word.fc.comb).flat.grep(* eq *).elems;
}

sub play {
    my $difficulty = +prompt 'Difficulty (1-5)? ';
    my @words = get-words $difficulty;

    say .uc for @words;

    my $secret = @words.pick;
    my $l = $secret.chars;

    for ^4 {
        my $g = guess $secret, $_;
        if $g == $l { say 'You win !'; return }
        else        { say "$g/$l correct" }
    }

    say "You lose, the word was $secret"
}

play;

share
Save
Maiddog
4 points·2 years ago·edited 2 years ago

Simple C++ version. Not very elegant, but I tried to use mainly C++11
constructs. I only played a few games on it, but from what I can tell it works
fine. I might try to clean it up later.

#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <random>
#include <ctime>

#define MIN_WORDS 5
#define MAX_WORDS 15

#define MAX_TRIES 4

std::vector<std::string> get_words(int length, int count)
{
  std::vector<std::string> words;
  std::ifstream ifs("enable1.txt");
  std::string line = "";

  //  Read each line of the file
  while (ifs >> line)
  {
    //  Only save lines with the correct length
    if (line.length() == length)
    {
      words.push_back(line);
    }
  }

  ifs.close();

  //  random_shuffle has to have rand seeded or it will always be the same
  srand(time(nullptr));

  //  Randomize vector
  std::random_shuffle(std::begin(words), std::end(words));

  //  Return first section of vector
  return std::vector<std::string>(std::begin(words), std::begin(words) + count - 1);
}

int get_random(int min, int max)
{
  //  Static so it generates different numbers per call
  static std::random_device rd;
  static std::mt19937 mt(rd());

  return std::uniform_int_distribution<int>(min, max)(mt);
}

int main(int argc, char *argv[])
{
  int difficulty = 0;
  int length = 0;
  int count = 0;
  std::string correct = "";

  //  Get the number of words for this round
  count = get_random(MIN_WORDS, MAX_WORDS);

  std::cout << "Difficulty (1-5): ";

  while (difficulty < 1 || difficulty > 5)
  {
    std::cin >> difficulty;
  }

  //  Very bad way to get ranges
  switch (difficulty)
  {
    case 1:
      length = get_random(4, 6);
        break;
    case 2:
      length = get_random(7, 8);
        break;
    case 3:
      length = get_random(9, 10);
        break;
    case 4:
      length = get_random(11, 12);
        break;
    case 5:
      length = get_random(13, 15);
        break;
    default:
      std::cout << "How did you get here?" << std::endl;
      return 1;
  }

  //  Get the words for this round
  std::vector<std::string> words = get_words(length, count);

  //  If there aren't enough words of the given length, then stop
  if (words.size() < MIN_WORDS)
  {
    std::cout << "Not enough words of length " << length << "." << std::endl;
    return 1;
  }
  //  If word count is less than expected, change it so we don't crash
  else if (words.size() != count)
  {
    count = words.size();
  }

  //  Pick the answer
  correct = words[get_random(0, count - 1)];

  bool win = false;

  //  Print the words
  for (int i = 0; i < count; i++)
  {
    std::cout << words[i] << std::endl;
  }

  for (int i = 0; i < MAX_TRIES && !win; i++)
  {
    int match_count = 0;
    std::string guess = "";

    //   Be forgiving if they don't type the right amount of letters
    while (guess.size() != length)
    {
      std::cout << "Guess (" << MAX_TRIES - i << " left): ";
      std::cin >> guess;
    }

    //  Check index by index to count correct letter placements
    for (int index = 0; index < length; index++)
    {
      if (std::tolower(correct[index]) == std::tolower(guess[index]))
      {
        match_count++;
      }
    }

    std::cout << match_count << "/" << length << " correct" << std::endl;

    if (match_count == length)
    {
      std::cout << "You win!";
      win = true;
    }
  }

  if (!win)
  {
    std::cout << "You lose. The correct answer was " << correct << std::endl;
  }

  return 0;
}

share
Save
louiswins
3 points·2 years ago

A few comments:

#define MIN_WORDS 5
#define MAX_WORDS 15
#define MAX_TRIES 4

It's generally considered "better" in C++ to use const int (or constexpr int
nowadays) than #defines, as you can typecheck, and you don't pollute other
peoples' namespaces.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

srand(time(nullptr));
std::random_shuffle(std::begin(words), std::end(words));

random_shuffle is deprecated and will be removed in C++17. With just a few more
characters you can use shuffle which is better in basically every way.

std::shuffle(std::begin(words), std::end(words), std::mt19937{std::random_device{}()});

(Of course, it doesn't have to be all on one line).

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

return std::vector<std::string>(std::begin(words), std::begin(words) + count - 1);

Good use of iterators! It would be important to check that the length of the
vector is at least count - 1 if you could have arbitrary values passed in for
length and count (or the file weren't hard-coded).

On that note, you don't need this code in main:

//  If there aren't enough words of the given length, then stop
if (words.size() < MIN_WORDS)
{
    std::cout << "Not enough words of length " << length << "." << std::endl;
    return 1;
}
//  If word count is less than expected, change it so we don't crash
else if (words.size() != count)
{
    count = words.size();
}

unless you make the check, because you would already have crashed trying to
dereference past the end of the vector.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

I would probably write get_random(std::pair<int, int>) so that I can do
something like

std::vector<std::pair<int, int>> lengths = {
    { 4, 6 },
    { 7, 8 },
    { 9, 10 },
    { 11, 12 },
    { 13, 15 }
};
length = get_random(lengths[difficulty-1]);

and all the other calls can be get_random(a, b) => get_random({a, b}).

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

for (int i = 0; i < count; i++)
{
    std::cout << words[i] << std::endl;
}

Not a big deal, but it's probably easier to use for (const auto& word : words)
{ std::cout << word << std::endl; }

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

//  Check index by index to count correct letter placements
for (int index = 0; index < length; index++)
{
    if (std::tolower(correct[index]) == std::tolower(guess[index]))
    {
        match_count++;
    }
}

I was going to make a big huff about using std::equal, but that doesn't work to
count. You can still do the following, but I don't know if it's any clearer:

match_count = std::inner_product(std::begin(correct), std::end(correct), std::begin(guess), 0, std::plus<>(),
    [](char l, char r) { return std::tolower(l) == std::tolower(r); });

share
Save
[deleted]
2 points·2 years ago


    It's generally considered "better" in C++ to use const int (or constexpr
    int nowadays) than #defines, as you can typecheck, and you don't pollute
    other peoples' namespaces.

Now would you use #define if it was C?

share
Save
louiswins
2 points·2 years ago

In this case, it's a toss up. There's nothing forcing you to use #define (like
int some_array[MAX_WORDS];), but it is a common idiom in C to use it for
constants. I personally have spent enough time in C++ land that I would still
use const int, but I would have no problem if someone else decided to use #
define.

share
Save
[deleted]
1 point·2 years ago

Yeah in all my C++ courses in college, they taught use to use const.

share
Save
Maiddog
1 point·2 years ago

Thanks for all the input!

For the defines, I had a feeling something was wrong but I wasn't quite sure
what was a better replacement. I had completely forgotten about constexpr
variables and only thought there were constexpr functions, but I now realize
there are both. I'll remember to use those instead of defines when needed.

As for random_shuffle, I did see that there was a C++11 shuffle replacement but
I wasn't able to get it working with what I had read (at least not very quickly
since I was working fast). The thing I came across said to do this:

auto engine = std::default_random_engine{};
std::shuffle(std::begin(cards_), std::end(cards_), engine);

But that didn't work as intended, so I fell back to random_shuffle for the time
being. Thanks for letting me know how to use it properly.

You're also right about the get_words thing. I hadn't thought about not enough
words being taken since the input was hard coded to be within a certain range.
I really should have noticed that. Also regarding the for each thing, I'm
genuinely surprised I didn't use that. I usually use it whenever possible since
I like the syntax over the longer version I ended up with. I guess I wasn't
paying attention.

I really like the range alternative compared to the switch statement. I didn't
think of being able to pass a pair like that, but it does make it cleaner. I
think that the last fix is a bit complex though. I think if it was split into
multiple lines for readability it would be better for me at least. If there's a
performance boost I'd definitely take it, but for a program like this that
doesn't really matter much.

And again, thanks for the input. I don't know a ton about C++11 so it's good to
get some practice and improvements.

share
Save
mellow_gecko
4 points·2 years ago

Python3

import sys
import random

def count_matches(word1, word2):
    """
    Takes two strings of equal length and returns a count
    of the characters in the same position in each string.
    """
    assert len(word1) == len(word2)
    matches = 0
    for i, letter in enumerate(word1):
        if word2[i] == letter:
            matches += 1
    return matches

def get_words(length):
    """
    Opens a dictionary file and returns a list
    of all words of desired length.
    """
    words = []
    with open("enable1.txt", 'r') as f:
        for line in f:
            word = line.strip()
            if len(word) == length:
                words.append(word)
    return words

def get_guess(guesses, clues):
    """
    Asks user to guess from a selection of clues.
    Asks until their guess is one of the clues.
    Returns user's guess.
    """
    guess = input("guess ({} left) >> ".format(guesses)).lower()
    if not guess in clues:
        print("That is not one of the possibilities.")
        return get_guess(guesses, clues)
    return guess

def get_difficulty():
    """
    Asks user for the difficulty they would like to play at.
    Returns a tuple of the password length and number of clues
    appropriate for the chosen difficulty.
    """
    try:
        difficulty = int(input("select difficulty (1-5) >> "))
        assert difficulty >= 1 and difficulty <= 5
    except:
        print("Please enter a number between 1-5.")
        return get_difficulty()

    difficulty_dict = {1: (4, 5), 2: (6, 8), 3: (10, 10), 4: (12, 13), 5: (15, 15)}
    return difficulty_dict[difficulty]

def play_game():
    # set-up
    password_length, num_clues = get_difficulty()
    words = get_words(password_length)
    password = random.choice(words)
    clues = [password]
    while len(clues) < num_clues:
        clue = random.choice(words).lower()
        if not clue in clues:
            clues.append(clue)
    random.shuffle(clues)
    guesses = 4

    # play
    print("\n".join(clues))
    while guesses > 0:
        guess = get_guess(guesses, clues)
        if guess == password:
            print("you win")
            return
        matches = count_matches(password, guess)
        print("{}/{} correct".format(matches, password_length))
        guesses -= 1
    print("you lose")
    return

def main():
    play = True
    while play:
        play_game()
        play = 'y' in input("play again? (y/n) >> ").lower()

if __name__ == "__main__":
    sys.exit(main())

share
Save
mellow_gecko
1 point·2 years ago·edited 2 years ago

I'm still learning so I'm pretty sure there is some naive code (in particular
the count_matches function and the way I build the clue list) which could be
made more concise/effective. Any help much appreciated.

Edit: I just discovered from a comment above that I should have used
random.sample to build the clues list. Thanks, u/supercodes.

share
Save
Trolldeg
1 point·2 years ago·edited 2 years ago

Look at what the zip function does in python. It should help your count_matches
more concise.

Example would be

for a,b in zip('abc', 'efg'):
  print(a,b)

Output is:

a e
b f
c g

I think you could figure out how that would make your function shorter. (And I
think there are some examples in this challenge that has solved it in python
that could help you.)

Edit: If that is more effective or not, I have no clue. But you could basically
write something that would look like this:

return len([(a,b) for a,b in zip(answer,guess) if a == b])

To return the number of correct letters. Its more concise atleast. :)

share
Save
Trolldeg
1 point·2 years ago

Also, you probably only use "assert" for things that should never happen(or
when you test by yourself) and throw an exception for things that are "more"
likely to happen. But someone more versed in python might want to correct me
here.

share
Save
mellow_gecko
1 point·2 years ago

Okay, thanks! I thought there must be something like that as accessing the
string via index rather than iterating over it felt wrong.

share
Save
supercodes
5 points·2 years ago

Python

Guess by index of word in list instead of typing it out, I'm too lazy for
typing the long words.

import random

def matching(password, guess):
    return sum([1 if p == g else 0 for p, g in zip(password, guess)])

def get_words(length, n, filename="../../lib/enable1.txt"):
    with open(filename, "r") as f:
        words = [word for word in map(str.strip, f.readlines()) if len(word) == length]
        return random.sample(words, n)

def clamp(n, nmin, nmax):
    return max(nmin, min(nmax, n))

def fallout_game():
    difficulty = int(raw_input("Difficulty (1-5)? "))
    difficulty = clamp(difficulty, 0, 5)
    word_length = random.choice(((), (4, 5), (6, 7), (8, 9), (10, 11, 12), (13, 14, 15))[difficulty])
    word_amount = random.choice(((), (5, 6), (7, 8), (9, 10), (11, 12, 13), (13, 14, 15))[difficulty])
    words = get_words(word_length, word_amount)
    password = random.choice(words)
    for i, word in enumerate(words):
        print "{} \t {}".format(i, word)
    for n in xrange(4, 0, -1):
        guess = int(raw_input("Guess ({} left)? ".format(n)))
        guess = clamp(guess, 0, word_amount)
        matches = matching(password, words[guess])
        print "{}/{} correct".format(matches, word_length)
        if  words[guess] == password:
            print "You win!"
            break
    else:
        print "You lose!"
    print "The password was {}".format(password)

fallout_game()

share
Save
jstaffans
3 points·2 years ago

Clojure, guesses to be put on a core.async channel.

(ns fallout.core
  (:require [clojure.java.io :as io]
            [clojure.string :as str]
            [clojure.core.async :as async]))

;; First load this namespace, then put guesses on the "guesses-chan" channel:
(comment
  (clojure.core.async/put! fallout.core/guesses-chan "SETTLERS"))


(def ^:const NUM_GUESSES 4)
(def ^:const WORD_LENGTH 8)
(def ^:const DIFFICULTY "Difficulty equals the number of words" 10)

(def words (clojure.string/split-lines (slurp (io/resource "enable1.txt"))))

(defn words-of-length
  [words length]
  (filter #(= (count %) length) words))

(defn chars-matching
  "Returns the number of characters matching at equal positions in two strings"
  [s1 s2]
  (reduce + (map #(if (apply = %&) 1 0) s1 s2)))

;; Put input on this channel. Applies an upper-case transducer.
(def guesses-chan (async/chan 1 (map str/upper-case)))

(defn process-guess
  "Processes a single guess, returns a map describing the state of the game"
  [correct-answer guess answer-count]
  {:correct-guess? (= guess correct-answer)
   :matching       (str (chars-matching correct-answer guess) "/" WORD_LENGTH)
   :game-over?     (= answer-count NUM_GUESSES)})

(defn start-game
  "Starts the game by returning a channel describing the result of a guess"
  [length difficulty]
  (let [words (->> (words-of-length words length) shuffle (map str/upper-case) (take difficulty))
        correct-answer (first (shuffle words))
        answer-count-chan (async/chan)]
    (println "The word I'm looking for is one of:\n")
    (doseq [w words]
      (println w))
    (async/onto-chan answer-count-chan (iterate inc 1))
    (async/map (partial process-guess correct-answer) [guesses-chan answer-count-chan])))


(let [loop-chan (start-game WORD_LENGTH DIFFICULTY)]
  (async/go-loop []
    (let [{:keys [correct-guess? matching game-over?]} (async/<! loop-chan)]
      (cond
        correct-guess? (println "Correct!")
        game-over? (println "Game over!")
        :else (do
                (println (str "Number of positions matching: " matching))
                (recur))))))

share
Save
fvandepitte
0 03 points·2 years ago

Haskell, quick and lazy (not that much time) I've just done the compare part,
feedback is welcome

import Data.Char

calculateScore :: String -> String -> Int
calculateScore xs ys = length $ filter id $ zipWith (==) (toLowerString xs) (toLowerString ys)
    where toLowerString = map toLower

isCorrect :: String -> String -> Bool
isCorrect xs ys = length xs == calculateScore xs ys

share
Save
smls
1 03 points·2 years ago

Couldn't isCorrect simply be:

isCorrect xs ys = xs == ys

share
Save
wizao
1 05 points·2 years ago

Or even

isCorrect = (==)

share
Save
VikingofRock
4 points·2 years ago

I think there's a small problem with that, where the original code is case
insensitive but yours is case sensitive. Easy enough fix though:

isCorrect xs ys = toLowerString xs == toLowerString ys

share
Save
wizao
1 03 points·2 years ago

Or even

isCorrect = (==) `on` map toLower

share
Save
fvandepitte
0 02 points·2 years ago

What do you know, you are absolutely right.

share
Save
wizao
1 02 points·2 years ago·edited 2 years ago

I like your mini solution. While reading the description, I thought we'd have
to also show where the letters intersected, so I came up with something like
this before realizing it wasn't needed:

calculateScore xs ys = length (common xs ys)
common = intersect `on` zip [1..] . map toLower

It made me think your could do:

calculateScore xs ys = length $ filter id $ zipWith (==) `on` map toLower $ xs ys

share
Save
fvandepitte
0 01 point·2 years ago

Nice, looks simpler. I'll test it later on.

share
Save
Boom_Rang
1 point·2 years ago

I only just saw your solution after posting mine (I used Haskell too). For me
the tricky bit was getting the randomness which is inherently not pure.

My solution to get the score:

check :: String -> String -> Int
check s1 s2 = sum $ [1 | (x, y) <- zip s1 s2, x == y]

Edit: I realise now that your solution is way more functional than mine, length
makes more sense and so does filter :)

share
Save
fvandepitte
0 02 points·2 years ago

Well sometimes we like to overthink it, don't we? just look at my
isCorrectimplementation.

I don't program Haskell for that long and I do understand the need for purity.
But I work everyday in legacy code, and actually don't mind the tiny bit impure
code...

Randomness shouldn't be predicatable, just like user input.

If we can manage to handle that correctly, everything should go right :p

share
Save
Wiggledan
3 points·2 years ago·edited 2 years ago

C89 edit: forgot to free the words and close the enable1.txt filestream

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

void set_difficulty(int diff, int *num_words, int *word_len);
void skip_lines(FILE *stream, int lines);
char* stream_to_string(FILE *stream);
void print_upper(char *word);
int compare_words(char *wordA, char *wordB);

int main(void)
{
    FILE *biglist = fopen("enable1.txt", "r");
    int difficulty, num_words, word_len, i;
    int guesses = 4, len, matches;
    char *words[15], *word, *correct;

    printf("\nDifficulty (1-5)? ");
    scanf(" %d", &difficulty);
    while (getchar() != '\n')
        ; /* clear input buffer */
    set_difficulty(difficulty, &num_words, &word_len);

    srand(time(NULL));

    for (i = rand() % 32; i > 0; --i)
        skip_lines(biglist, rand() % RAND_MAX);

    /* get valid words from the word list */
    for (i = 0; i < num_words; ++i) {
        for (;;) {
            word = stream_to_string(biglist);
            if ((len = strlen(word)) == 0) {
                rewind(biglist);
                free(word);
                continue;
            }
            if (len == word_len) {
                print_upper(word);
                words[i] = word;
                skip_lines(biglist, rand() % RAND_MAX);
                break;
            }
            else
                free(word);
        }
    }
    fclose(biglist);

    correct = words[rand() % num_words];

    for (; guesses > 0; --guesses) {
        printf("Guess (%d left)? ", guesses);
        word = stream_to_string(stdin);

        matches = compare_words(correct, word);
        printf("%d/%d correct\n", matches, word_len);

        free(word);
        if (matches == word_len)
            break;
    }
    if (guesses == 0)
        printf("GAME OVER!\n\n");
    else
        printf("You win!\n\n");

    for (i = 0; i < num_words; ++i)
        free(words[i]);

    return 0;
}

void set_difficulty(int diff, int *num_words, int *word_len)
{
    switch(diff) {
        case 1: *num_words = 5;  *word_len = 4;  break;
        case 2: *num_words = 7;  *word_len = 6;  break;
        case 3: *num_words = 10; *word_len = 8;  break;
        case 4: *num_words = 12; *word_len = 12; break;
        case 5: *num_words = 15; *word_len = 15;
    }
}

void skip_lines(FILE *stream, int lines)
{
    char c;
    for (; lines > 0; --lines)
        while ((c = fgetc(stream)) != '\n')
            if (c == EOF)
                rewind(stream);
}

char* stream_to_string(FILE *stream)
{
    int i = 0, max_len = 64;
    char c, *input = malloc(max_len + 1);

    if (input == NULL) {
        printf("Memory allocation error\n");
        exit(EXIT_FAILURE);
    }
    while ((c = fgetc(stream)) != '\n' && c != EOF) {
        if (i >= max_len) {
            input = realloc(input, i + max_len + 1);
            if (input == NULL) {
                printf("Input too long! Memory error!\n");
                exit(EXIT_FAILURE);
            }
        }
        input[i++] = c;
    }
    input[i] = '\0';
    return input;
}

void print_upper(char *word)
{
    for (; *word != '\0'; ++word)
        putchar(toupper(*word));
    putchar('\n');
}

int compare_words(char *wordA, char *wordB)
{
    int matches = 0;
    for (; *wordA != '\0'; ++wordA, ++wordB)
        if (tolower(*wordA) == tolower(*wordB))
            ++matches;
    return matches;
}

share
Save
crossroads1112
2 points·2 years ago

Correct me if I'm wrong, but isn't rand() % N a really bad way to get random
numbers within a range? IIRC, the random number generator favors certain
numbers so the modulo doesn't give you an even distribution.

I've always used lo + rand() / (RAND_MAX / (hi - lo + 1) + 1) where lo is your
lower bound and hi is your lower bound.

share
Save
Wiggledan
1 point·2 years ago

Yeah, you're right about that. I forgot about that while doing the challenge,
plus I was kind of in a rush to post my solution at the time. I'll try to
remember that next time I need RNG :)

share
Save
SatisfiedWithout
3 points·2 years ago

Python 3.4

import random

def run_game(difficulty=3, word_file='enable1.txt', start_word_length = 4, word_length_increase_per_level=3, start_number_of_words=5, number_of_words_increase=3, max_word_length=15, max_number_of_words=15, seed=None):
        random.seed(a=seed)
        word_length = min(int(difficulty)*word_length_increase_per_level+start_word_length, max_word_length)
        num_words =  min(int(difficulty)*number_of_words_increase+start_number_of_words, max_word_length)
        with open(word_file, 'r') as f:
                dictionary = [x for x in map(str.strip, f.readlines()) if len(x) == word_length]
        game_words = random.sample(dictionary, num_words)
        password = random.choice(game_words).upper()
        print("\n".join(game_words).upper())

        for ii in range(0,4):
                guess = input('Guess (' + str(4-ii) + ')? ').upper()
                difference = len([i for i in range(min(len(guess),len(password))) if guess[i] == password[i]])
                print(str(difference) + '/' + str(len(password)) + ' correct')
                if difference == len(password):
                        print("You win!")
                        return
        print("Incorrect. The secret was " + password)

def setup_game():
        print("Welcome to the Fallout Hacking Game")
        print("Please choose a difficulty (1=very easy, 2=easy, 3=average, 4=hard, 5=very hard)")
        difficulty = input(":")
        run_game(difficulty=difficulty)

setup_game()

share
Save
zengargoyle
3 points·2 years ago

Perl 6

I should steal somebody's difficulty level determinations. Only thing of
interest may be picking N random things from a stream in a single pass.

#!/usr/bin/env perl6
use v6;
constant $DEBUG = %*ENV<DEBUG> // 1;

# most favorite one pass random picker
class RandomAccumulator {
  has $.value;
  has $!count = 0;
  method accumulate($input) {
    $!value = $input if rand < 1 / ++$!count;
    self;
  }
}

# get count random words with some filtering
sub random-words(
  Int :$count = 1,
  Int :$length = 5,
  Regex :$match = rx/^<:Letter>+$/,
) {
  my @acc = RandomAccumulator.new xx $count;
  for "/usr/share/dict/words".IO.lines.grep($match)\
    .grep(*.chars == $length) -> $word {
    .accumulate($word) for @acc;
  }
  @acc.map: *.value;
}

sub count-matching-chars(Str $a, Str $b) {
  ($a.comb Zeq $b.comb).grep(?*).elems
}

sub MAIN {

  my $difficulty;

  repeat {
    $difficulty = prompt("Difficulty (1-5): ");
  } until 1 <= $difficulty <= 5;

  # first pass at difficulty levels, tweak as desired
  # maybe pick count/length as some function of $difficulty
  my %level =
    1 => [ count => 5, length => 4 ],
    2 => [ count => 5, length => 4 ],
    3 => [ count => 5, length => 4 ],
    4 => [ count => 5, length => 4 ],
    5 => [ count => 15, length => 15 ],
    ;

  my @words = random-words(|%level{$difficulty}.hash).map(*.fc);
  my $target = @words.pick;
  say "target: $target" if $DEBUG;

  @words.join("\n").say;

  my $won = False;
  for ^4 {
    my $guess = prompt("Guess ({4-$_} left): ").fc;
    if ($guess eq $target) { $won = True; last }
    say "You got &count-matching-chars($guess,$target) characters correct.";
  }

  if $won {
    say "You won!";
  }
  else {
    say "You loose!";
  }

}

share
Save
smls
1 01 point·2 years ago


    class RandomAccumulator

Ooh, that's neat. You never have to load the whole dictionary into RAM, that
way!

    ($a.comb Zeq $b.comb).grep(?*).elems

Also nice. I didn't think of attaching the eq test directly to the zip meta-op
like that, so the corresponding expression in my solution ended up a bit more
verbose...

share
Save
zengargoyle
1 point·2 years ago

Z_op_ and X_op_ and [op] are the operators I always wanted but didn't know I
wanted that I'll probably be abusing a lot. And that random thing is just so
elegant proof-wise that it's my default concept of random now (discounting that
it's a rand, /, and < per item vs memory and a single rand).

share
Save
[deleted]
3 points·2 years ago

In Python. Guesses the answer automatically. In 100 games, it gets ~93 right in
4 attempts.

Give me your feedback!

from random import choice, sample, randint

def get_words(difficulty):

        difficulty_levels = {1:(4,5), 2:(6,7,8), 3:(9,10), 4:(11,12), 5:(13,14,14)}

        length = choice(difficulty_levels[difficulty])
        words = open("enable1.txt").read().split()
        words = [word for word in words if len(word) == length]
        return sample(words, randint(5,15))

def challenge(player, difficulty):

        words = get_words(difficulty)
        password = choice(words)
        print '\n'.join(words)

        for rounds in range(4):
                print "Guess (", rounds + 1, "): "
                guess = player.play(words)
                if guess == password:
                        print "You won!\n"
                        return "Won"

                matches = len([1 for x, y in zip(guess, password) if x == y])
                player.get_feedback(matches, guess)
                print "Guessed ", matches, "/", len(password)

        return "Lost"

class Player:

        def __init__(self):
                self.words = []

        def play(self, words):

                if self.words == []:
                        self.words = words
                word = choice(words)
                self.words.remove(word)
                print "Guessing ", word
                return word

        def get_feedback(self, n, attempt):

                for word in self.words:
                        if len([1 for x, y in zip(word, attempt) if x == y]) != n:
                                self.words.remove(word)

def main():

        P = Player()
        challenge(P, 5)

if __name__ == "__main__":
        main()

share
Save
louiswins
3 points·2 years ago

Partial c++14 solution. Not the actual game, but since everyone else is loading
the entire file and shuffling it, only to discard 99.9% of the words, I thought
I'd demonstrate a more efficient way. It's called "reservoir sampling", and
it's a way to select k items out of a stream of unknown length, all with equal
probability.

The memory usage of this program will stay proportional to length * count
instead of increasing with the size of your dictionary.

#include <fstream>
#include <iostream>
#include <random>
#include <string>
#include <vector>

std::vector<std::string> load_words(std::istream& in, int length, int count) {
    long n = 0;
    std::string word;
    std::vector<std::string> ret;
    ret.reserve(count);

    std::mt19937 gen{std::random_device{}()};

    while (in >> word) {
        if (word.length() != length) continue;
        if (n < count) {
            ret.push_back(word);
        } else {
            auto pos = std::uniform_int_distribution<long>{0, n}(gen);
            if (pos < count) {
                ret[pos] = word;
            }
        }
        ++n;
    }
    return ret;
}

int main() {
    std::ifstream in{"enable1.txt"};
    auto words = load_words(in, 8, 10);

    for (const auto& word : words) {
        std::cout << word << '\n';
    }

    return 0;
}

share
Save
Scroph
0 02 points·2 years ago

An intermediate challenge I can solve ! At least I think I solved it.

D (dlang) solution :

import std.stdio;
import std.algorithm : map, filter, count;
import std.string : strip;
import std.range : zip;
import std.random : uniform, randomShuffle;
import std.conv : to;
import std.array : array;

int main(string[] args)
{
        bool win;
        int difficulty, length, amount, guesses = 5;
        write("Difficulty (1-5)? ");
        readf("%d\n", &difficulty);
        difficulty.handleDifficulty(length, amount);
        string[] words = loadWords(length, amount);
        string password = words[uniform(0, amount)];
        foreach(word; words)
                writeln(word);
        while(--guesses)
        {
                string guess;
                int score;
                writefln("Guess (%d left)? ", guesses);
                readf("%s\n", &guess);
                score = zip(guess, password).count!(e => e[0] == e[1]);
                writefln("%d/%d correct", score, password.length);
                if(score == password.length)
                {
                        win = true;
                        break;
                }
        }
        writeln(win ? "You win!" : "You lose!");
        return 0;
}

string[] loadWords(int length, int amount)
{
        auto wordlist = File("enable1.txt");
        auto words =  wordlist.byLine.filter!(word => word.length == length).map!(word => word.strip.to!string).array;
        words.randomShuffle;
        return words[0 .. amount];
}

void handleDifficulty(int difficulty, ref int length, ref int amount)
{
        switch(difficulty)
        {
                case 1: length = 4; amount = 5; break;
                case 2: length = 6; amount = 8; break;
                case 3: length = 9; amount = 11; break;
                case 4: length = 12; amount = 13; break;
                default: length = 15; amount = 15; break;
        }
}

share
Save
[deleted]
2 points·2 years ago·edited 2 years ago

We ended up pretty close!

Almost exact on the loadWords function. I have map first because I'm using curl to get the words.

import std.random;
import std.algorithm;
import std.string;

void main()
{
    import std.stdio;
    import std.math;
    import std.range;
    import std.uni;

    bool win = false;
    int difficulty, words, correct, wordLength, guesses = 4;
    string answer, guess;

    write("Difficulty (1-5)? ");
    readf("%s\n", &difficulty);

    wordLength = cast(int)round((2.8 * difficulty) + 1.0); // 1 == 4, 5 == 15
    string[] wordList = getWords(wordLength, uniform(5, 15)); // Random number of words, for slightly variable difficulty
    answer = wordList[uniform(0, wordList.length - 1)];

    //Show word list
    foreach (word; wordList)
        writeln(word);

    do {
        writef("Guess (%d left)? ", guesses);
        readf("%s\n", &guess);
        guess.strip;

        if (guess == answer) win = true;
        correct = zip(guess, answer).count!(e => icmp(e[0],e[1]));
        writefln("%d/%d correct", correct, wordLength);
    } while(--guesses && !win);

    writeln("You " ~ (win ? "won" : "lost") ~ "!");
}

string[] getWords(int length, int n) {
    import std.net.curl;
    import std.conv;
    import std.array;

    string[] wordList = byLine("https://dotnetperls-controls.googlecode.com/files/enable1.txt")
                        .map!(word => word.strip.to!string)
                        .filter!(word => word.length == length)
                        .array;
    wordList.randomShuffle;

    return wordList[0 .. n];
}

share
Save
Scroph
0 01 point·2 years ago

Good to see another D submission.

By the way, I just noticed this :

if (guess == answer) win = true;

I haven't tested it, but since the loop only stops once guesses reaches 0, it
seems that the game will keep prompting the user for guesses even after the
correct word is submitted.

share
Save
[deleted]
1 point·2 years ago

Fixed. I turned it off while testing and forgot to put it back.

share
Save
Comment deleted2 years ago
hyrulia
2 points·2 years ago

I think you can replace

print("\n".join(map(lambda x: x.upper(), selection)))

with

print("\n".join(map(str.upper, selection)))

share
Save
mapmaker_y2k
2 points·2 years ago·edited 2 years ago

PHP

<?php
$pa = (isset($_GET['pa']) ? $_GET['pa'] : '');
$difficulty_choice = (isset($_GET['difficulty']) ? $_GET['difficulty'] : 'very easy');
$attempts = (isset($_GET['attempts']) ? $_GET['attempts'] : 1);
$choice = (isset($_GET['choice']) ? $_GET['choice'] : '');
$correct_word = (isset($_GET['correct_word']) ? $_GET['correct_word'] : '');
define('MAX_ATTEMPTS',4);

$word_length = array(
        'very easy'     => 4
        ,'easy'                         => 6
        ,'average'              => 9
        ,'hard'                 => 12
        ,'very hard'    => 15
);

$num_words = array(
        'very easy'     => 5
        ,'easy'                         => 8
        ,'average'              => 10
        ,'hard'                 => 12
        ,'very hard'    => 15
);

$results = '';
$html = '';

switch (strtolower($pa)) {
        case 'compare':
                $cva = choice_vs_answer($choice, $correct_word);
                if ($cva === true) {
                        $html =         '<p>You win!</p>' .
                                                '<form method="get"><input type="submit" value="Try Again?" /></form>';
                        break;
                } else {
                        if (MAX_ATTEMPTS == $attempts) {
                        $results =      '<p>' . $cva . ' correct</p>';
                                $html =         '<p>You lose...</p>' .
                                                        '<form method="get"><input type="submit" value="Try Again?" /></form>';
                                break;
                        } else {
                                $results =      '<p>' . $cva . ' correct</p>' .
                                                                '<p>Guess (' . (MAX_ATTEMPTS - $attempts) . ' left)?</p>';
                                $attempts++;
                        }//END IF
                }//END IF
        case 'play':
                if (isset($_GET['display_words'])) {
                        $display_words = json_decode($_GET['display_words']);
                        $correct_word = $_GET['correct_word'];
                } else {
                        $sub_dict = array();
                        $rand_keys = array();
                        $display_words = array();

                        $full_dict = fopen('enable1.txt','r');
                        while (!feof($full_dict)) {
                                $line = trim(fgets($full_dict, 1024));

                                if (strlen($line) == $word_length[$difficulty_choice]) {
                                        $sub_dict[] = $line;
                                }//END IF
                        }//END WHILE
                        fclose($full_dict);

                        $sub_dict_length = count($sub_dict);
                        while (count($rand_keys) < $num_words[$difficulty_choice]) {
                                $rand = rand(0,$sub_dict_length);

                                if (! in_array($rand, $rand_keys)) {
                                        $rand_keys[] = $rand;
                                }//END IF
                        }//END WHILE

                        foreach ($rand_keys as $key) {
                                $display_words[] = trim($sub_dict[$key]);
                        }//END FOREACH

                        $correct_word = trim($display_words[array_rand($display_words)]);
                }//END IF

                $choices = '';
                foreach ($display_words as $word) {
                        $choices .= '<label><input type="radio" name="choice" value="' . $word . '" /> ' . strtoupper($word) . '</label><br />';
                }//END FOREACH

                if ($pa != 'compare') {
                        $results = '<p>Guess (' . MAX_ATTEMPTS . ' left)?</p>';
                }//END IF
                $html =         '<form method="get">' .
                                        $choices .
                                        '<input type="hidden" name="pa" value="compare" />' .
                                        '<input type="hidden" name="attempts" value="' . $attempts . '" />' .
                                        '<input type="hidden" name="display_words" value=\'' . json_encode($display_words) . '\' />' .
                                        '<input type="hidden" name="correct_word" value="' . $correct_word . '" />' .
                                        '<input type="submit" />' .
                                        '</form>';
                break;
        default:
                $choices = '';
                foreach ($num_words as $difficulty => $num) {
                        $choices .= '<label><input type="radio" name="difficulty" value="' . $difficulty . '" /> ' . $difficulty . '</label><br />';
                }//END FOREACH
                $html =         '<form method="get">' .
                                        $choices .
                                        '<input type="hidden" name="pa" value="play" />' .
                                        '<input type="submit" />' .
                                        '</form>';

                break;
}

echo $results . $html;

function choice_vs_answer($choice, $answer) {
        $choice_letters = str_split(strtoupper($choice));
        $answer_letters = str_split(strtoupper($answer));

        $correct = 0;
        $out_of = count($answer_letters);
        foreach ($choice_letters as $key => $letter) {
                if ($letter === $answer_letters[$key]) {
                        $correct++;
                }//END IF
        }//END FOREACH

        return ($correct == $out_of ? true : $correct . '/' . $out_of);
}//END FUNCTION

?>

share
Save
TheOneOnTheLeft
2 points·2 years ago·edited 2 years ago

Python 3.5

All feedback welcome. It's a bit long, I know, but I've tried to make it
readable. After looking at u/hyrulia's solution, list comprehensions are
definitely something I should remember to think about using.

import random

# Gets a list of words, and selects a password from them
def getWords(numOfWords, wordLength):
    possibleWords = []
    finalWords = []
    with open("/usr/share/dict/words", 'r') as f:
        i = 0
        for line in f:
            l = f.readline()
            if len(l) == wordLength + 1:
                possibleWords.append(l)
    j = 0
    while j <= numOfWords:
        candidate = random.choice(possibleWords)
        if candidate not in finalWords:
            finalWords.append(candidate[:-1].lower())
        j = len(finalWords)
    password = random.choice(finalWords)
    return sorted(finalWords), password

# Allows the player to guess at the password once, and displays the feedback
def takeAGuess(wordList, password, guessesLeft):
    correctLetters = 0
    guess = input("Enter password (%s attempts left): " % (guessesLeft)).lower()
    while guess not in wordList:
        print('That is not a valid guess.')
        guess = input("Enter password (%s attempts left): " % (guessesLeft)).lower()
    for i in range(len(password)):
        if password[i] == guess[i]:
            correctLetters += 1
    print("%s/%s Correct" % (correctLetters, len(password)))
    return guess

# asks the player to select a difficulty level and assigns appropriate word length and no. of options
def setDifficulty():
    level = int(input('Select a difficulty level (1-5): '))
    while level not in range(1, 6):
        level = int(input('Invalid level. Please enter a level from 1 to 5: '))
    wordLength = int((level - 1) * 2.8) + 4
    numOfWords = int((level - 1) * 2.6) + 5
    print(' ')
    return numOfWords, wordLength

# initialises variables
numOfWords, wordLength = setDifficulty()

wordList, password = getWords(numOfWords, wordLength)

guess, guessesLeft = '', 4

for word in wordList:
    print(word.upper())
print(' ')

# main play loop
while guess != password:
    guess = takeAGuess(wordList, password, guessesLeft)
    guessesLeft -= 1
    if guessesLeft == 0:
        print('TERMINAL ENTERING LOCKDOWN')
        break
    elif guess == password:
        print('ACCESS GRANTED')
        break

share
Save
chunes
1 22 points·2 years ago

I had fun with this. Java

import java.util.*;
import java.nio.charset.*;
import java.nio.file.*;

public class FalloutHacking {

    public static void main(String[] args) throws Exception {
        List<String> wordList = Files.readAllLines(Paths.get("enable1.txt"), StandardCharsets.UTF_8);
        Scanner sc = new Scanner(System.in);
        Random rng = new Random();
        System.out.print("Difficulty? (1-5) ");
        int d = sc.nextInt();
        int len = d*2+2;
        List<String> words = new ArrayList<>();

        // Generate and display words
        for (int i = 0; i < d*2+3; i++) {
            int n;
            String w;
            do {
                n = rng.nextInt(wordList.size());
                w = wordList.get(n);
            } while (w.length() != len);
            wordList.remove(n);
            System.out.println(w.toUpperCase());
            words.add(w);
        }

        // Game
        String pass = words.get(rng.nextInt(words.size()));
        for (int g = 4; g > 0; g--) {
            String guess;
            do {
                System.out.printf("Guess (%d left)? ", g);
                guess = sc.next();
                if (guess.length() != len)
                    System.out.printf("Guess must have length of %d.%n", len);
            } while (guess.length() != len);
            System.out.print(numCorrect(guess, pass));
            if (guess.equals(pass)) {
                System.out.print("You win!");
                System.exit(0);
            }
        }
        System.out.println("You lose. The password was " + pass + ".");
    }

    // Given two strings, returns the number of characters they have in common.
    public static String numCorrect(String g, String p) {
        int c = 0;
        for (int i = 0; i < g.length(); i++)
            if (g.charAt(i) == p.charAt(i))
                c++;
        return c + "/" + g.length() + " correct" + "\n";
    }
}

share
Save
japangreg
2 points·2 years ago

My quick solution in Java. Comments welcome.

        import java.io.File;
        import java.io.FileNotFoundException;
        import java.util.Random;
        import java.util.Scanner;

        public class FalloutHack {

                public static boolean correct;

                public static void main(String[] args){

                        File wordList = new File("enable1.txt");

                        int difficulty = 0;

                        Random random = new Random();

                        int challengeListSize = random.nextInt(15);

                        if(challengeListSize < 5){
                                challengeListSize = 5;
                        }

                        int chancesLeft = 4;

                        correct = false;

                        String[] challengeList = new String[challengeListSize];

                        Scanner in = new Scanner(System.in);
                        System.out.print("Difficulty (1-5)? ");
                        difficulty = in.nextInt();

                        while(difficulty <= 0 || difficulty > 5){
                                System.out.println("Sorry, only values between 1 and 5 work. Please try again.");
                                System.out.print("Difficulty (1-5)? ");
                                difficulty = in.nextInt();
                        }

                        try {
                                Scanner wordsIn = new Scanner(wordList);

                                int wordCounter = 0;

                                while(wordsIn.hasNext() && wordCounter < challengeListSize){
                                        String tempString = wordsIn.nextLine();
                                        int wordLength = difficulty * 3 + 1;
                                        if(wordLength > 15){
                                                wordLength = 15;
                                        }

                                        if(tempString.length() == wordLength){
                                                challengeList[wordCounter] = tempString;
                                                wordCounter++;
                                        }
                                }

                                wordsIn.close();

                                String hiddenWord = challengeList[random.nextInt(challengeListSize)];

                                for(String word : challengeList){
                                        System.out.println(word);
                                }

                                String guess = null;

                                System.out.print("Guess (" + chancesLeft + " left)? ");
                                guess = in.next();

                                while(chancesLeft > 1 && !checkGuess(guess, hiddenWord) && !correct){
                                        chancesLeft--;
                                        System.out.print("Guess (" + chancesLeft + " left)? ");
                                        guess = in.next();
                                }

                                if(correct){
                                        System.out.println("You win!");
                                }else{
                                        System.out.println("System locked out.");
                                }

                        } catch (FileNotFoundException e) {
                                // TODO Auto-generated catch block
                                e.printStackTrace();
                        }

                        in.close();

                }

                public static boolean checkGuess(String guess, String hiddenWord){

                        guess = guess.toUpperCase();
                        hiddenWord = hiddenWord.toUpperCase();

                        int correctCount = 0;

                        if(guess.equalsIgnoreCase(hiddenWord)){
                                System.out.println("8/8 correct");
                                correct = true;
                        }else{
                                for(int i = 0; i < hiddenWord.length(); i++){
                                        if(guess.charAt(i) == hiddenWord.charAt(i)){
                                                correctCount++;
                                        }
                                }
                                System.out.println(correctCount + "/" + hiddenWord.length() + " correct");
                                if(correctCount == hiddenWord.length()){
                                        correct = true;
                                }
                        }

                        return correct;
                }

        }

share
Save
SoftDevPadawan
2 points·2 years ago

My C# solution. Feedback is welcome.

class Program { static int DifficultyPrompt() { Console.WriteLine("Difficulty
(1-5)? "); return int.Parse(Console.ReadLine()); }

    static void Main(string[] args)
    {
        bool termProgram = false;

        while (!termProgram)
        {
            HackingGame game = new HackingGame(DifficultyPrompt(), "D:\\Downloads\\enable1.txt");
            game.PlayGame();

            Console.WriteLine("Would you like to play again? (y/n)");
            if (Console.ReadLine().ToUpper() == "N")
                termProgram = true;
        }
    }
}

class HackingGame
{
    private const int MaxGuesses = 4;
    private List<string> wordDictionary = new List<string>();
    private List<string> gameWords = new List<string>();
    private int _correctWordIndex;
    private int _guessesMade = 0;
    private int _wordLength;
    private int _numWords;
    private bool _isGameWon = false;

    private string CorrectWord { get { return gameWords[_correctWordIndex]; } }

    public HackingGame(int difficulty, string dictionaryPath)
    {
        _wordLength = SetWordLength(difficulty);
        _numWords = GetNumWordsByDifficulty(difficulty);
        wordDictionary = GetDictionaryFromFile(dictionaryPath);
        gameWords = SetGameWords(_wordLength);
        _correctWordIndex = SelectCorrectAnswer(gameWords);
    }

    #region Setup
    private int SetWordLength(int difficulty)
    {
        Random rnd = new Random();
        switch (difficulty)
        {
            case 1:
                return rnd.Next(4, 5);
            case 2:
                return rnd.Next(6, 7);
            case 3:
                return rnd.Next(8, 9);
            case 4:
                return rnd.Next(10, 12);
            case 5:
                return rnd.Next(13, 15);
        }
        return -1;
    }

    private int GetNumWordsByDifficulty(int difficulty)
    {
        Random rnd = new Random();
        switch (difficulty)
        {
            case 1:
                return rnd.Next(5, 6);
            case 2:
                return rnd.Next(7, 8);
            case 3:
                return rnd.Next(9, 10);
            case 4:
                return rnd.Next(11, 12);
            case 5:
                return rnd.Next(13, 15);
        }
        return -1;
    }

    private List<string> GetDictionaryFromFile(string path)
    {
        return System.IO.File.ReadAllLines(path).ToList();
    }

    private List<string> SetGameWords(int length)
    {
        return wordDictionary.Where(x => x.Length == length)
                         .OrderBy(dict => Guid.NewGuid())
                         .Take(_numWords)
                         .OrderBy(x => x)
                         .ToList();
    }

    private int SelectCorrectAnswer(List<string> possibleWords)
    {
        Random rnd = new Random();
        return rnd.Next(0, possibleWords.Count - 1);
    }
    #endregion

    #region Play
    public void PlayGame()
    {
        DisplayGameWords();

        while (!CheckGameOver())
            PlayRound();

        DisplayEndGameMessage();
    }

    private void PlayRound()
    {
        DisplayGuessPrompt();
        string guessedWord = Console.ReadLine();
        if(ValidateInput(guessedWord))
        {
            _isGameWon = CompareWords(guessedWord, CorrectWord);
            DisplayGuessMessage(GetNumLettersCorrect(guessedWord));
            _guessesMade++;
        }
        else
        {
            Console.WriteLine("{0} is not a possible word", guessedWord);
        }
    }

    private bool CheckGameOver()
    {
        return _isGameWon || _guessesMade == MaxGuesses;
    }

    private int GetNumLettersCorrect(string guessedWord)
    {
        int numCorrect = 0;

        for (int i = 0; i < guessedWord.Length; i++)
        {
            if (guessedWord.ToUpper()[i] == CorrectWord.ToUpper()[i])
                numCorrect++;
        }

        return numCorrect;
    }

    private bool ValidateInput(string input)
    {
        return gameWords.Select(w => w.ToUpper()).Contains(input.ToUpper());
    }

    private bool CompareWords(string word1, string word2)
    {
        return word1.ToUpper().Equals(word2.ToUpper());
    }

    private void DisplayGameWords()
    {
        foreach (var word in gameWords)
        {
            Console.WriteLine(word.ToUpper());
        }
    }

    private void DisplayEndGameMessage()
    {
        if (_isGameWon)
        {
            Console.WriteLine("Congratulations! You've hacked the system!");
        }
        else
        {
            Console.WriteLine("You've lost. The correct word was {0}", CorrectWord);
            Console.WriteLine("Game Over....");
        }
    }

    private void DisplayGuessPrompt()
    {
        Console.WriteLine("Guess ({0} left)?", MaxGuesses - _guessesMade);
    }

    private void DisplayGuessMessage(int numCorrect)
    {
        Console.WriteLine("{0}/{1} corrct", numCorrect, _wordLength);
    }
    #endregion
}

share
Save
enano9314
2 points·2 years ago

Just because this one doesn't have a challenge feature, one can try to
implement the other aspects of the hacking game present in Fallout.

Namely that choosing certain characters that are present will reset the amount
of tries that you have left.

From the wiki

"There are also things you can do with the characters that are not part of
words. Clicking on matching brackets (i.e. () [] {} <>, even with other
characters between, but not a whole word between) can remove a dud password or
reset the number of remaining guesses to four. The brackets must be of the same
type and on the same line. Although you cannot match brackets with a whole word
between them, you can match brackets separated by the dots that appear when a
dud word is removed ( <.......> ). Also, two or more opening brackets can be
matched to a single closing bracket ("[ [ ]" on a line gives you two chances),
but the opposite is not true ("[ ] ]" only gives you one chance). When you
scroll across this type of entry from left-to-right, the entire entry will be
highlighted letting you know if you've found one or not. "

share
Save
cheers-
1 point·2 years ago·edited 2 years ago

I was thinking the same thing but you have to create a GUI app in that case(you
cant click on stuff on a console).

Every char/word/<chars between brackets> should be in a button or label and
@mouseclick the code should evaluate if correct, you could also add add the
highlight @mouseover.
You could also change the colour of the blackgrounds(panel,buttons etc...) to
black and display the font with that green colour used in Fallout.

If I have time I'll prob do it.

share
Save
enano9314
1 point·2 years ago

Yeah, making GUIs def isn't my strong suit hah

share
Save
errorseven
1 point·2 years ago·edited 2 years ago

Hoping this becomes the next Hard challenge!

Edit: Would be awesome if the bonus was to reverse engineer your own game to
produce accept anything as an answer or somehow reveal the answer password!

share
Save
glenbolake
2 02 points·2 years ago

Python 3. One of the only solutions I've submitted that doesn't use functions
or OOP at all. That feels weird.

import random

difficulty = input('Difficulty (1-5)? ')
while difficulty not in map(str, range(1, 6)):
    difficulty = input('Difficulty (1-5)? ')

difficulty_value = random.choice({
    '1': [4, 5, 6],
    '2': [7, 8, 9],
    '3': [10, 11],
    '4': [12, 13],
    '5': [14, 15]
}[difficulty])
wordlist = open('input/enable1.txt').read().splitlines()
words = [word for word in wordlist if len(word) == difficulty_value]
options = []
for _ in range(difficulty_value + 2):
    word = random.choice(words)
    options.append(word.lower())
    words.remove(word)
    if not words:
        # There might not be difficulty+2 words available.
        break
password = random.choice(options)

for word in options:
    print(word.upper())

tries = 4
guess = ''
while tries and guess != password:
    guess = input('Guess ({} left)? '.format(tries)).lower()
    if guess not in options:
        print('Invalid guess')
        continue
    count = sum(a==b for a,b in zip(guess, password))
    print('{}/{} correct'.format(count, difficulty_value))
    tries -= 1
if guess == password:
    print('You win!')
else:
    print('You lose!')
    print('The answer was', password)

share
Save
cheers-
2 points·2 years ago·edited 2 years ago

Java

I was originally thinking to do a gui and mimic the way fallout minigame works
but dont have time now.
If I have time I will add it later.
Uses Scanner & Regex and it is not case sensitive. Allows to play it again
without closing and recalling java myclass ect...
Java doesn't have goto so I had to implement play it again with recursion.
If someone has a better solution to handle it please let me know.
It is commented hence it should not be to hard to read. Feedback is welcomed.

 import java.util.Scanner;
 import static java.lang.Math.*;
 import java.io.*;
 import java.net.*;
 import java.util.ArrayList;
 /*Inspired by Fallout hacking minigame*/
 class HackingMinigame{
static ArrayList<String> dictionary=new ArrayList<>();
public static void main(String[] args){
        String dictWord;
        BufferedReader inTxt;
        ArrayList<String> pickedWords;
/*Acquires the dictionary*/
        try{
                inTxt=new BufferedReader(new InputStreamReader(new URL("http://users.cs.duke.edu/~ola/ap/linuxwords").openStream()));
                while( (dictWord=inTxt.readLine() )!=null)
                        dictionary.add(dictWord);
                inTxt.close();
        }
        catch(Exception e){System.out.println("could not Acquire the dictionary");e.printStackTrace();System.exit(-1);}
        /*If a player want to play again this method will call itself*/
        startGame();
}
/*picks  number of words from the dictionary based on the difficulty
 *the word @ index=0 will be the correct one*/
private static ArrayList<String> pickWords(int difficulty){
        ArrayList<String> pickedWords=new ArrayList<>(difficulty*4);
        int wordLength=(difficulty>3)?8:5;
        String word;

        for(int i=0;i<difficulty*5;i++){
                boolean wordFound=false;
                while(!wordFound){
                word=dictionary.get( (int)( (dictionary.size()-1)*random() ));
                        if(word.length()==wordLength){
                                pickedWords.add(word);
                                wordFound=true;
                        }
                }

        }
        return pickedWords;
}
/*Handles the game and player inputs
 *it will call itself if the player want to play again or call System.exit if the player wants to quit*/
private static void startGame(){
        Scanner in=new Scanner(System.in);
        ArrayList<String> words=null;
        String correctWord=null;
        String currGuess;
        boolean playAgain=false;
        System.out.println("Welcome to the hacking minigame\n select a difficulty (1-4)? \n Q to quit");
        while(true){
                String input=in.nextLine().trim();
                if(input.matches("[1234]")){
                        words=pickWords(Integer.parseInt(input));
                        correctWord=words.get(0);
                        break;
                }
                if(input.matches("[Qq]")){System.out.println("Goodbye!");in.close();System.exit(0);}
                if(!(input.matches("[1234]")||input.matches("[Qq]"))){
                        System.out.println("Invalid input must be a number from 1 to 4");
                }
        }
        System.out.println("Here's the words, Guess the correct one(4/4):");
        /*Randomly prints the picked words*/
        while(words.size()>0){
                System.out.println( words.remove( (int)((words.size()-1)*random()) ).toUpperCase() );
        }
        /*handles the guess part*/
        for(int i=1;i<5;i++){
                currGuess=in.nextLine().trim();
                if(currGuess.equalsIgnoreCase(correctWord)){
                        System.out.println("Congratulations! "+correctWord+" is the correct one. Solution found in "+i+" tries");
                        break;
                }
                else{
                        System.out.println("It is not the correct one: "+matchingLetters(currGuess,correctWord)+" matching letters \n"+(5-i)+" tries remaining");
                        if(i==4)
                                System.out.println("Game Over!\n "+"it was "+correctWord);
                }
        }
        /*handles the post game if a player wants to play again*/
        while(true){
                System.out.println("\n Input P to play again or q to quit");
                if(in.hasNext("[qQ]")){
                        System.out.println("Goodbye!");
                        playAgain=false;
                        break;
                }
                if(in.hasNext("[Pp]")){
                        System.out.println("\nOk! let's do it!");
                        playAgain=true;
                        break;
                }
                if(!(in.hasNext("[Pp]")||in.hasNext("[qQ]"))){
                        System.out.println("Invalid input: P to play again Q to quit(case insensitive)");in.next();
                }
        }
        //try{System.in.reset();}catch(Exception e){e.printStackTrace();System.exit(-1);}
        if(playAgain){
                System.out.println("\n");
                startGame();
        }
        else{in.close();System.exit(0);}
}
/*Return matching letters  ignoring case*/
private static int matchingLetters(String guess,String solution){
        int numMatchingChars=0;
        for(int i=0;i<solution.length();i++)
                if(i<guess.length())
                        if(guess.charAt(i)==solution.charAt(i)||guess.charAt(i)==(solution.charAt(i)-32)||guess.charAt(i)==(solution.charAt(i)+32))
                                numMatchingChars++;
        return numMatchingChars;
}
 }

share
Save
colbrand
2 points·2 years ago·edited 2 years ago

JAVA with full game logic and messages

public class Main {
    private static int[] difficultySize = new int[]{5, 6, 7, 8, 9, 10};
    private static Set<String> chosenWords;
    private static List<String> dictArray;
    private static final String selectDifficultyText = "Difficulty(1-5) ?";
    private static final String FILEPATH = "enable1.txt";
    private static final String ERROR = "Something went Wrong";
    private static final String GUESS_NOT_IN_ARRAY = "Please select a word from the list";
    private static final String GUESS_MESSAGE = "Guess (%d left)?\n";
    private static final String GUESS_RESULT = "%1d/%2d correct\n";
    private static final String WIN = "You win!";
    private static final String LOSE = "You lose!";
    private static final String TRY_AGAIN = "try again? (y/n)";
    private static String wordToGuess;
    private static Random rnd = new Random();
    private static final int TOTALWORDS = 10;
    private static final int MAX_GUESSES = 4;
    private static int currentDif;
    private static int currentGuess;
    private static boolean isPlaying = true;

    public static void main(String[] args) {
        while (isPlaying) {
            play();
        }
    }
    public static void play() {
        currentGuess = MAX_GUESSES;
        File dictFile = new File(FILEPATH);
        try {
            dictArray = Files.readAllLines(dictFile.toPath());
        } catch (IOException e) {
            System.out.println(ERROR);
        }
        Scanner in = new Scanner(System.in);
        System.out.println(selectDifficultyText);
        try {
            currentDif = difficultySize[Integer.parseInt(in.next())];
        } catch (Exception e) {
            currentDif = 5;
        }
        chosenWords = new HashSet<>();
        String temp;
        while (chosenWords.size() != TOTALWORDS) {
            do {
                temp = dictArray.get(rnd.nextInt(dictArray.size()));

            } while (temp.length() != currentDif);
            chosenWords.add(temp);
            wordToGuess = temp;
        }
        chosenWords.forEach(System.out::println);
        while (currentGuess > 0) {
            System.out.printf(GUESS_MESSAGE, currentGuess);
            String guess = in.next().toLowerCase();
            Boolean guessAgain = chosenWords.contains(guess);
            while (!guessAgain) {
                System.out.println(GUESS_NOT_IN_ARRAY);
                guess = in.next();
                guessAgain = chosenWords.contains(guess);
            }
            int difference = returnDifference(guess);
            System.out.printf(GUESS_RESULT, difference, guess.length());
            if (difference == guess.length()) {
                System.out.println(WIN);
                currentGuess = 0;
            } else {
                currentGuess--;
                if (currentGuess == 0)
                    System.out.println(LOSE);
            }
        }
        tryAgain(in);
    }
    public static void tryAgain(Scanner in) {
        System.out.println(TRY_AGAIN);
        isPlaying = in.next().toLowerCase().equals("y");
    }
    public static int returnDifference(String guess) {
        int length = guess.length();
        int returnValue = 0;
        for (int i = 0; i < length; i++) {
            if (guess.charAt(i) == wordToGuess.charAt(i))
                returnValue++;
        }
        return returnValue;
    }
}

share
Save
chunes
1 21 point·2 years ago

Heh, you really hate magic numbers and strings.

share
Save
colbrand
1 point·2 years ago

I should have prepared seperate XML file :D

share
Save
SerkZex
2 points·2 years ago·edited 2 years ago

Python 3!

import random

def FalloutGame(lvl):


    difficulty = {1: (4, 5, 6), 2: (7, 8), 3: (9, 10, 11), 4: (12, 13), 5: (14, 15)}  # taken from this thread :P
    difficulty =  choice(difficulty[lvl])

        wordCompination = []
        wordFile = open("enable1.txt","r").read().split('\n')
        for word in wordFile:
                if len(word) == difficulty+1:
                        wordCompination.append(word)

        random.shuffle(wordCompination)
        wordCompination = wordCompination[0:15]
        passWord = random.choice(wordCompination)
        print(wordCompination, len(wordCompination))
        print("----------------------------------- PassWord:" , passWord)

        for TimesLeft in range(99,0,-1):

                choosen = input("\nyou have " + str(TimesLeft) +" left. you Write you chose: ");
                if choosen != passWord:


                        passWordCharMatch = 0
                        for pas in range(len(passWord)):
                                for cho in range(len(choosen)):
                                        if passWord[pas] is choosen[cho]:
                                                passWordCharMatch += 1


                        for possiblePassword in wordCompination:
                                WordsCharMatch = 0
                                for k in range(len(possiblePassword)):
                                        for i in range(len(choosen)):
                                                if possiblePassword[k] == choosen[i]:
                                                        WordsCharMatch += 1
                                if WordsCharMatch == 0:
                                        wordCompination.remove(possiblePassword)

                        print(wordCompination, len(wordCompination))
                        print("Password matches: ", passWordCharMatch, "\n")
                else:
                        print("Password is right! you succeded")
                        break


def Main():
        FalloutGame(input("Choose the difficulty (1-5): "))

if __name__ == '__main__':
        Main()

share
Save
fish_on_dude
2 points·2 years ago·edited 2 years ago

Like u/fvandepitte, I've done a mini solution. This one's in Fortran... it just
illustrates how the match-counting could be done.

program mastermind
    character key(7), guess(7)
    character*7:: kv = 'SCORPIO'
    read(kv, '(7A1)') key
    do
        print*, 'enter a 7-letter word (uppercase)'
        read(*,'(7A1)') guess
10      format('(',i0,'/',i0,') correct')
        write(*, 10) nmatch(key,guess),  7
    end do
contains

    integer function nmatch(key, guess)
        character guess(:), key(:)
        nmatch=count(ichar(key)==ichar(guess))
    end function

end program

share
Save
errorseven
2 points·2 years ago·edited 2 years ago

AutoHotkey - Not as concise as I could get it if I took more time but it runs
fast and works!

/* #238 [Intermediate] Fallout Hacking Game
Coded by errorseven @ 10282015
*/

setbatchlines -1

diff := {1: [4, 5, 6], 2: [7, 8], 3: [9, 10, 11], 4: [12, 13], 5: [14, 15]}

DllCall("AttachConsole", "int", -1) || DllCall("AllocConsole")
stdout := FileOpen("*", "w `n")
stdin  := FileOpen("*", "r `n")

stdout.Write("Difficulty (1-5) ? ")
stdout.Read(0)
query := RTrim(stdin.ReadLine(), "`n")

if !((query > 0) and (query < 6))
exitapp

Random, setting, 1, %  diff[query].maxindex()

numberOfWords := diff[query, setting]
lengthOfWords := diff[query, setting]

words := []

FileRead, List, %A_ScriptDir%\enable1.txt
Loop, Parse, List, `n, `r
(StrLen(A_LoopField) == lengthOfWords ? words.Push(A_LoopField) : Continue)

wordList := []

Loop % numberOfWords {
Random, output, 1, % words.maxindex()
wordList.push(words[output])
}

Random, output, 1, wordList.maxindex()

answer := wordList[output]

loop % wordList.MaxIndex() {
 stdout.Write(wordList[A_Index] "`n")
 stdout.Read(0)
}

Loop, 4 {
stdout.Write("Guess (" (5 - A_Index) " left) ? ")
stdout.Read(0)
query := RTrim(stdin.ReadLine(), "`n")
    For Each, Word in wordList {
       If (query == Word)
           results := compareResults(query, answer)
           If (results ~= "You Win!") {
                stdout.Write(results "`n")
                stdout.Read(0)
                Sleep 5000
                ExitApp
            }

    }
    stdout.Write(results "`n")
    stdout.Read(0)
}
stdout.Write("You Lose!`n")
stdout.Read(0)
Sleep 5000
ExitApp

compareResults(picked, word) {
results := 0
For Each, Char in StrSplit(word)
    (Char == SubStr(picked, A_Index, 1) ? results++ : continue)
Return results "/" StrLen(word) " correct" (results == StrLen(word) ?  "`nYou Win!" : "")
}

Output: http://i.imgur.com/wKYs1h1.png

share
Save
errorseven
1 point·2 years ago·edited 2 years ago

Here's Version 2! The code isn't pretty but the game is solid. This version
randomizes the difficulty setting on launch, not quite like the game but you
never know what difficultly you'll encounter before you do. The display is as
close to a recreation as I could make it (without mouse input and word
highlighting). I also didn't add any additional functionality to the game play,
its pretty cut and dry with what I originally posted, so pretty much all the
added code is just aesthetics.

/* #238 [Intermediate] Fallout Hacking Game
Coded by errorseven @ 10312015
*/

SetBatchLines -1

;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
; VARIABLES AND OBJECTS
;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

DllCall("AllocConsole")
stdout := FileOpen("*", "w `n")
stdin  := FileOpen("*", "r `n")
attempts := 4
x := squares(attempts)
message := "ENTER PASSWORD NOW"
global youwin := false
diff := {1: [4, 5, 6], 2: [7, 8], 3: [9, 10, 11], 4: [12, 13], 5: [14, 15]}
words := []
wordList := []

;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
; SETTINGS / INITIAL GAME SCREEN SETUP
;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

difficulty := Random(1, 5)
lengthWords := diff[difficulty, Random(1, diff[difficulty].maxindex())]

FileRead, List, %A_ScriptDir%\enable1.txt
Loop, Parse, List, `n, `r
    (StrLen(A_LoopField) == lengthWords ? words.Push(A_LoopField) : Continue)

Loop % lengthWords {
    wordList.push(words[Random(1, words.maxindex())])
}

hexseed := Random(10000, 50000)
spacing := Round((408 - (lengthWords * lengthWords)) / lengthWords)
wcount := Round((lengthWords / 2))

Loop % spacing {
        string .= Symbols()
    }

For each, Word in WordList {
    string .= Word
    Loop % spacing {
        string .= Symbols()
    }
}
While (StrLen(string) <> 800) {
        string .= Symbols()
    }

Loop, 17 {
    If (A_Index = 17) {
        scr .= Format("`t`t0x{1:X} {2:Us} 0x{3:X} {4:Us} >"
           , hexseed
           , SubStr(string, wcount, 12)
           , (hexseed + 17)
           , SubStr(string, (wcount + 204), 12))
    }
    Else {
        scr .= Format("`t`t0x{1:X} {2:Us} 0x{3:X} {4:Us}`n"
               , hexseed
               , SubStr(string, wcount, 12)
               , (hexseed + 17)
               , SubStr(string, (wcount + 204), 12))
    }
    hexseed++
    wcount += 12
}

answer := wordList[Random(1, wordList.maxindex())]

RunWait %comspec% /c "color 8a"

;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
; GAME LOOP
;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

Loop {
display =
(
`t`t
`t`tROBCO INDUSTRIES (TM) TERMLINK PROTOCOL
`t`t%message%

`t`t%attempts% ATTEMP(S) LEFT: %x%

%scr%
)

    stdout.Write(display)
    stdout.Read(0)
    IF (attempts == 0)
        break
    SetCapsLockState, On
    query := RTrim(stdin.ReadLine(), "`n")
        For each, Word in wordList {
           If (Word ~= "i)"query) {
               scr := updateScreen(scr, answer, query)
               if (youwin == true) {
                   message := "!!! TERMINAL UNLOCKED !!!"
                   attempts := 1
               }
            }
        }
    query := ""
    attempts--
    x := squares(attempts)


    If (attempts == 1 && youwin == false)
        message := "!!! WARNING: LOCKOUT IMMINENET !!!"
    if (attempts == 0 && youwin == false)
        message := "!!! TERMINAL LOCKOUT NOW PROCESSING !!!"

    RunWait %comspec% /c "cls"
}
SetCapsLockState, Off
Sleep 5000

;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
; FUNCTIONS
;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

CompareResults(picked, word) {
    results := 0
    For Each, Char in StrSplit(word)
        (Char == Format("{:U}", SubStr(picked, A_Index, 1)) ? results++ : continue)
Return results
}

UpdateScreen(lowerDisplay, ans, word) {
    consoleMessages := []
    Loop, Parse, lowerDisplay, `n, `r
    {
        line := Trim(A_LoopField)
        If (StrLen(line) > 39 &&  A_Index < 16) {
            consoleMessages.push(SubStr(line, 41))
        }
    }
    consoleMessages.push(">" word)
    results := compareResults(ans, word)
    If (StrLen(ans) <> results) {
        consoleMessages.push(">Entry denied")
        consoleMessages.push(Format(">{1:d}/{2:d} correct", results, StrLen(ans)))
    }
    Else {
        consoleMessages.push(">Entry granted")
        consoleMessages.push(Format(">{1:d}/{2:d} correct", results, StrLen(ans)))
        gameWon()
    }
    Loop, Parse, lowerDisplay, `n, `r
    {
        line := Trim(A_LoopField)
        If (((15 - consoleMessages.MaxIndex()) == A_index) && (A_Index < 17)) {
           cur_scr .= Format("`t`t{1:s} {2:s}`n", SubStr(line, 1, 39), consoleMessages.RemoveAt(1))
        }
        else If (A_Index = 17) {
            cur_scr .= Format("`t`t{1:s}", SubStr(line, 1, 41))
        }
        Else {
            cur_scr .= Format("`t`t{1:s}`n", SubStr(line, 1, 39))
        }
    }
    return cur_scr
}

Symbols() {
    x := [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 58, 59, 60, 61, 62, 63, 64, 94, 123, 124, 125]
    y := Format("0x{1:X}", x[Random(1, x.MaxIndex())])
    return Chr(y)
}

Squares(x) {
    Loop % x {
        results .= Chr(0xDB) A_Space
    }
    Return results
}

GameWon() {
    Global
    youwin := !youwin
    return
}

Random(x, y) {
    Random, results, x, y
    Return Results
}

What it looks like now:

  • http://i.imgur.com/c0oc3mJ.png

  • http://i.imgur.com/RZxgNAQ.png

share
Save
Boom_Rang
2 points·2 years ago

Definitely not the prettiest way to do it, but here's my attempt in Haskell:

import Data.RVar
import Data.Random.Source.DevRandom
import Data.Random.Extras

getDif :: Int -> RVar Int
getDif 1 = choice [4..6]
getDif 2 = choice [7, 8]
getDif 3 = choice [9..11]
getDif 4 = choice [12, 13]
getDif _ = choice [14, 15]

check :: String -> String -> Int
check s1 s2 = sum $ [1 | (x, y) <- zip s1 s2, x == y]

play :: Int -> String -> IO ()
play 0 s = putStrLn $ "You lose, the word was " ++ s
play n s = do
    putStrLn $ "Guess (" ++ show n ++ " left)?"
    word <- getLine
    try (check word s) (length s) where
        try :: Int -> Int -> IO ()
        try a b | a == b = putStrLn $ show a ++ "/" ++ show b ++ " correct\nYou win!"
                | otherwise = do
                    putStrLn $ show a ++ "/" ++ show b ++ " correct"
                    play (n-1) s
main = do
    putStrLn "Difficulty (1-5)?"
    dif <- readLn
    content <- readFile "enable1.txt"
    n <- runRVar (getDif dif) DevRandom
    words <- runRVar (choices n [l | l <- map init $ lines content, length l == n]) DevRandom
    word <- runRVar (choice words) DevRandom
    mapM_ putStrLn words
    play 4 word

share
Save
n2468txd
2 points·2 years ago

IcedCoffeeScript / nodejs ^first ^post ^here ^<:

wordlist = 'enable1.txt'

fs = require 'fs'
readline = require 'readline'
getRandomInt = (min, max) -> return Math.floor(Math.random() * (max - min)) + min # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random

dictionary = fs.readFileSync(wordlist).toString().split('\n')
rl = readline.createInterface
  input: process.stdin
  output: process.stdout

await rl.question 'Difficulty (1-5)? ', defer difficulty
if +difficulty > 5 or +difficulty < 1
    console.error 'Invalid difficulty.'
    process.exit 1

words = []
i = 0
while i < +difficulty*3 # level 5 = 15 words, level 1 = 3 words, scaled by *3
    word = ''
    wordLength = if +difficulty*3 < 4 then 4 else +difficulty*3 # 4 to 15 char long, 4 easiest 15 hardest scaled by *3 except for lv1 is 4
    while word.length isnt wordLength
        index = getRandomInt 0, dictionary.length
        if dictionary[index].trim() in words then continue else word = dictionary[index].trim() # no repeating words, trailing whitespace
    console.log word.toUpperCase()
    words.push word.toLowerCase()
    i++

wordToGuess = words[getRandomInt 0, words.length].split ''
guesses = 4
while guesses > 0
    await rl.question "Guess (#{guesses} left)? ", defer guess
    correctPositions = 0
    i = 0
    while i < wordToGuess.length
        if (wordToGuess[i] or guess[i]) and wordToGuess[i] is guess[i] then correctPositions++ # Check for invalid positions first and check for correct positions
        i++
    console.log "#{correctPositions}/#{wordToGuess.length} correct"
    if correctPositions is wordToGuess.length
        console.log 'You win!'
        process.exit()
    guesses--

console.log "You lose. The correct word was #{wordToGuess.join ''}."
process.exit()

share
Save
[deleted]
2 points·2 years ago·edited 2 years ago

D:

My first go around at this:

import std.random;
import std.algorithm;
import std.string;

void main()
{
    import std.stdio;
    import std.math;
    import std.range;
    import std.uni;

    bool win = false;
    int difficulty, words, correct, wordLength, guesses = 4;
    string answer, guess;

    write("Difficulty (1-5)? ");
    readf("%s\n", &difficulty);

    wordLength = cast(int)round((2.8 * difficulty) + 1.0); // 1 == 4, 5 == 15
    string[] wordList = getWords(wordLength, uniform(5, 15)); // Random number of words, for slightly variable difficulty
    answer = wordList[uniform(0, wordList.length - 1)];

    //Show word list
    foreach (word; wordList)
        writeln(word);

    do {
        writef("Guess (%d left)? ", guesses);
        readf("%s\n", &guess);
        guess.strip;

        if (guess == answer) win = true;
        correct = zip(guess, answer).count!(e => icmp(e[0],e[1]));
        writefln("%d/%d correct", correct, wordLength);
    } while(--guesses && !win);

    writeln("You " ~ (win ? "won" : "lost") ~ "!");
}

string[] getWords(int length, int n) {
    import std.net.curl;
    import std.conv;
    import std.array;

    string[] wordList = byLine("https://dotnetperls-controls.googlecode.com/files/enable1.txt")
                        .map!(word => word.strip.to!string)
                        .filter!(word => word.length == length)
                        .array;
    wordList.randomShuffle;

    return wordList[0 .. n];
}

And now its time for bed.

share
Save
leonardo_m
1 point·2 years ago

"guess.strip;" in your code does nothing (and the type system of D is unable to
catch your bug here). I have improved your code a little (but I still don't
like a lot the early return in the main):

import std.stdio: writeln, writefln, write, writef, readln;
import std.algorithm: map, filter, count;
import std.range: take, zip;
import std.conv: text, to;
import std.array: array;
import std.random: randomCover, uniform;
import std.math: round;
import std.string: strip, toLower;

string[] getWords(in size_t length, in size_t n) {
    import std.net.curl: byLine;

    return "https://dotnetperls-controls.googlecode.com/files/enable1.txt"
           .byLine
           .map!(word => word.strip.text)
           .filter!(word => word.length == length)
           .array
           .randomCover
           .take(n)
           .map!toLower
           .array;
}

void main() {
    enum nGuesses = 10;
    write("Difficulty (1-5)? ");
    immutable difficulty = readln.strip.to!uint;

    // 1 == 4, 5 == 15.
    immutable wordLength = round((2.8 * difficulty) + 1.0).to!uint;

    // Random number of words, for slightly variable difficulty.
    const wordList = getWords(wordLength, uniform(5, 15));

    writefln("%-(%s\n%)", wordList);
    immutable answer = wordList[uniform(0, $ - 1)].toLower;

    foreach (immutable i; 0.. nGuesses) {
        writef("Guess (%d left)? ", nGuesses - i);
        immutable guess = readln.strip.toLower;

        if (guess == answer) {
            writeln("You won!");
            return;
        } else {
            immutable nCorrect = zip(guess, answer)
                                 .count!(e => e[0] == e[1]);
            writefln("%d/%d correct", nCorrect, wordLength);
        }
    }

    writeln("You lost!");
}

share
Save
[deleted]
1 point·2 years ago

If you don't like the early return, just set a bool and break the for loop in a
similar fashion to me? I did this at 1am, so I'm sure it's not the best code

share
Save
leonardo_m
1 point·2 years ago

In Python you avoid the whole problem with code like this (untested), because
"for" has an "else" that runs if you have not done a break:

for i in xrange(n_guesses, -1, -1):
    guess = raw_input("Guess (%d left)? " % i).strip().lower()
    if guess == answer:
        print "You won!"
        break
    else:
        n_correct = sum(a == b for a, b in zip(guess, answer))
        print "%d/%d correct" % (n_correct, word_len)
else:
    print "You lost!"

share
Save
[deleted]
1 point·2 years ago

That however isn't valid code in D. That's also really terrible because it
obfuscates its behavior. Its no longer just iterating over some set.

share
Save
leonardo_m
1 point·2 years ago

That's one typical use case for Python for-else statements, it was created for
such use case. And in my opinion that code is clean and quite readable (more
than the D code).

share
Save
Gregman
2 points·2 years ago

GOLANG or Go

package main

import (
        "bufio"
        "fmt"
        "math/rand"
        "os"
        "strings"
        "time"
)

func errch(s error) {
        if s != nil {
                fmt.Println(s)
                os.Exit(1)
        }
}

func generate_quiz(lvl string, words *bufio.Scanner) string {
        var quiz, play []string
        var diff = map[string][]int{
                "1": {4, 5, 6},
                "2": {7, 8},
                "3": {9, 10, 11},
                "4": {12, 13},
                "5": {14, 15},
        }
        tme := time.Now()
        rand.Seed(int64(tme.Nanosecond()))
        rnd_seed := rand.Intn(len(diff[lvl]))
        for words.Scan() {
                if len(words.Text()) == diff[lvl][rnd_seed] { //num of letters
                        quiz = append(quiz, words.Text())
                }
        }

        for i := 0; i < diff[lvl][rand.Intn(len(diff[lvl]))]; i++ { //num of words
                x := quiz[rand.Intn(len(quiz))]
                play = append(play, x)
                fmt.Println(strings.ToUpper(x))
        }
        return play[rand.Intn(len(play))]
}

func main() {
        var inp string

        dic, e := os.Open("enable1.txt")
        errch(e)
        defer dic.Close()
        reader := bufio.NewReader(dic)
        scanner := bufio.NewScanner(reader)

        for {
                if strings.ContainsAny(inp, "12345") {
                        break
                } else {
                        fmt.Printf("difficulty (1-5)?")
                        _, e = fmt.Scanln(&inp)
                        errch(e)
                }
        }
        answer := generate_quiz(inp, scanner)
        t := len(answer)
        for i := 0; i < 4; i++ {

                for {
                        if t != len(inp) {
                                fmt.Printf("\nGuess (%d left)? ", 4-i)
                                _, e = fmt.Scanln(&inp)
                                errch(e)
                        } else {
                                break
                        }
                }

                x := 0
                for a := 0; a < t; a++ {
                        if strings.IndexByte(answer, inp[a]) >= 0 {
                                x++
                        }
                }
                if x == t {
                        fmt.Println("WIN!")
                        os.Exit(1)
                } else {
                        fmt.Printf("%d/%d correct", x, t)
                        inp = ""
                }
        }
}

Thanks u/hyrulia for dict. That was smart!

share
Save
Fawzors
2 points·2 years ago

ABAP 7.4 SP 05 (always winning in line count)

REPORT z_fal_puzzle.

CLASS lcx_locked DEFINITION INHERITING FROM cx_dynamic_check.
  PUBLIC SECTION.
ENDCLASS.
CLASS lcx_locked IMPLEMENTATION.
ENDCLASS.

CLASS lcl_security_system DEFINITION CREATE PUBLIC.

  PUBLIC SECTION.
    CLASS-METHODS class_constructor.
    TYPES ty_words TYPE STANDARD TABLE OF zwords-word WITH DEFAULT KEY.
    METHODS constructor
      IMPORTING i_security_level TYPE i.
    METHODS get_possible_passwords
      RETURNING VALUE(re_passwords) TYPE ty_words.
    METHODS input_password
      IMPORTING
                i_input_password  TYPE zwords-word
      RETURNING
                VALUE(re_correct) TYPE abap_bool
      RAISING   lcx_locked.
    METHODS get_correct_letters_count
      IMPORTING
        i_password               TYPE zwords-word
      RETURNING
        VALUE(r_correct_letters) TYPE i.

    METHODS get_login_attempts
      RETURNING VALUE(remaining_tries) TYPE i.

  PRIVATE SECTION.
    CLASS-DATA passwords TYPE ty_words.

    DATA number_of_passwords TYPE i.
    DATA password_length TYPE i.
    DATA possible_passwords TYPE ty_words.
    DATA fake_passwords TYPE ty_words.
    DATA main_password TYPE zwords-word.
    DATA number_of_tries TYPE i.

    METHODS get_number_of_passwords
      IMPORTING
        i_security_level TYPE i
      RETURNING
        VALUE(r_result)  TYPE i.

    METHODS get_password_length
      IMPORTING
        i_security_level TYPE i
      RETURNING
        VALUE(r_result)  TYPE i.

    METHODS filter_possible_passwords.

    METHODS set_fake_passwords.

    METHODS set_main_password.

    METHODS get_random_password
      RETURNING
        VALUE(r_random_password) TYPE zwords-word.

    METHODS scramble_passwords
      RETURNING
        VALUE(scrambled_passwords) TYPE ty_words.

    METHODS get_number_of_tries
      IMPORTING
        i_number_of_passwords TYPE i
        i_security_level      TYPE i
      RETURNING
        VALUE(r_result)       TYPE i.
    DATA seed_helper TYPE i.
ENDCLASS.

CLASS lcl_security_system IMPLEMENTATION.

  METHOD class_constructor.
    SELECT word FROM zwords INTO TABLE passwords.
  ENDMETHOD.


  METHOD constructor.
    IF i_security_level < 1
    OR i_security_level > 5.
      MESSAGE e000(su) WITH 'MEOW'.
    ENDIF.

    number_of_passwords = get_number_of_passwords( i_security_level ).
    password_length     = get_password_length( i_security_level ).
    number_of_tries     = get_number_of_tries( i_number_of_passwords = number_of_passwords i_security_level = i_security_level ).
    filter_possible_passwords( ).
    set_main_password( ).
    set_fake_passwords( ).

    scramble_passwords( ).

  ENDMETHOD.


  METHOD get_number_of_passwords.
    r_result = cl_abap_random_int=>create( seed = CONV i( sy-uzeit ) min = i_security_level * 3 + 1  max = ( i_security_level + 1 ) * 3 )->get_next( ) .
  ENDMETHOD.

  METHOD get_password_length.
    r_result = cl_abap_random_int=>create( seed = CONV i( sy-uzeit ) min = i_security_level * 3 + 1  max = ( i_security_level + 1 ) * 3 )->get_next( ) .
  ENDMETHOD.

  METHOD filter_possible_passwords.
    FREE possible_passwords.
    LOOP AT passwords ASSIGNING FIELD-SYMBOL(<password>).
      IF strlen( <password> ) = password_length.
        APPEND <password> TO possible_passwords.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.


  METHOD set_fake_passwords.

    DO number_of_passwords TIMES.
      DATA(fake_password) = get_random_password( ).
      APPEND fake_password TO fake_passwords.
    ENDDO.

  ENDMETHOD.


  METHOD set_main_password.

    main_password = get_random_password( ).

  ENDMETHOD.


  METHOD get_random_password.
    seed_helper = seed_helper + 1.

    DATA(seed_helper_aux) =  seed_helper DIV 2 .

    DATA(l_index) = cl_abap_random_int=>create( seed = CONV i( sy-timlo / seed_helper ) min = 1 max = lines( possible_passwords ) )->get_next( ).

    r_random_password =  possible_passwords[ l_index ].

    DELETE possible_passwords INDEX l_index.

  ENDMETHOD.


  METHOD scramble_passwords.

    FREE scrambled_passwords.
    "create initial list
    DATA(password_list) = fake_passwords.

    APPEND main_password TO password_list.

    "scrambleee
    DO lines( password_list ) TIMES.

      DATA(l_index) = cl_abap_random_int=>create( min = 1 max = lines( password_list ) )->get_next( ).

      DATA(password) = password_list[ l_index ].
      DELETE password_list INDEX l_index.
      APPEND password TO scrambled_passwords.

    ENDDO.
  ENDMETHOD.


  METHOD get_possible_passwords.
    re_passwords = scramble_passwords( ).
  ENDMETHOD.


  METHOD input_password.
    IF number_of_tries = 0.
      RAISE EXCEPTION TYPE lcx_locked.
    ENDIF.

    IF i_input_password = main_password.
      re_correct = abap_true.
    ELSE.
      re_correct = abap_false.
    ENDIF.

    number_of_tries = number_of_tries - 1.

    IF number_of_tries = 0.
      RAISE EXCEPTION TYPE lcx_locked.
    ENDIF..
  ENDMETHOD.


  METHOD get_correct_letters_count.
    DO strlen( i_password ) TIMES.
      DATA(index) = sy-index - 1.
      IF main_password+index(1) = i_password+index(1).
        ADD 1 TO r_correct_letters.
      ENDIF.
    ENDDO.
  ENDMETHOD.


  METHOD get_number_of_tries.
    CASE i_security_level.
      WHEN 1 OR 2.
        r_result = i_number_of_passwords / 2 + 1.
      WHEN 3 OR 4.
        r_result = i_number_of_passwords / 2.
      WHEN 5.
        r_result = i_number_of_passwords / 3.
    ENDCASE.
  ENDMETHOD.


  METHOD get_login_attempts.
    remaining_tries = number_of_tries.
  ENDMETHOD.

ENDCLASS.

CLASS lcl_computer DEFINITION CREATE PUBLIC.

  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        i_security_level TYPE any OPTIONAL.
    METHODS: show_login_screen,
      input_password
        IMPORTING
          i_input_password TYPE zwords-word.
  PROTECTED SECTION.
  PRIVATE SECTION.

    DATA security_system TYPE REF TO lcl_security_system.
    DATA passwords TYPE TABLE OF zwords-word.
    DATA log TYPE TABLE OF char100.

ENDCLASS.

CLASS lcl_computer IMPLEMENTATION.


  METHOD show_login_screen.

    DATA l_intensify TYPE i.
    IF sy-lisel IS NOT INITIAL.
      WRITE: / 'Vault-Tech Security'.
      ULINE.
    ENDIF.
    WRITE: / security_system->get_login_attempts( ) , 'ATTEMPTS LEFT: '.
    DO security_system->get_login_attempts( ) TIMES.
      WRITE 'X'.
    ENDDO.
    ULINE.

    LOOP AT passwords ASSIGNING FIELD-SYMBOL(<password>).
      DATA(l_index) = sy-tabix.

      CLEAR l_intensify.

      IF line_exists( log[ table_line(30) = <password> ] ).
        l_intensify = 6.
      ELSE.
        l_intensify = 0.
      ENDIF.

      TRY.
          IF lines( passwords ) < lines( log ).
            l_index = l_index + lines( log ) - lines( passwords ).
          ENDIF.

          IF line_exists( log[ l_index ] ).
            WRITE: / <password> COLOR = l_intensify , AT 40 '|' && log[ l_index ].
          ELSE.
            WRITE: / <password> COLOR = l_intensify , AT 40 '|'.
          ENDIF.

        CATCH cx_sy_itab_line_not_found.

      ENDTRY.

    ENDLOOP.

    ULINE.
  ENDMETHOD.


  METHOD constructor.
    CREATE OBJECT security_system
      EXPORTING
        i_security_level = i_security_level.

    passwords = security_system->get_possible_passwords( ).
  ENDMETHOD.


  METHOD input_password.
    DATA: log_line LIKE LINE OF log.
    DATA(l_password) = i_input_password.

    CONDENSE l_password NO-GAPS.
    TRY.
        IF  security_system->input_password( l_password ) = abap_true.
          WRITE: '>Access Granted!' TO log_line.
          APPEND log_line TO log.
        ELSE.
          WRITE: '>Entry Denied: ' TO log_line.
          APPEND log_line TO log.
          WRITE i_input_password TO log_line.
          APPEND log_line TO log.

          WRITE: '>' && security_system->get_correct_letters_count( i_input_password )
                     && '/' && CONV string( strlen( i_input_password ) )
                     && 'CORRECT' TO log_line.
          APPEND log_line TO log.


        ENDIF.
      CATCH lcx_locked.
        WRITE: '>Locked!' TO log_line.
        APPEND log_line TO log.
    ENDTRY.

  ENDMETHOD.

ENDCLASS.

PARAMETER: p_difclt TYPE i.

START-OF-SELECTION.

  DATA(computer) = NEW lcl_computer( i_security_level = p_difclt ).
  computer->show_login_screen( ).

AT LINE-SELECTION.

  CASE sy-ucomm.
    WHEN 'PICK'.
      TRY.
          computer->input_password( CONV zwords-word( sy-lisel ) ).
          computer->show_login_screen( ).
        CATCH lcx_locked.

      ENDTRY.
  ENDCASE.

share
Save
mantisbenji
2 points·2 years ago·edited 2 years ago

Haskell solution. Probably can use some Control.Monad do block functions
instead of if-else.

import Data.Char (toLower, toUpper)
import Control.Applicative
import System.IO
import System.Random

difficultyTable :: String -> (Int, Int)
difficultyTable n = case n of
                      "1" -> (5, 4)
                      "2" -> (8, 6)
                      "3" -> (10, 8)
                      "4" -> (12, 10)
                      "5" -> (14, 12)
                      _ -> (0, 0)

guess :: Int -> [String] -> String -> IO ()
guess 0 _ _ = putStrLn "You lose!"
guess l p c = do
    putStr ("Guess (" ++ show l ++ " left)? ")
    hFlush stdout
    input <- map toLower <$> getLine
    if (input `notElem` p)
        then do
            putStrLn "Invalid word"
            guess l p c
        else do
            let hits = length . filter (==True) $ zipWith (==) c input
            if (input /= c)
                then do
                    putStrLn (show hits ++ "/" ++ show (length c) ++ " correct")
                    guess (l - 1) p c
                else putStrLn "You win!"

main :: IO ()
main = do
    putStr "Difficulty (1-5)? "
    hFlush stdout
    (quantity, size) <- difficultyTable <$> getLine
    if (quantity == 0)
        then do
            putStrLn "Invalid difficulty level"
            main
        else do
            dict <- (filter ((== size) . length) . lines) <$> readFile "enable1.txt"
            listSeed <- getStdGen
            correctSeed <- newStdGen
            let indices = map (flip mod (length dict) . abs) . take quantity $ randoms listSeed
                possibleWords = map ((!!) dict) indices
                correctWord = (!!) possibleWords . flip mod quantity . fst $ random correctSeed
            mapM_ (putStrLn . map toUpper) possibleWords
            guess 4 possibleWords correctWord

share
Save
neptunDK
2 points·2 years ago

Python 3. My first intermediate challenge that I have completed, so tips/
comments are welcome. :)

import random

#helper functions
def load_wordset():
    with open('enable1.txt', 'r') as file:
        wordset = {word.strip() for word in file.readlines()}
    return wordset

def filter_word_set(wordset, num):
    return {word for word in wordset if len(word) == num}

def pick_lenght(difficulty):
    lenght = {1: (4, 5), 2: (6, 8), 3: (9, 10), 4: (11, 12), 5: (13, 15)}
    low, high = lenght[difficulty]
    return random.randint(low, high)

def pick_word(wordset):
    return wordset.pop()

def make_words_collection(wordlist, difficulty):
    words_collection = []
    lenght = pick_lenght(difficulty)
    filtered_words_set = filter_word_set(wordlist, lenght)
    while len(words_collection) < lenght:
        words_collection.append(pick_word(filtered_words_set))
    return words_collection

def pick_password(words_collection):
    return random.choice(words_collection)

def show_words_collection(words_collection):
    for word in words_collection:
        print(word)

def set_difficulty():
    return int(input('Difficulty (1-5)?'))

def score_guess(guess, password):
    score = sum(1 for idx in range(len(guess)) if guess[idx] == password[idx])
    maxscore = len(password)
    print('{}/{} correct'.format(score, maxscore))
    return score, maxscore


def main():
    DIFFICULTY = set_difficulty()
    WORDS_COLLECTION = make_words_collection(load_wordset(), DIFFICULTY)
    PASSWORD = pick_password(WORDS_COLLECTION)
    GUESSES_LEFT = 4

    def promt_user_for_guess():
        return input('Guess ({} left)?'.format(GUESSES_LEFT)).lower()

    while GUESSES_LEFT > 0:
        show_words_collection(WORDS_COLLECTION)
        guess = promt_user_for_guess()
        score, maxscore = score_guess(guess, PASSWORD)
        GUESSES_LEFT -= 1

        if score == maxscore:
            print('You win!')
            quit()

    print('You loose...')
    print('Password was: {}'.format(PASSWORD))
    quit()

main()

if __name__ == '__main__':
    main()

share
Save
rjggmp
2 points·2 years ago

Ruby

class Mastermind
  def play
    words = select_words(gets.chomp.to_i)
    secret = words.sample
    puts words

    4.times do
      guess = gets.chomp
      value = check_users_guess(guess,secret)
      if value == secret.length
        return "you win"
      end
      puts "#{value}/#{secret.length}"
    end
    return "you lose, the word was #{secret}"
  end

  def check_users_guess(input, secret)
    secret.chars.zip(input.chars).reduce(0) do |result, (w1,w2)|
      result += 1 if w1 == w2 ; result
    end
  end

  def level
    {
      1 => 4,
      2 => rand(5..6),
      3 => rand(7..9),
      4 => rand(10..12),
      5 => rand(13..15)
    }
  end

  def select_words(difficulty)
    word_length = level[difficulty]
    File.readlines("enable1.txt").map(&:strip).keep_if { |word|
      word.length == word_length
    }.shuffle.take(rand(5..15))
  end
end

p Mastermind.new.play

share
Save
kad1n
2 points·2 years ago

Probably a bit late, but better late than never ;) Here is my java attempt (PS,
first time i post here in this subreddit!) Feedback is appreciated.

package terminalhacker;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Random;

public class TerminalHacker {

    static final Scanner input = new Scanner(System.in);
    static List<String> words = null;
    static Random r = new Random();
    static int gameNumber = 0;
    static int baseWordLength = 4;
    static int difficulty = 1;
    static int numWords = 10;

    public static void main(String[] args) {

        printStart();
        askAndSetDifficulty();
        words = getUsableWordList(new File("C:\\Users\\Kad\\Documents\\NetBeansProjects\\TerminalHacker\\src\\terminalhacker\\words.txt"));

        do {
            gameNumber++;
            startWordGame();
            System.out.println("Do you wish to play again? Type 'yes' to retry.");

        } while ("yes".equals(input.next()));

    }

    private static List<String> getUsableWordList(File file) {
        List<String> allWordsList = new ArrayList();
        String text;

        try {
            BufferedReader reader = new BufferedReader(new FileReader(file));

            System.out.print("Loading words... ");

            while ((text = reader.readLine()) != null) {
                if (text.length() == (baseWordLength + difficulty - 1)) {
                    allWordsList.add(text);
                }
            }

            System.out.println("Finished loading words. " + allWordsList.size() + " words has been loaded.");

        } catch (FileNotFoundException e) {
            System.out.println("File not found.");
        } catch (IOException ex) {
            System.out.println("Words file could not be opened");
        }
        return allWordsList;
    }

    private static void printStart() {
        System.out.println("Welcome to TerminalHacker 1.0");
    }

    private static void askAndSetDifficulty() {
        System.out.println("Please enter difficulty (1-5)");
        String textInput = input.next();
        try {
            int value = Integer.parseInt(textInput);

            if (value >= 1 && value <= 5) {
                difficulty = value;
                System.out.println("Difficulty has been set to: " + value);
            } else {
                askAndSetDifficulty();
            }
        } catch (NumberFormatException e) {
            askAndSetDifficulty();
        }

    }

    private static void startWordGame() {

        List<String> gameWords = getRandomUsableWords(words, numWords);
        String correctWord = getCorrectWord(gameWords);
        boolean hasPlayerWon = false;
        int attempts = 4;
        String userInput;

        System.out.println("\n\n\nStarting game " + gameNumber + ":");
        printWords(gameWords);

        while (attempts > 0 && !hasPlayerWon) {

            System.out.println("Attempts remaining: " + attempts);
            System.out.print("Poll password: ");

            userInput = input.next().toUpperCase();

            if (wordIsInList(gameWords, userInput)) {
                if (correctWord.equals(userInput)) {
                    hasPlayerWon = true;
                    System.out.println("You won!");
                } else {
                    attempts--;
                    if (attempts < 0) {

                    } else {
                        System.out.println("Incorrect");
                        System.out.println("Matching chars: " + getMatchingChars(correctWord, userInput));
                    }

                }
            } else {
                System.out.println("Error: Word not listed");
            }

        }

    }

    private static List<String> getRandomUsableWords(List<String> usableWords, int num) {

        List<String> selectedWords = new ArrayList();
        int counter = 0;

        while (selectedWords.size() < num || counter > 1000) {
            int rNum = r.nextInt(usableWords.size());
            String wordToAdd = usableWords.get(rNum);
            if (!wordIsInList(selectedWords, wordToAdd)) {
                selectedWords.add(wordToAdd.toUpperCase());
            }
        }

        if (selectedWords.size() < num) {
            System.out.println("Could not add enough words. Please add more words to the file.");
        }

        return selectedWords;
    }

    private static String getCorrectWord(List<String> gameWords) {
        return gameWords.get(r.nextInt(gameWords.size() - 1));
    }

    private static void printWords(List<String> gameWords) {
        for (int i = 0; i < gameWords.size(); i++) {
            System.out.println(gameWords.get(i));
        }
    }

    private static boolean wordIsInList(List<String> list, String word) {
        return list.contains(word);
    }

    private static int getMatchingChars(String correctWord, String inputWord) {
        int charsMatching = 0;

        if (correctWord.length() == inputWord.length()) {
            for (int x = 0; x < correctWord.length(); x++) {
                if (correctWord.charAt(x) == inputWord.charAt(x)) {
                    charsMatching++;
                }
            }
        } else {
            System.out.println("Words are diffrent langth, cannot compare.");
            return 0;
        }

        return charsMatching;
    }
}

share
Save
Godspiral
3 33 points·2 years ago·edited 2 years ago

In J, does something different: takes an initial word of any length, filters
the dictionary by that length and words with at least 1 correct letter
location, and returns that new dictionary. It takes a parameter for how long of
a sublist to return, and returns that number of random words that pass the
test.

 gen =: ([ (] {~ ((<. #@]) ? #@])) w&((] (] #~ +./@:= every) [ #~ =&# every) <)@])

  12 gen 'banana'
┌──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┐
│bushes│barked│garden│bopper│guinea│barely│phials│saucer│maraca│vagrom│lambda│jabbed│
└──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┘

this generation allows the generator parameter to be a first blind guess, and
compiles the guessing verb while displaying the choices after the first guess
and "difficulty" param.

genv =: 1 : '# %~&x: (0 {:: m) +/@:= ]'  NB. secret set to first word in list just for debugging clarity.

  pD=:1!:2&2
 gen2 =: 4 : 'g =: ((][pD@list) x gen y) genv label_. g y'

  12 gen2 'banana'

bagnio sleave damply bloops bucket maundy afraid talked dances voting throne
rinser
1r3 NB. result is fraction = 2 of 6

g 'maundy'
1r3
g 'bagnio'
1

The difficulty tends to be based mostly on how many common letters the chosen
word has with generator word. 1 is hardest.

   40 gen2 'banana'

raggle abrade walrus budges clears wauled macons jagers fixate waxers halter
ground rachet syrinx vivary torula brewer bongos barded dasher makers venial
convey fanion buyout bulges bosque bailee mutase zinged gonion zenana cleats
raffle broken lipoma gyving namers ramous caviar
1r6

more challenging game would be to not show the list. 6133 6 letter words with
at least 1 correct position match with banana.

share
Save
Godspiral
3 31 point·2 years ago·edited 2 years ago

A redo that doesn't give away the secret's relationship with the generator, and
picks random secret instead of first.... oh, and add dictionary loading

  w =.  (13{a.) -.~ each cutLF fread jpath ,'~/Downloads/enable1.txt'
 pD=:1!:2&2
 gen2 =: ([ (] {~ ((<. #@]) ? #@])) w&((] (] #~ +./@:= every) [ #~ =&# every) <)@])
  genv =: 1 : '# %~&x: (({::~ ?@#) m) +/@:= ]'
  gen =: 4 : 'g =: (a =. x gen2 y) genv label_. a'

 list 30 gen 'banana'

lairds wonner naives bimbos tagged blames pallor confab mining wintle blurts
exuvia convey saults parole bourgs riling basins gagged cholla carted octave
fairer kaiaks ablaze caters coloni souari consul eunuch

 g  NB. cheat by peeking
 # %~&x: 'fairer' +/@:= ]

share
Save
BHuber09
1 point·2 years ago

I actually did this in my Data Structures class last year. Except we used a
text file that he provided. Regardless, the solution should be the same. Here
was my solution in C++.

https://github.com/BHuber55/LAB03

share
Save
oprimo
0 11 point·2 years ago·edited 2 years ago

My Javascript solution below.

To speed things up and help the user, the code groups the dictionary words by
length and, inside those groups, it creates kind of a 'hash map' using the word
letters, in order, as a key. This effectively groups similar words like
"ensued", "sudden" and "unused" under the same key ("densu"). Since similar
words make the guesswork easier, the code tries to pick groups with 2 or more
words and include all of them among the user choices.

You can play the fully-functional solution (with a quick-and-dirty,
old-school-like interface) here.

(EDIT: forgot to tell that feedback is welcome!)

var masterDictionary = {};
var diffLengths = [[4,5],[6,7,8],[9,10],[11,12],[13,14,15]]; // Word lenghts for each difficulty setting

// Randomizer helpers
var r = function(max) { return Math.round(Math.random() * max); };
var randomElement = function(arr) { return arr.splice(r(arr.length-1),1)[0]; };

var password = '', guesses;

$.get('enable1.txt', function(data) {
        // Group words by length and, inside each length, by the word's alphabetic key
        data.split('\n').forEach(function(word){
                var len = word.length;
                var key = word.split('').sort().reduce(function(p,c){
                        if (p.charAt(p.length-1) == c) return p;
                        else return p + c;
                });
                if (!masterDictionary[len]) masterDictionary[len] = [];
                if (!masterDictionary[len][key]) masterDictionary[len][key] = [];
                masterDictionary[len][key].push(word);
        });

        // Generate a game, picking words of the desired length
        $('#btnPlay').html('Play').attr('disabled', false).click(function(){
                var maxChoices = $('#selAlternatives option:selected').text();
                var difficulty = diffLengths[$('input[name="difficulty"]').filter(':checked').val()];
                var dict = masterDictionary[difficulty[r(difficulty.length - 1)]];
                var keyList = Object.keys(dict);
                var playerChoices = [];

                var key = randomElement(keyList);
                while (playerChoices.length < maxChoices && keyList.length > 0){
                        if (dict[key].length === 0)
                                while (dict[key].length < 2) key = randomElement(keyList); // Prevent picking word groups with only one element
                        playerChoices.push(dict[key].splice(r(dict[key].length-1), 1)[0]);
                }

                var shuffledChoices = []; // Shuffle the selected words to separate the groups
                while (playerChoices.length) shuffledChoices.push(randomElement(playerChoices));

                password = shuffledChoices[r(shuffledChoices.length - 1)];
                guesses = 4;

                // Display the user interface for the game
                $('#output').html('');
                shuffledChoices.forEach(function(word){
                        $('#output').append('<button class="btnWordChoice" name="wordchoice">' + word + '</button></br>');
                });

                $('#output').append('<p>Click the words to guess. ' + guesses + ' guesses remaining.</p>');

                // Process user input and give feedback
                $('.btnWordChoice').click(function(){
                        var guessedWord = this.innerHTML;
                        var p = 0, t = password.length - 1, msg = '';

                        for(var i = 0; i < t; i++)
                                if (guessedWord.charAt(i) === password.charAt(i)) p++;

                        if (p === t) msg = 'Exact match! YOU WIN! ';
                        else {
                                msg = p + '/' + t + ' correct letters. ';
                                if (--guesses) msg += guesses + ' guesses remaining.</p>';
                                else msg += 'Game over! The password was ' + password;
                        }

                        if (!guesses || p === t) $('.btnWordChoice').attr('disabled', true);

                        $('#output').append('<p>' + guessedWord + ' : ' + msg + '</p>');
                });
        });
});

share
Save
tongerny
1 point·2 years ago·edited 2 years ago

Perl v5.8.8

#!/usr/bin/perl

use strict;
use warnings;

my $difficulty;
my $dictionary_file = "/tmp/enable1.txt";
my $attempt_count = 4;
my @word_challenge = (5, 7, 10, 12, 15);
my @length_challenge = (4, 6, 9, 12, 15);

# Prompt user for difficulty level
do
{
    print "Difficulty (1-5)? ";
    $difficulty = <STDIN>;
    chomp($difficulty);

    if( $difficulty !~ m/^[1-5]$/ )
    {
        print STDERR "ERROR: Invalid entry\n";
        undef($difficulty);
    }
} while( ! defined($difficulty) );

# Read all the words from the dictionary file
open(DICTIONARY, "<$dictionary_file") or die("ERROR: Unable to open $dictionary_file: $!");
my @lines = <DICTIONARY>;
my $total_lines = @lines;
close(DICTIONARY);

# Determine number of words and word length based on difficulty
my $word_count = RandomNumber($word_challenge[$difficulty - 1], ($difficulty > 2) ? $word_challenge[$difficulty - 2] : 5);
my $word_length = RandomNumber($length_challenge[$difficulty - 1], ($difficulty > 2) ? $length_challenge[$difficulty - 2] : 4);

# Generate list of words
my @challenge_words;
my $counter = $word_count;
while( $counter-- )
{
    my $word;

    do
    {
        my $line_number = int( rand($total_lines) );

        $word = $lines[$line_number];
        chomp($word);
        my $length = length($word);

        if( $word_length == $length )
        {
            push(@challenge_words, $word);
        }
        else
        {
            undef($word);
        }
    }
    while( ! defined($word) );
}

foreach my $word (@challenge_words)
{
    print $word . "\n";
}

print "\n";

# Randomly select the challenge word from the word list
my $winning_word = $challenge_words[ int( rand($word_count) ) ];
my $winning_length = length($winning_word);

my $correct = 0;

while( $attempt_count )
{
    print "Guess ($attempt_count remaining)? ";
    my $guess = <STDIN>;
    chomp($guess);

    if( $guess =~ m/$winning_word/i )
    {
        $correct = 1;
        last;
    }
    else
    {
        my @letters = split('', $guess);
        my $word = $winning_word;
        my $num_correct = 0;
        while(@letters)
        {
            my $letter = shift(@letters);
            if( $word =~ m/$letter/i )
            {
                $num_correct++;
                $word =~ s/$letter//i;
            }
        }

        print "$num_correct/$winning_length correct\n\n";
    }

    $attempt_count--;
}

if( $correct )
{
    print "You win!\n";
}
else
{
    print "You lose... The correct word was: $winning_word\n";
}

exit 0;


#####################
## Functions Below:
sub RandomNumber
{
    my $max = shift;
    my $min = shift;

    my $val = int( rand($max) + $min );
    if( $val > $max )
    {
        return $max;
    }

    return $val;
}

share
Save
BaronPaprika
1 point·2 years ago·edited 2 years ago

Python 3.5.0. I decided to pick words randomly from enable1, so it's not the
most efficient way of doing it. I wasn't quite sure how difficulty should
relate to word length, so I worked out a few proportions. While that might not
stick to the original setup of the game, it means the difficulty can scale
infinitely given enough really long words.

from random import randint, choice
def hacking_game(difficulty):
    words = open("enable1.txt").read().splitlines()
    length = randint(difficulty + 3, difficulty + 6)
    wordlist = []
    while len(wordlist) < randint(6, 9):
        testword = choice(words)
        if len(testword) == length and testword not in wordlist:
            wordlist += [testword.upper()]
    print("Possible passwords:\n" + "\n".join(i for i in wordlist))
    secret_word = choice(wordlist)
    guesses = 5
    while guesses > 1:
        guesses -= 1
        guess = input("Make a guess (%s left): " % guesses)
        c_letters = 0
        for char in range(len(secret_word)):
            if secret_word[char].lower() == guess[char].lower():
                c_letters += 1
        print("%s/%s correct" % (c_letters, len(secret_word)))
        if c_letters == len(secret_word):
            print("You win!")
            return
    print("The password was %s" % secret_word)

share
Save
_seemethere
1 point·2 years ago


    Python 3.5.0

A combination of a lot of the solutions here. Short and concise and to the
point. Does error trapping for the difficulty check. Uses list comprehension
for both the matching and generating functions.

from random import choice, sample

def gen_wordlist(difficulty):
    lens = ([4, 5, 6], [7, 8], [9, 10, 11], [12, 13], [14, 15])
    wordlen = choice(lens[difficulty - 1])
    with open('enable1.txt', 'r') as infile:
        words = [word.upper() for word in infile.read().splitlines()
                 if len(word) == wordlen]
    return sorted(sample(words, choice(lens[difficulty - 1]))), wordlen

if __name__ == '__main__':
    difficulty = int(input('Difficulty (1-5)? '))
    if difficulty not in range(1, 6):
        print('Not a valid difficutly: {}'.format(difficulty))
        exit()
    wordlist, wordlen = gen_wordlist(difficulty)
    secret = choice(wordlist).lower()
    print('\n'.join(wordlist))
    for guesses in range(4, 0, -1):
        guess = input('Guess ({} left)? '.format(guesses)).lower()
        num_correct = sum([1 for a, b in zip(guess, secret) if a == b])
        print('{}/{} correct'.format(num_correct, wordlen))
        if num_correct == wordlen:
            print('You win!')
            break
    else:
        print('You lose!')

share
Save
fullrobot
1 point·2 years ago

Python 2. Any feedback welcome!

import random

def getWordList(wordList, difficultyParameters):
    ''' Return a smaller list of words from larger list of words'''
    count = difficultyParameters[0]
    lst = random.sample([word for word in wordList if len(word) == difficultyParameters[1]], count)
    return lst

def createWordList(filename):
    '''create Large wordlist from file'''
    try:
        f = open(filename)
        wordList = [line.strip().upper() for line in f]
    except:
        raise IOError
    return wordList

def getDifficultyParameters(difficulty):
    '''returns a tuple for difficulty setting, (number of word choices, number of letters in word)'''
    if difficulty == 1:
        return (random.randint(5,6) , random.randint(4,6))
    if difficulty == 2:
        return (random.randint(7,8) , random.randint(7,8))
    if difficulty == 3:
        return (random.randint(9,10) , random.randint(9,10))
    if difficulty == 4:
        return (random.randint(11,12) , random.randint(11,12))
    if difficulty == 5:
        return (random.randint(13,15) , random.randint(13,15))

def checkGuess(guess, password):

    correct = 0
    for i in range(len(guess)):
        if guess[i].lower() == password[i].lower():
            correct += 1
    return correct

def main():
    gameWon = False
    wordList = createWordList('enable1.txt')
    difficulty = input('Choose difficulty setting (1-5): \n')
    while type(difficulty) != int and difficulty < 1 and difficulty > 5:
        print 'Invalid choice\n'
        difficulty = input('Choose difficulty setting (1-5): \n')
    difficultyParameters = getDifficultyParameters(difficulty)
    passwordLst = getWordList(wordList, difficultyParameters)
    password = random.choice(passwordLst)
    numGuesses = 4
    for word in passwordLst:
        print word
    correct = 0
    while not gameWon and numGuesses != 0:
        guess = raw_input('Guess (' + str(numGuesses) + ' left)? ')
        correct = checkGuess(guess, password)
        print str(correct) + "/" + str(len(password)) + " correct"
        numGuesses -= 1
        if correct == len(password):
            gameWon = True
            print "You win!"

if __name__ == '__main__':
    main()

share
Save
ReckoningReckoner
1 point·2 years ago

Ugly Ruby ugh

class Difficulty
   def get_word_length(level)
      case level
      when 1
         4
      when 2
         rand 5..6
      when 3
         rand 6..9
      when 4
         rand 9..12
      when 5
         rand 12..15
      end
   end

   def get_dictionary(dictionary, level)
      accepted_length = get_word_length(level)
      return dictionary.select {|word| word.length == accepted_length }
   end
end

class Game
   def initialize(dictionary, level)
      dictionary = Difficulty.new.get_dictionary(dictionary, level)
      @word = dictionary.sample
      @hints = (dictionary.sample(@word.length-1) << @word.upcase).shuffle
      @lives = 5
   end

   def score(input)
      score = 0
      @word.chars.each_index { |i| score += 1 if i < input.length && input[i] == @word[i]}
      return score
   end

    def play
      @hints.each {|h| puts h.upcase}
      while @lives > 0
         print "Guess (#{@lives} left)?"; input = gets.chomp.downcase
         if input == @word
            puts "WINNAR!"
            return
         else
            puts "#{score(input)}/#{@word.length} correct"
            @lives -=1
         end
      end
      puts "The word was #{@word}"
   end
end

def main
   dictionary = File.open("enable1.txt").map{|line| line.chomp}
   puts "Choose a level from 1-5"
   level = gets.chomp.to_i
   level.between?(1, 5) ? Game.new(dictionary.dup, level).play : (puts "invalid entry")
end

main

share
Save
therealkbhat
1 point·2 years ago

Ruby

Completely procedural; how can I improve this?

levels = {
  "1" => {"words" => 5, "length" => 4},
  "2" => {"words" => 5, "length" => 6},
  "3" => {"words" => 10, "length" => 8},
  "4" => {"words" => 12, "length" => 12},
  "5" => {"words" => 15, "length" => 15}
}

print "Difficulty (1-5)? "
ans = gets.chomp
numWords, wordLength = levels[ans]["words"], levels[ans]["length"]
possibleWords = Array.new()
count = 0
index = 0

words = File.readlines("enable1.txt").shuffle!

while count < numWords
  if words[index].chomp.length == wordLength
    possibleWords.push(words[index].upcase)
    count += 1
  end
  index += 1
end

puts possibleWords

toGuess = possibleWords[rand(0..numWords-1)]
tries = 4

while tries != 0
  print "Guess (#{tries} left)? "
  guess = gets.chomp.upcase
  idx = 0
  correct = 0
  while idx < wordLength
    if guess[idx] == toGuess[idx]
      correct += 1
    end
    idx += 1
  end
  puts "#{correct}/#{wordLength} correct"
  if correct == wordLength
    puts "You win!"
    break
  end
  tries -= 1
end

share
Save
SirAceBoogie
1 point·2 years ago

C# This challenge was a lot of fun! Here is my first attempt in C#. Feed back
is welcomed! I plan on improving this and making it more like fallout.

Hacking.cs

class Hacking
{
    private int difficulty;
    private string password;
    public int guesses;
    public List<string> PasswordList { get; set; }

    public Hacking(int difficulty, int size)
    {
        this.difficulty = difficulty;
        guesses = 4;
        PasswordList = new List<string>(size);
    }

    public void GeneratePasswordList(string dictonaryPath)
    {
        List<string> WordsMatchingLength = new List<string>();

        using (FileStream fileStream = File.Open(dictonaryPath, FileMode.Open))
        {
            using (StreamReader streamReader = new StreamReader(fileStream))
            {

                while (streamReader.ReadLine() != null)
                {
                    string word = streamReader.ReadLine();
                    if (word.Length == difficulty * 3)
                    {
                        WordsMatchingLength.Add(word);
                    }
                }
            }
        }

        Random random = new Random();
        for (int i = 0; i < 15; i++)
        {
            PasswordList.Add(getRandomWord(WordsMatchingLength, random));
        }

        this.setPassword();
    }

    public int CheckGuess(string guess)
    {
        char[] guessArray = guess.ToCharArray();
        char[] passwordArray = password.ToCharArray();
        int count = 0;
        if (guess.Length > password.Length)
        {
            return 0;
        }

        for (int i = 0; i < guess.Length; i++)
        {
            if (guess[i] == password[i]) count++;
        }

        return count;
    }

    private string getRandomWord(List<string> source, Random random)
    {

        int index = random.Next(0, source.Count - 1);

        return source.ElementAt(index);
    }

    private void setPassword()
    {
        Random random = new Random();
        password = getRandomWord(PasswordList, random);
    }
}

}

Program.cs

 class Program
{
    const string dictonaryPath = "enable1.txt";
    static void Main(string[] args)
    {
        bool quit = false;
        while (!quit)
        {
            Console.WriteLine("NUKE-COLA (TM) TERMLINK PROTOCOL\n");
            Console.WriteLine("Enter difficulty. (1 - 5)");
            int difficulty = int.Parse(Console.ReadLine());

            Hacking hacking = new Hacking(difficulty, 15);
            hacking.GeneratePasswordList(dictonaryPath);
            List<string> passwordList = hacking.PasswordList;

            for (int i = 4; i > 0; i--)
            {
                foreach (var password in passwordList)
                {
                    Console.WriteLine(password);
                }

                Console.WriteLine("You have {0} guesses left!\n", hacking.guesses);
                Console.Write("Enter your guess: ");
                string guess = Console.ReadLine();
                int numberCorrect = hacking.CheckGuess(guess);

                if (numberCorrect == difficulty * 3)
                {
                    Console.WriteLine("Access Granted!");
                }
                else
                {
                    Console.WriteLine("Access Denied!\n{0}/{1} correct", numberCorrect, difficulty * 3);
                }

                hacking.guesses--;
            }

            Console.WriteLine("Play again? (y or n)");
            string quitInput = Console.ReadLine();
            if (Regex.IsMatch(quitInput, "n|N"))
            {
                quit = true;
            }
            else
            {
                quit = false;
            }
        }

        Console.WriteLine("GoodBye!");
    }
}

share
Save
hellercopter
1 point·2 years ago·edited 2 years ago

Java:

public class C0238I {
        public static final Random rand = new Random();
        public static final int GUESSES = 4;

        public static void main(String[] args) throws IOException {
                try (Scanner scanner = new Scanner(System.in)) {
                        List<String> lines = Util.getLinesFromFile(Util.WORDLIST);
                        Collections.shuffle(lines);

                        System.out.print("Choose a difficulty (0-4): ");
                        int difficulty = getWordLengthFromDifficulty(scanner.nextInt());

                        List<String> words = lines
                                .stream()
                                .filter(line -> line.length() == difficulty)
                                //.sorted((s1, s2) -> Integer.compare(rand.nextInt(), rand.nextInt())) not transitive :(
                                .collect(Collectors.toList())
                                .subList(0, 10);

                        String password = words.get(rand.nextInt(words.size()));
                        System.out.println(String.join("\n", words));

                        int length = password.length();
                        for (int tries = 0; tries < GUESSES; ++tries) {
                                System.out.print("Guess (%d left): ", GUESSES - tries);
                                String guess = scanner.next().toLowerCase();

                                long correct = guess(password, guess);
                                if (correct == length) {
                                        System.out.print("You win!");
                                        return;
                                }

                                System.out.printf("%d/%d correct.\n", correct, length);
                        }

                        System.out.printf("You lose, the word was %s.", password);
                }
        }

        public static int getWordLengthFromDifficulty(int difficulty) {
                switch (difficulty) {
                case 0: return rand.nextInt(5 - 4) + 4;
                case 1: return rand.nextInt(8 - 6) + 6;
                case 2: return rand.nextInt(10 - 9) + 9;
                case 3: return rand.nextInt(12 - 11) + 11;
                case 4: return rand.nextInt(15 - 13) + 13;
                default: return -1;
                }
        }

        public static long guess(String password, String guess) {
                return IntStream.range(0, password.length()).filter(n -> password.charAt(n) == guess.charAt(n)).count();
        }
}

share
Save
chunes
1 21 point·2 years ago

Befunge-93

              v
vp020p010 p004<
> 91+ "DEES" 91+ "OMEM" 91+ "MREG" 91+ "ELXA" 91+ "KCOJ" >:#,_$v
v                                                              <
>                                      v
                                       v       <
                                v      ?      v
                             v  ?  v   ^   v  ?^
                            v?v ^ v?v     v?  ^
                            "^"   "^"     "^
                            S M   G A     J
                            E E   E X     O
                            E M   R L     C
                            D O   M E     K
                            " "   " "     "
               vp03p04p05p06< <   < <     <
       >00p    >" )tfel " 00g 68* + "( ?sseuG" >:#,_$5v
>00g1-:|                                              3
       > >"enod",,,,@                                 0
^p020   _^#-4g02,+19<                                 g
>"tcerroc 4 /">:#,_$^                                 ~
^             <                                       :
v     <  p02<                                         ,
    >-|                                               4
>:5-| >20g1+^                                         0
    >$91+,20g.^                                       g
^                                      ,:~g06,:~g05,:~<

Example output:

JOCK
AXLE
GERM
MEMO
SEED
Guess? (4 left) JOCK
0 / 4 correct
Guess? (3 left) SEED
1 / 4 correct
Guess? (2 left) MEMO
4 / 4 correct
done

Caveats:

  • word list is hard-coded

  • only a single, easy difficulty

share
Save
demeteloaf
1 point·2 years ago

erlang: I should probably do something more creative to generate the list such
that you get better words instead of totally randomly...

start_game(WordLength, NumWords) ->
  Dictionary = make_dictionary(),
  Words = get_words(Dictionary, WordLength, NumWords),
  lists:foreach(fun(Word) ->
             io:format("~s~n", [string:to_upper(Word)]) end, Words),
  CorrectWord = lists:nth(random:uniform(length(Words)), Words),
  guess_word(CorrectWord, 4).

make_dictionary() ->
  {ok, Device} = file:open("enable1.txt",[read]),
  make_dictionary_list(Device, []).

make_dictionary_list(Device, Acc) ->
  case io:get_line(Device, "") of
    eof -> file:close(Device), lists:reverse(Acc);
    Line -> make_dictionary_list(Device, [string:strip(Line,both,$\n)|Acc])
  end.


get_words(Dictionary, WordLength, NumWords) ->
  FilteredDict = lists:filter(fun(Word) ->
                       length(Word) =:= WordLength end, Dictionary),
  pick_new_word(FilteredDict, NumWords, []).

pick_new_word(_, 0, Acc) ->
  Acc;

pick_new_word(Dict, NumWords, Acc) ->
  Word = lists:nth(random:uniform(length(Dict)), Dict),
  case lists:member(Word, Acc) of
    true ->
      pick_new_word(Dict, NumWords, Acc);
    false ->
      pick_new_word(Dict, NumWords-1, [Word|Acc])
  end.

evaluate_word(Word, Guess) ->
  CorrectLetters =  evaluate_word(string:to_lower(Word), string:to_lower(Guess), 0),
  case (CorrectLetters =:= length(Word)) and (CorrectLetters =:= length(Guess)) of
    true ->
      correct;
    false ->
      {wrong, CorrectLetters}
  end.

evaluate_word([], _, NumSame) ->
  NumSame;

evaluate_word(_, [], NumSame) ->
  NumSame;

evaluate_word([Let1|Word], [Let2|Guess], NumSame) ->
  case Let1 =:= Let2 of
    true -> evaluate_word(Word, Guess, NumSame+1);
    false -> evaluate_word(Word, Guess, NumSame)
  end.

guess_word(Word, 0) ->
  io:format("out of guesses, the word was ~s~n", [Word]);

guess_word(Word, NumGuesses) ->
  io:format("You have ~p guesses left~n", [NumGuesses]),
  {ok, [Guess]} = io:fread("Guess> ", "~s"),
  case evaluate_word(Word, Guess) of
    correct ->
      io:format("Correct!~n");
    {wrong, NumLetters} ->
      io:format("Wrong, ~p letters correct~n", [NumLetters]),
      guess_word(Word, NumGuesses-1)
  end.

output:

60> fallout:start_game(10,5).
NONDANCERS
CAMPHORATE
AEROBIOSES
HYPOSTATIC
OUTCHEATED
You have 4 guesses left
Guess> NONDANCERS
Wrong, 0 letters correct
You have 3 guesses left
Guess> OUTCHEATED
Wrong, 1 letters correct
You have 2 guesses left
Guess> HYPOSTATIC
Wrong, 0 letters correct
You have 1 guesses left
Guess> CAMPHORATE
Correct!

share
Save
aXIYTIZtUH9Yk0DETdv2
1 point·2 years ago

Rust (since no one has done it yet)

extern crate rand;

const DICT: &'static str = include_str!("../data/dictionary.txt");

fn main() {
    let levels = [(4..7), (7..9), (9..11), (11..13), (13..16)];

    // Get level input
    let level;
    // Loop until level is input
    loop {
        let mut level_str = String::new();
        println!("Insert level (0-4)");
        let _ = std::io::stdin().read_line(&mut level_str);
        level = match level_str.trim().parse::<usize>() {
            Ok(v @ 0 ... 5) => v,
            Err(_) | Ok(_) => {
                println!("Bad level input");
                continue;
            }
        };
        break;
    }


    let mut rng = rand::thread_rng();
    let word_len = rand::sample(&mut rng, levels[level].clone(), 1)[0];
    // gotta filter out 4 for how many words (as there are minimum 5)
    let num_words = std::cmp::max(4, rand::sample(&mut rng, levels[level].clone(), 1)[0]);

    // Sample num_words of length word_len, probably more efficient to split them
    // at compile time but whatever
    let words = rand::sample(&mut rng,
                             DICT.lines().filter(|line| line.len() == word_len),
                             num_words);

    let correct_word = rand::sample(&mut rng, words.iter(), 1)[0];

    for word in &words {
        println!("{}", word);
    }

    for i in 0..4 {
        println!("Guess ({} left):", 4 - i);
        let mut guess = String::new();
        // let _ ignoring errors...
        let _ = std::io::stdin().read_line(&mut guess);

        // Count correct characters
        let num_correct = guess.chars().zip(correct_word.chars()).fold(0, |acc, (a, b)| {
            if a == b {
                acc + 1
            } else {
                acc
            }
        });

        if num_correct == correct_word.len() {
            println!("You win");
            return;
        } else {
            println!("{} correct", num_correct);
        }
    }
    println!("You lose!");
}

share
Save
crossroads1112
1 point·2 years ago·edited 2 years ago

I didn't know about include_str! that's pretty cool, nor about rand::sample

Check out my solution if you'd like.

I'd use print! for user input as it doesn't output the trailing newline (thus
looks a little nicer). In mine I also didn't allow the user to input a string
that wasn't one of the possible words. It'd be trivial to "cheat" the game by
making up specially crafted guesses.

share
Save
aXIYTIZtUH9Yk0DETdv2
1 point·2 years ago

Yours looks good :). Improvement over mine I'm sure ;). I tried to use print!()
intiially but my stdin overwrote it. Maybe it was the version of rust I had
configured at the time.

share
Save
crossroads1112
1 point·2 years ago

That's because terminal output is (usually) line buffered. You need to use
std::io::stderr().flush() after print! to flush the buffer (though this
requires you to use std::io::Write)

share
Save
Qvoovle
1 point·2 years ago

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define LINELEN 64

void choose_answer(char *buf, char **answer, size_t wordlen, int nwords)
{
        int i = 0;
        int n = rand() % nwords;
        size_t len = wordlen + 2;

        if ((*answer = malloc(len)) == NULL) {
                fprintf(stderr, "Error: malloc %zu bytes\n", len);
                exit(EXIT_FAILURE);
        }

        for (buf += n * wordlen + n; *buf != '\n'; buf++)
                (*answer)[i++] = *buf;
        (*answer)[i++] = '\n';
        (*answer)[i] = '\0';
}

/*
 * Choose random words in buffer
 */
void choose_nwords(char **buf, int nwords, size_t wordlen, size_t nlines)
{
        char *tmp;
        size_t len = ((wordlen + 1) * nlines) + 1;

        if ((tmp = malloc(len)) == NULL) {
                fprintf(stderr, "Error: malloc %zu bytes\n", len);
                exit(EXIT_FAILURE);
        }
        int j = 0;
        for (int i = 0; i < nwords; i++) {
                int n = rand() % nlines;
                char *c = *buf;
                for (c += n * wordlen + n; *c != '\n'; c++)
                        tmp[j++] = *c;
                tmp[j++] = '\n';
        }
        if ((*buf = realloc(*buf, len)) == NULL) {
                fprintf(stderr, "Error: realloc %zu bytes\n", len);
                exit(EXIT_FAILURE);
        }
        strcpy(*buf, tmp);
        free(tmp);
}

/*
 * Filter everything except lowercase words of length
 * from source file and capitalize them in destination buffer
 * because source file contains proper names and accent characters
 */
void filter_and_cap(FILE *fp, char **buf, size_t wordlen, size_t *nlines)
{
        const char *accept = "abcdefghijklmnopqrstuvwxyz";
        char tmp[LINELEN];
        int i = 0;

        while (fgets(tmp, LINELEN, fp) != NULL) {
                size_t len = strlen(tmp) - 1;
                if (strspn(tmp, accept) == len && len == wordlen) {
                        (*nlines)++;
                        char *p = tmp;
                        while (*p != '\0')
                                (*buf)[i++] = toupper(*p++);
                }
        }
}

/*
 * Allocate a destination buffer as large as the source file
 */
void make_word_list(const char *filename, char **buf, size_t wordlen,
                    int nwords)
{
        FILE *fp;
        long sz;
        size_t nlines = 0;

        if ((fp = fopen(filename, "r")) == NULL) {
                fprintf(stderr, "Error: fopen %s\n", filename);
                exit(EXIT_FAILURE);
        }
        if (fseek(fp, 0L, SEEK_END) == -1) {
                fprintf(stderr, "Error: fseek %s\n", filename);
                exit(EXIT_FAILURE);
        }
        if ((sz = ftell(fp)) == -1) {
                fprintf(stderr, "Error: ftell %s\n", filename);
                exit(EXIT_FAILURE);
        }
        if (fseek(fp, 0L, SEEK_SET) == -1) {
                fprintf(stderr, "Error: fseek %s\n", filename);
                exit(EXIT_FAILURE);
        }
        if ((*buf = malloc(sz)) == NULL) {
                fprintf(stderr, "Error: malloc %ld bytes\n", sz);
                exit(EXIT_FAILURE);
        }
        filter_and_cap(fp, buf, wordlen, &nlines);
        choose_nwords(buf, nwords, wordlen, nlines);
}

int main(void)
{
        char *buf;
        char *answer;
        int nwords = 0;
        int guesses = 4;
        int difficulty = 0;
        size_t wordlen = 0;
        char line[LINELEN];
        const char *filename = "/usr/share/dict/words";

        srand(time(NULL));
        while (!difficulty) {
                printf("Difficulty (1-5)? ");
                fgets(line, LINELEN, stdin);
                switch (line[0]) {
                case '1':
                        wordlen = 4;
                        nwords = 5;
                        difficulty = line[0] - '0';
                        break;
                case '2':
                        wordlen = 6;
                        nwords = 7;
                        difficulty = line[0] - '0';
                        break;
                case '3':
                        wordlen = 8;
                        nwords = 10;
                        difficulty = line[0] - '0';
                        break;
                case '4':
                        wordlen = 12;
                        nwords = 13;
                        difficulty = line[0] - '0';
                        break;
                case '5':
                        wordlen = 15;
                        nwords = 15;
                        difficulty = line[0] - '0';
                        break;
                }
        }
        make_word_list(filename, &buf, wordlen, nwords);
        choose_answer(buf, &answer, wordlen, nwords);
        printf(buf);

        while (guesses) {
                printf("Guess (%d left)? ", guesses);
                fgets(line, LINELEN, stdin);
                size_t correct = 0;
                char *p = line;
                char *q = answer;
                while (*p != '\n')
                        if (toupper(*p++) == *q++)
                                correct++;
                printf("%zu/%zu correct\n", correct, wordlen);
                if (correct == wordlen) {
                        printf("You win!\n");
                        break;
                } else {
                        guesses--;
                }
        }

        if (!guesses)
                printf("The answer was %s", answer);
        free(buf);
        free(answer);

        return EXIT_SUCCESS;
}

share
Save
WoblyInflatableThing
1 point·2 years ago

C

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#define MAX_WORD_LENGTH 15
#define MAX_WORD_COUNT 15

int main( int argc, char **argv )
{
        // Set Random Seed
        srand( time(NULL) );

        // Allocate Word Memory
        char current_word[128];
        char *word_list[MAX_WORD_COUNT];
        size_t mem_size = MAX_WORD_COUNT * (MAX_WORD_LENGTH+1);
        char *word_block = (char *)malloc( mem_size );
        memset( word_block, 0, mem_size );
        if ( word_block == NULL )
        {
                fprintf( stderr, "ERROR: Could not allocate word memory\n" );
                return 1;
        }
        for( unsigned i = 0; i < MAX_WORD_COUNT; ++i )
                word_list[i] = word_block + ( i * (MAX_WORD_LENGTH+1) );

        // Get Difficulty
        long difficulty = 0;
        while( difficulty < 1 || difficulty > 5 )
        {
                printf( "Please Enter Difficulty (1-5): " );
                scanf( "%s", current_word );
                difficulty = strtol( current_word, (char **)NULL, 10 );
        }

        // Set Word Lengths
        unsigned pass_length = ( (difficulty == 1) ? 4 + rand()%1 :
                                                         (difficulty == 2) ? 6 + rand()%2 :
                                                         (difficulty == 3) ? 9  + rand()%1:
                                                         (difficulty == 4) ? 11 + rand()%1:
                                                         /* else */                      13 + rand()%2 );

        // Print Newline
        printf( "\n" );

        // Read Words from Dictionary file
        FILE *file = fopen( "enable1.txt", "r" );
        if ( file == NULL )
        {
                fprintf( stderr, "ERROR: Could not open dictionary file\n" );
                return 1;
        }
        unsigned retrieve_count = 0;
        while( retrieve_count < MAX_WORD_COUNT )
        {
                char c = fscanf( file, "%s", current_word );
                if ( c == EOF )
                {
                        // Return to Start of File
                        fseek( file, 0, SEEK_SET );
                }
                else
                {
                        // NOTE(troy): The chance value can be lowered to make more similar
                        //                         words more likely, or raised to make words more varied

                        const unsigned length = strlen( current_word );
                        const unsigned chance = 100;
                        if ( length == pass_length && rand() % chance == 0 )
                        {
                                strcpy( word_list[retrieve_count], current_word );
                                ++retrieve_count;
                        }
                }
        }
        fclose( file );

        // Choose Which Word (index) is Correct
        const unsigned winner = rand() % MAX_WORD_COUNT;

        // Debugging - Show Winner
        //printf( "Winner: %u (%s)\n\n", winner, word_list[winner] );

        // Print Word Selection
        for( unsigned i = 0; i < MAX_WORD_COUNT; ++i )
                printf( "%u. %s\n", (i+1), word_list[i] );

        // Print Newline
        printf( "\n" );

        // Loop through, letting user make word selections
        unsigned try_number = 1;
        const unsigned max_tries = 5;
        while( try_number <= max_tries )
        {
                // Get selection
                printf( "Tries Left: %u\n", max_tries+1-try_number );
                printf( "Please choose a word to try (1-15): " );
                scanf( "%s", current_word );
                long selection = strtol( current_word, (char **)NULL, 10 );

                // Check in bounds
                if ( selection < 1 || selection > MAX_WORD_COUNT )
                        continue;

                // Check for Winner
                if ( selection-1 == winner )
                {
                        printf( "Correct! You Win!\n" );
                        break;
                }

                // Loop Through Words Checking
                char *word = word_list[selection-1];
                char *win_word = word_list[winner];
                unsigned correct_count = 0;
                for( unsigned i = 0; i < pass_length; ++i )
                {
                        correct_count += ( word[i] == win_word[i] );
                }
                printf( "Incorrect Selection - Correct Letters: %u\n\n", correct_count );

                ++try_number;
        }

        // Losing Message
        if ( try_number > max_tries )
        {
                printf( "You have been locked out\nPlease connect your system administrator\n\n" );
        }

        // Free and Return Success
        free( word_block );
        return 0;
}

share
Save
chappell28
1 point·2 years ago

Golang

Self-taught newbie, so feedback welcome! Off the top of my head, problems
include entire wordlist is stored in memory and input isn't confirmed to match
one of the possible choices.

Code:

package main

import (
        "bufio"
        "fmt"
        "log"
        "math/rand"
        "os"
        "strings"
        "time"
)

const (
        VERY_EASY = iota
        EASY
        NORMAL
        HARD
        VERY_HARD
)

var wordList map[int][]string

type Round struct {
        Words  []string
        Answer string
        Won    bool
}

func NewRound(diff int, list map[int][]string) (round Round) {
        words := []string{}
        s1 := rand.NewSource(time.Now().UnixNano())
        r1 := rand.New(s1)
        var r, nw int
        switch diff {
        case VERY_EASY:
                r, nw = r1.Intn(3)+3, 5
        case EASY:
                r, nw = r1.Intn(3)+5, 6
        case NORMAL:
                r, nw = r1.Intn(5)+5, 8
        case HARD:
                r, nw = r1.Intn(9)+5, 12
        case VERY_HARD:
                r, nw = r1.Intn(4)+10, 14
        }
        w := list[r]
        for i := 0; i < nw; i++ {
                n := r1.Intn(len(w))
                words = append(words, w[n])
        }

        answer := words[r1.Intn(len(words))]
        round = Round{
                Words:  words,
                Answer: answer,
                Won:    false,
        }

        return round
}

func (r *Round) Guess(g string) (num int) {
        num, gg := 0, strings.ToLower(g)
        if gg == r.Answer {
                num = len(r.Answer)
                r.Won = true
                return
        }

        for i := range r.Answer {
                if gg[i] == r.Answer[i] {
                        num++
                }
        }
        return num
}

func main() {
        fi, err := os.Open("enable1.txt")
        if err != nil {
                log.Fatal(err)
        }
        wordList := make(map[int][]string, 30)
        scanner := bufio.NewScanner(fi)
        for scanner.Scan() {
                str := scanner.Text()
                wordList[len(str)] = append(wordList[len(str)], scanner.Text())
        }
        if err := scanner.Err(); err != nil {
                fmt.Fprintln(os.Stderr, "reading filename:", fi, err)
        }

        fmt.Println("What difficulty would you like? (0-4)")
        var diff int
        if _, err := fmt.Scanln(&diff); err != nil {
                log.Fatal(err)
        }
        r := NewRound(diff, wordList)
        fmt.Println("Guess the word!")
        for i := range r.Words {
                fmt.Println(r.Words[i])
        }

        for g := 0; g < 4; g++ {
                fmt.Println("Enter your guess")
                var guess string
                if _, err := fmt.Scanln(&guess); err != nil {
                        log.Fatal(err)
                }
                num := r.Guess(guess)
                fmt.Printf("%d/%d Correct \n", num, len(r.Answer))
                if r.Won == true {
                        break
                }
        }
        if r.Won == true {
                fmt.Println("You won!")
        } else {
                fmt.Println("You lost! The correct answer was: ", r.Answer)
        }
}

Output:

% ./10282015
What difficulty would you like? (0-4)
4
Guess the word!
aromatherapy
facilitative
misassembled
deformalizes
nonintrusive
underbudding
natriuretics
hornswoggled
graciousness
oscilloscope
nebulosities
diminishable
phosphatidic
discoverable
Enter your guess
nonintrusive
1/12 Correct
Enter your guess
hornswoggled
0/12 Correct
Enter your guess
nebulosities
0/12 Correct
Enter your guess
oscilloscope
1/12 Correct
You lost!

share
Save
taindissa_work
1 point·2 years ago

40 lines of ruby

def get_words(level)
  num_words = [5, 7, 9, 11, 13]
  word_length = [4, 5, 6, 7, 8]
  file = File.open('enable1.txt')
  puts 'Generating...'
  lines = file.readlines.select{|word| word.strip.length == word_length[level-1]}
  file.close
  words = lines.sample(num_words[level-1])
  words.each{|word| word.strip!}
end

def check_guess(guess, answer)
  diff = 0
  answer.length.times { |i| diff += 1 if guess[i] != answer[i] }
  diff
end

while true do
  puts 'what difficulty (1-5)?'
  level = gets.strip.to_i
  guesses = 4
  words = get_words(level)
  puts words
  answer = words.sample.strip
  while guesses > 0 do
    puts "Guess (#{guesses} left)?"
    guess = gets.strip
    difference = check_guess(guess, answer)
    if !words.include? guess
      puts "That word isn't in the range"
    elsif difference > 0
      puts "#{answer.length - difference}/#{answer.length} correct"
      guesses -= 1
    else
      puts "You win"
      break
    end
  end
  puts "You lose it was #{answer}" if guesses == 0
end

share
Save
dangkhoasdc
1 point·2 years ago

Here is my solution using C++.

// Fallout Hacking Game
// Link: https://www.reddit.com/r/dailyprogrammer/comments/3qjnil/20151028_challenge_238_intermediate_fallout/
// very simple version
#include <iostream>
#include <map>
#include <string>
#include <utility>
#include <fstream>
#include <stdexcept>
#include <set>
#include <cstdlib>
#include <algorithm>

const unsigned int max_guess = 4;
const unsigned int max_length_word = 15;
const unsigned int min_length_word = 4;
std::multimap<int, std::string> dict;
void load_dict(const std::string& filename) {
    std::fstream fi(filename, std::ios::in);
    if (fi.fail()) {
        throw std::invalid_argument("Could not read file " + filename);
    }
    std::string word;
    while (fi >> word) {
        int length = word.length();
        if ((min_length_word <= length) && (length <= max_length_word)) {
            dict.insert(std::pair<int, std::string>(length, word));
        }
    }
    fi.close();
}
std::set<std::string> get_words_from_dict(int length, int num_words) {
    std::set<std::string> result;
    auto ret = dict.equal_range(length);
    std::size_t sz = std::distance(ret.first, ret.second);
    std::string word;
    while (result.size() != num_words) {
        std::size_t idx = std::rand() % sz;
        auto iter = ret.first;
        std::advance(iter, idx);
        result.insert(iter->second);
    }
    return result;
}

std::set<std::string> get_words(unsigned int difficulty) {
    std::set<std::string> result;
    switch (difficulty) {
        case 1:
            result = get_words_from_dict(4, 6);
            break;
        case 2:
            result = get_words_from_dict(6, 8);
            break;
        case 3:
            result = get_words_from_dict(8, 10);
            break;
        case 4:
            result = get_words_from_dict(10, 12);
            break;
        case 5:
            result = get_words_from_dict(12, 15);
            break;
    }
    return result;
}
int check_word(std::string guess, std::string correct_word) {
    if (guess.length() != correct_word.length()) {
        return -1;
    }
    int count = 0;
    for (int i = 0; i < guess.length(); ++i)
    {
        if (guess[i] == correct_word[i])
            count++;
    }
    return count;
}

std::string get_correct_word(const std::set<std::string>& words) {
    auto iter = words.begin();
    std::advance(iter, rand() % words.size());
    return *iter;
}
void game() {
    std::srand(time(0));
    int difficulty;
    bool win = false;
    load_dict("enable1.txt");
    std::cout << "Difficulty (1-5)? ";
    std::cin >> difficulty;
    auto words = get_words(difficulty);
    auto correct_word = get_correct_word(words);
    for(auto&& i : words) {
        std::cout << i << std::endl;
    }
    for (unsigned int num_guess = 0; num_guess < max_guess; ++num_guess) {
        std::string guess = "";
        std::cout << "Guess (" << (max_guess - num_guess) << ")? " ;
        std::cin >> guess;
        std::transform(guess.begin(), guess.end(), guess.begin(), ::tolower);
        int corr_positions = check_word(guess, correct_word);
        if (corr_positions < 0) {
            std::cout << "Guess word must have " << correct_word.length() << " characters." << std::endl;
        } else {
            std::cout << corr_positions << "/" << correct_word.length() << " correct." << std::endl;
        }
        if (corr_positions == correct_word.length()) {
            win = true;
            break;
        }
    }

    if (win) {
        std::cout << "You win!" << std::endl;
    } else {
        std::cout << "You lose!" << std::endl;
    }
};
int main(int argc, char const *argv[])
{
    game();
    return 0;
}

share
Save
curtmack
1 point·2 years ago·edited 2 years ago

Clojure

Don't really have much to say about this. It's pretty straightforward.

Oh oh wait I do have something to say about this! Clojure does not
automatically flush output when you call (read-line) and friends. It is
incredibly annoying.

(ns daily-programmer.fallout-hacking
  (:require [clojure.string :refer [upper-case split-lines join]]))

(defn difficulty->len [diff]
  (let [difficulties {:1 [4 5 6]
                      :2 [7 8]
                      :3 [9 10 11]
                      :4 [12 13]
                      :5 [14 15]}]
    (rand-nth (difficulties diff))))

(defn- gen-difficulty-words [diff]
  (let [len (difficulty->len diff)]
    (->> "enable1.txt"
         (slurp)
         (split-lines)
         (filter #(= len (count %)))
         (map upper-case)
         (shuffle)
         (take (+ 5 (rand-int 11))) ; random from 5 to 15
         (vec))))

(defn- check-guess [password guess]
  (= password (upper-case guess)))

(defn- score-guess [password guess]
  (->> guess
       (upper-case)
       (map = password)
       (filter true?)
       (count)))

(defn- ask-difficulty []
  (loop [difficulty nil]
    (if-not (nil? difficulty)
      difficulty
      (do
        (print "Difficulty (1-5)? ")
        (flush)
        (let [diff (keyword (read-line))]
          (if (#{:1 :2 :3 :4 :5} diff)
            (recur diff)
            (do
              (println "Invalid input")
              (recur nil))))))))

(defn- ask-guess [password guesses]
  (let [len (count password)]
    (loop [guess nil]
      (if-not (nil? guess)
        (let [score (score-guess password guess)]
          (println (str score "/" len " correct"))
          score)
        (do
          (print (str "Guess (" guesses " left)? "))
          (flush)
          (let [g (read-line)]
            (if (= len (count g))
              (recur g)
              (do
                (println (str "Guess must be of length " len))
                (recur nil)))))))))

(defn start-game []
  (let [difficulty (ask-difficulty)
        wordlist   (gen-difficulty-words difficulty)
        password   (rand-nth wordlist)
        len        (count password)]
    (println (join "\n" wordlist))
    (loop [guesses 4]
      (if (zero? guesses)
        (println (str "You lose! Password was " password))
        (if (= len (ask-guess password guesses))
          (println "You win!")
          (recur (dec guesses)))))))

(start-game)

Edit: Fixed to validate guess length - it now rejects guesses that don't have
the same number of letters as the password. (Intentionally does not validate
whether non-letters are in the guess, though.)

share
Save
tarunteam
1 point·2 years ago

C#

Main Program

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Security.Cryptography;

namespace ConsoleApplication6
{
    class Program
    {
        static void Main(string[] args)
        {

            string[] lsWords = File.ReadAllLines(@"enable1.txt");
            string userAnswer;
            int wordlength = 0;
            Console.Write("What difficulty would you like to play at?");
            int read = Convert.ToInt32(Console.ReadLine());
            List<string> choice = new List<string>();

            switch (read)
            {
                case 1:
                    wordlength = 5;
                    break;
                case 2:
                    wordlength = 7;
                    break;
                case 3:
                    wordlength = 9;
                    break;
                case 4:
                    wordlength = 12;
                    break;
                case 5:
                    wordlength = 15;
                    break;
                default:
                    Console.WriteLine("You have choosen a incorrect difficulty level!");
                    break;

            }
            ListGen Engine = new ListGen(lsWords);
            choice = Engine.randomList(wordlength);
            Console.WriteLine("=======Choices======");
            foreach(string word in choice)
            {
                Console.WriteLine(word);
            }
            int i;
            for( i= 0; i < 5; i++)
            {
                int j = 0;
                Console.WriteLine("\n");
                Console.WriteLine("Attempt a guess!");
                userAnswer = Console.ReadLine();
                if(userAnswer == Engine.Answer)
                {
                    Console.WriteLine("Your enetered the correct answer, good job vault seaker!");
                    Console.ReadLine();
                    break;
                }
                if (!choice.Contains(userAnswer))
                {
                    Console.WriteLine("Please enter a choice from the list!");
                    i--;
                }
                else
                {
                    for (int k = 0; k < userAnswer.Length; k++)
                    {
                        if (Engine.Answer[k] == userAnswer[k])
                        {
                            j++;

                        }
                    }
                    Console.WriteLine("{0}/{1} match!", j, wordlength);
                }


            }
            if(i ==5)
            {
                Console.WriteLine("You failed, oh no!");
                Console.ReadLine();
            }




        }


    }

}

ListGen

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Security.Cryptography;

namespace ConsoleApplication6
{
    class ListGen
    {
        private List<string> outList = new List<string>(7);
        private string answer;
        private string[] _lsList;
        public string[] lslist
        {
            get { return _lsList; }
        }
        public string Answer
        {
            get
            {
                if (answer == null)
                {
                    throw new ApplicationException("You neeed to execute randomList first!");
                }
                else
                {
                    return answer;
                }
            }
        }


        public ListGen(string[] lslist)
        {
            this._lsList = lslist;

        }

        public List<string> randomList(int iHardness)
        {
            //Checks to make sure you actually put in a hardness
            if (iHardness == 0)
            {
                throw new Exception("Fuck you too bro!");
            }
            Random rand = new Random();
            int r, k,lenght;

            //Generates a answer and adds it to the llist
            while( true)
            {
                r = rand.Next(_lsList.Length);
                answer = _lsList[r];
                if (answer.Length == iHardness)
                {
                    outList.Add(answer);
                    break;
                }
            }

            // adds words to list with some common letters among them
            while(outList.Count<string>() < 7)
            {
                r = rand.Next(_lsList.Length);
                if(_lsList[r].Length == iHardness)
                {
                    k = rand.Next(iHardness-1);
                    lenght = 0;
                    for (int j = 0; j < iHardness;j++)
                    {
                        if(_lsList[r][j] == answer[j])
                        {
                            lenght++;
                        }
                    }
                    if(lenght == k)
                    {
                        outList.Add(_lsList[r]);
                    }

                }
            }
            var provide = new RNGCryptoServiceProvider();
            int n = outList.Count;
            while (n > 1)
            {
                byte[] box = new byte[1];
                do provide.GetBytes(box);
                while (!(box[0] < n * (byte.MaxValue / n)));
                var m = (box[0] % n);
                n--;
                string value = outList[m];
                outList[m] = outList[n];
                outList[n] = value;
            }

            return outList;

        }


    }

}

share
Save
hbeggs
1 point·2 years ago·edited 2 years ago

Here's my novice attempt at Python 2.7

import random, sys

def main():
    usrinpt = raw_input("Please select a difficulty:\n\nvery easy\neasy\naverage\nhard\nvery hard\n")
    wrdcnt = difficulty(usrinpt)
    words = computer_choices(wrdcnt)
    keyword = words[random.randint(0,len(words)-1)]
    interface(words, keyword)

def interface(words, keyword):
    tries = 0
    while tries < 4:
        print "One of words in this list is the password, you have used {0} tries...".format(tries)
        for i in words:
            print i
        user_choice = raw_input("Your selection please: ")
        if user_choice == keyword:
            print "You have successfully hacked the system; your selection matched the password."
            sys.exit()
        elif user_choice in words:
            correct_letters = word_comparison(user_choice, keyword)
            print "{0} / {1} letters correct...".format(correct_letters, len(keyword))
        tries+=1
    else:
        print "You have been locked out of the terminal.\n\n\n\n\n\n\nGoodbye"
        sys.exit()

def word_comparison(user_choice, keyword):
    matches = 0
    for i in range(len(keyword)):
        if user_choice[i] == keyword[i]:
            matches+=1
    return matches

def computer_choices(numberofwords):
    words = []
    character_count = random.randint(4,15)
    with open('/path/to/Word_list', 'r') as wordlist:
        wl = wordlist.read().splitlines()
        while len(words) < numberofwords:
            word = wl[random.randint(0, len(wl))]
            if len(word) == character_count:
                words.append(word)
    for i in words:
        i.replace("\\", "")

    words = [i.replace("\\", "") for i in words]
    return words

def difficulty(choice):
    choice = choice.lower()
    option = ["very easy", "easy", "average", "hard", "very hard"]
    rubric = {0: 5, 1: 8, 2: 10, 3: 12, 4: 15}
    if choice not in option:
        print "Please select a valid choice"
        main()
    else:
        selection = option.index(choice)
        return rubric[selection]

main()

Let me know where I can improve

share
Save
FreeIceCreen
1 point·2 years ago

Python 3.5

This is the first time I'm submitting a solution, but I was pretty proud of
this, and I think I could make it better. Any tips?

My Solution

share
Save
MusicPants
1 point·2 years ago·edited 2 years ago

Hi r/dailyprogrammer

Here is my attempt at making this into a game. This is my first 'untutorialed'
use of using ajax. I am using it to grab the .txt file. The program is mostly
working and plays reasonably well, but sometimes it seems like the JavaScript
is getting stuck somewhere and I am getting a runtime error intermittently.

My code is a bit of a mess so I apologize for that but this is my first try at
an intermediate DP challenge so that's a plus.

Thanks for any help. Here is the link, http://musicpants.net/webapps/
password-game/

var guesses = 4;
var score = 0;
var winnerColor = 'rgba(123, 197, 77, 0.5)';
var loserColor = 'rgba(199, 19, 22, 0.93)';
var initialColor = '#fff';
var difficultyParams = [
    {
        difficulty: 'Very Easy',
        wordLength: 4,
        wordCount: 5
    },
    {
        difficulty: 'Easy',
        wordLength: 4,
        wordCount: 6
    },
    {
        difficulty: 'Medium',
        wordLength: 5,
        wordCount: 6
    },
    {
        difficulty: 'Hard',
        wordLength: 6,
        wordCount: 7
    },
    {
        difficulty: 'Very Hard',
        wordLength: 7,
        wordCount: 10
    }
];
var elDivPasswordContainer = document.getElementById('pwdcontainer');
var elDifficultySelector = document.getElementById('difficulty-setting');
var elPlayAgainBtn = document.getElementById('playagainbtn');
var elWordContainer = document.getElementById('wordcontainer');
var elChooseYouDifficultyH2 = document.getElementById('choosedifficulty');
var elGuessContainer = document.getElementById('guesscontainer');
var password;

function guessUpdater(number) {
    elGuessContainer.innerHTML = 'Remaining number of guesses: '+number.toString();
}
//Parse dictionary
//wordlist will be equal to the XMLHttpRequest returned text. difficultyObj will be passed in depending on the selection of the dropdown.
function wordsByDifficulty(wordlist, difficultyObj) {
    var listOfWords = [];
    var passwords = [];
    var wordArray = wordlist.split('\n');
    wordArray.forEach(function(element){
        if (element.length === difficultyObj.wordLength + 1) {
            listOfWords.push(element);
        }
    });
    //push a random selection of the correct length words to the password array.
    for (var i = 0; i < difficultyObj.wordCount; i++) {
        passwords.push(listOfWords[Math.floor(Math.random() * listOfWords.length)]);
    };
    return passwords;
};

function createPasswordDivs(word, index) {
    var makeDiv = document.createElement('div');
    makeDiv.setAttribute('class', 'password-word');
    makeDiv.setAttribute('id', index.toString());
    makeDiv.innerHTML = word;
    makeDiv.addEventListener('click', function(){

        function validator(element) {
            var wordChildren = elWordContainer.children;

            //REVEAL EACH LETTER's DIV CODE HERE:
            for(var i = 0; i < element.innerHTML.length - 1; i++) {

                if (element.innerHTML.charAt(i) === password.charAt(i)) {
document.getElementById('word'+i.toString()).firstChild.style.visibility = 'visible';
                }
            }


                if (password === element.innerHTML) {
                    for (var i = 0; i < wordChildren.length; i++) {
                                wordChildren[i].style.background = winnerColor;
                        wordChildren[i].firstChild.style.visibility = 'visible';
                            }
                    alert('You win!');
                    elGuessContainer.style.display = 'none';
                    elPlayAgainBtn.style.display = 'block';
                }   else {
                        //element.style.display = 'none';
                        element.style.background = loserColor;
                        guesses --;
                        guessUpdater(guesses);
                        if (guesses <= 0) {
                            elDivPasswordContainer.style.visibility = 'hidden';
                            for (var i = 0; i < wordChildren.length; i++) {
                                wordChildren[i].firstChild.style.visibility = 'visible';
                                wordChildren[i].style.background = loserColor;
                            }
                            elGuessContainer.style.display = 'none';
                            alert('You lost.');
                            elPlayAgainBtn.style.display = 'block';

                        }
                    }
        };

    validator(this);

    }, false);


    elDivPasswordContainer.appendChild(makeDiv);
}

//CREATE DIVS TO SHOW THE LETTERS OF THE ANSWER.
function createWordDivs(string) {
    console.log(string + 'line100');

    for (var i = 0; i < string.length - 1; i++) {
        var createDiv = document.createElement('div');
        createDiv.setAttribute('class', 'password-letter');
        createDiv.setAttribute('id', 'word'+i.toString());
        createDiv.innerHTML = '<p class="pwd-letter">'+string.charAt(i)+'</p>';
        console.log(typeof string.charAt(i));
        elWordContainer.appendChild(createDiv);
    }
    //document.getElementById('word'+string.length.toString()).style.display = 'none';
}

function passwordPicker() {
    randomNum = Math.floor(Math.random() * elDivPasswordContainer.childNodes.length - 1);
    password = elDivPasswordContainer.childNodes[randomNum].innerHTML;
    return password;
}

// WINDOW LOAD EVENT w/ AJAX //
window.addEventListener("load", function() {
    //AJAX Request
        //create a new XMLHttpRequest(); and store it in a variable.
        var getTextFile = new XMLHttpRequest();
        //Tell the variable what to do when the ready state changes, reference, but do not call the callback function. (this can be an anonymous function though.)
        getTextFile.onreadystatechange = parseContents;
        //Tell the variable what to do EG: GET, then tell it where: 'URL'.
        getTextFile.open('GET', 'http://mattstates.com/apps/password-game/enable1.txt', true);
        //Tell the variable what to send to the server (if applicable).
        getTextFile.send(null);

    //AJAX callback function as referenced for the .onreadystatechange.
    function parseContents() {
        //if the XMLHttpRequest.readyState is finished...
        if (getTextFile.readyState === XMLHttpRequest.DONE) {
            //and if the server status is 200 (OK)...
            if (getTextFile.status === 200) {
                //Do this stuff...
                console.log('AJAX Success!');
                var wordText = getTextFile.responseText;

//EVENT HANDLER FOR THE DROPDOWN SELECTORS.
elDifficultySelector.addEventListener('change', function(){
    var dropdownOptionIndex = elDifficultySelector.options[elDifficultySelector.selectedIndex].value;
    //assigns the difficultyParams object to the appropriate dropdown selection.
    var difficulty = difficultyParams[parseInt(dropdownOptionIndex)];
    elDifficultySelector.style.display = 'none';
    elChooseYouDifficultyH2.style.display = 'none';
    elGuessContainer.style.display = 'block';
    guessUpdater(guesses);
    wordsByDifficulty(wordText, difficulty).forEach(function(element, index){

        createPasswordDivs(element, index)
    });

    var answer = passwordPicker();

    console.log(answer);

    createWordDivs(answer);

}, false);





//END OF THE CODE THAT RUNS FOR A SUCCESSFUL AJAX REQUEST.
                //else do this stuff...
            } else {
                alert('There was an error loading the .txt file library.');
            }
        }
    };
}, false);




//PLAY AGAIN BUTTON & FUNCTION
//TODO ADD HIDING THIS WHEN CLICKED.
elPlayAgainBtn.addEventListener('click', function(){
    elDifficultySelector.value = 111;
    elDifficultySelector.style.display = 'block';
    elChooseYouDifficultyH2.style.display = 'block';
    elDivPasswordContainer.innerHTML = '';
    guesses = 4;
    guessUpdater(guesses);
    elDivPasswordContainer.style.visibility = 'visible';
    elWordContainer.innerHTML = '';
    elWordContainer.style.background = initialColor;
    elPlayAgainBtn.style.display = 'none';
}, false);

share
Save
YonkeMuffinMan
1 point·2 years ago

Python 2.7

from random import randint, shuffle

def getWords(size):
    diction = file("enable1.txt")
    wordNum = size
    wordList = []
    for line in diction:
        if len(wordList) <= wordNum and len(line.rstrip('\n')) == size:
            if len(wordList) > 0 and wordList[len(wordList)-1][0] != line.rstrip('\n')[0] and theLetters[randint(0,(len(theLetters)-1))] == line.rstrip('\n')[0]:
                wordList.append(line.rstrip('\n'))
            elif len(wordList) == 0:
                wordList.append(line.rstrip('\n'))
    diction.close()
    return wordList

def guessing(p,guessLeft):
    while guessLeft > 0:
        posCorrect = 0
        theGuess = raw_input("Guess (" + str(guessLeft) + " left)? ")
        if theGuess == p:
            print "You win!"
            break
        for i in range(len(theGuess)):
            if theGuess[i] == p[i]:
                posCorrect += 1
        print str(posCorrect) + "/" + str(len(p)) + " correct"
        guessLeft -= 1

def playAgain():
    ans = raw_input("Would you like to play again? y or n: ")
    if ans.lower()[0] == 'y':
        setup()
    else:
        exit()

def setup():
    diff = int(raw_input("Difficulty (1-5)?"))
    if diff == 1:
        size = 6
    if diff == 2:
        size = 8
    if diff == 3:
        size = 10
    if diff == 4:
        size = 13
    if diff == 5:
        size = 15
    guessLeft = 4
    theWords = getWords(size)
    shuffle(theWords)
    password = theWords[randint(0,(len(theWords)-1))]
    for i in theWords:
        print i
    guessing(password,guessLeft)
    playAgain()

theLetters = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
setup()

share
Save
sort_of_a_username
1 point·2 years ago·edited 2 years ago

inside your setup() function why not use a dict?

something like this

size = {1:6, 2:8, 3:10, 4:13, 5:15}[diff]

would get the job done, and look better in my opinion :)

share
Save
Krirken
1 point·2 years ago

Node.js, ES5

'use strict';
function mastermind() {
  // Requires
  var fs = require('fs');
  var readline = require('readline');
  ///

  // Members
  var prompts = {
    banner: function() {
      return 'Welcome to the Mastermind Guessing Game';
    },
    correct: function() {
      return 'Correct! Secret Word was ' + chosenSecretWord;
    },
    guess: function() {
      return 'Guess? (' + guessesRemaining-- + ' left) ';
    },
    lose: function() {
      return 'You Lose! Secret Word was ' + chosenSecretWord + ', try again';
    },
    invalidDifficulty: function() {
      return 'Invalid Difficulty, try again';
    }
  }
  var FILE_NAME = './enable1.txt'; // filename of dictionary
  var dictionary = fs.readFileSync(FILE_NAME, { encoding: 'utf-8' }).split('\n');
  var SAMPLE_SIZE;  //determined by difficulty
  var WORD_LENGTH;  //determined by difficulty
  var difficulty;   // prompted
  var words;        // dictionary filtered by word length
  var randomSample; // random sampling of words array
  var guessesRemaining; // number of remaining guesses
  var chosenSecretWord; // secret word randomly chosen from randomSample
  ///

  function numCommonCharacters(word1, word2) {
    // Assume two words are equal length
    word1 = word1.toLowerCase();
    word2 = word2.toLowerCase();
    return word1.split('').reduce(function(memo, current, index) {
      if (current === word2.charAt(index))
        memo += 1;
      return memo;
    }, 0);
  }
  function nLetterWordsFilter(n, words) {
    function doFilter(words) {
      return words.filter(function(elem) {
        return elem.length === n;
      });
    }
    // If no words are provided return curried function
    if (!words) return doFilter;

    // If words return a filtered array
    return doFilter(words);
  }

  function init() {
    // Initialize the game
    SAMPLE_SIZE = 2 * difficulty + 4;
    WORD_LENGTH = 3 * difficulty;
    guessesRemaining = 4;

    // Filter dictionary by word length
    words = nLetterWordsFilter(WORD_LENGTH, dictionary);

    // Create a random sample
    randomSample = new Array(SAMPLE_SIZE).fill(0).map(function() {
      return words[Math.floor(Math.random() * words.length)];
    });

    // Choose a secret word
    chosenSecretWord = randomSample[Math.floor(Math.random() * randomSample.length)];

    // Print choices
    console.log("Choices:");
    console.log(randomSample);
  }


  // input listening beginning is the beginning of the game
  function beginInputListening() {
    var rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      terminal: true
    });

    // Print the banner if there is one
    if (prompts.banner) console.log(prompts.banner());

    rl.setPrompt('Difficulty? 1-5 ');
    rl.prompt();

    rl.on('line', function(line) {
      // Difficulty is the first thing prompted
      if (!difficulty) {
        difficulty = +line;
        if ((0 >= difficulty) || (difficulty > 5)) {
          console.log(prompts.invalidDifficulty());
          difficulty = false;
          rl.prompt();
          return;
        } else {
          // Init game and start guessing
          init();
          rl.setPrompt(prompts.guess());
          rl.prompt();
          return;
        }
      }
      // Check the Guesses
      if (chosenSecretWord === line) {
        // Correct answer
        console.log(prompts.correct());
        guessesRemaining = 0;
        rl.close();
      }
      if (guessesRemaining > 0) {
        // Still guessing
        var lettersInCommon = numCommonCharacters(chosenSecretWord, line);
        console.log(lettersInCommon + '/' + WORD_LENGTH + ' correct');
        rl.setPrompt(prompts.guess());
        rl.prompt();
      } else {
        // Game over
        console.log(prompts.lose());
        rl.close();
      }
    }).on('close', function() {
      process.exit(0);
    });
  }

  return {
    // The only function that needs to be exposed is beginInputListening
    // this function will begin the game
    play: beginInputListening
  }
}
var game = mastermind();
game.play();

share
Save
TiZ_EX1
1 point·2 years ago

Haxe. thx.core.

using Thx;
class Hacking {
    static function main () {
        var diff = getDiff();
        var count = [5, 8, 10, 12, 15][diff],
         length = [4, 7, 9, 12, 15][diff];
        var words = sys.io.File.getContent("enable1.txt").toLines()
         .filter.fn(_.length == length).sample(count);
        var target = words.sampleOne().toArray();
        for (w in words) Sys.println(w.toUpperCase());
        var matches = 0, tries = 5;
        while (tries-- > 0 && length > (matches = getMatches(target)))
            Sys.println('You got $matches/$length. $tries tries remain.');
        Sys.println(length == matches ? "Access granted." : "ACCESS DENIED.");
    }

    static function getMatches (target: Array<String>) {
        Sys.print("Make a guess: ");
        var guess = Sys.stdin().readLine().toArray(), matches = 0;
        for (i in 0 ... Std.int(Math.min(target.length, guess.length)))
            if (target[i].toUpperCase() == guess[i].toUpperCase()) matches++;
        return matches;
    }

    static function getDiff () {
        var diff = -1;
        while (diff < 0 || diff > 4) {
            Sys.print("Select difficulty, 1-5: ");
            diff = Sys.stdin().readLine().toInt() - 1;
        }
        return diff;
    }
}

Feedback, please! Thank you!

share
Save
FlammableMarshmallow
1 point·2 years ago

Python3!

#!/usr/bin/env python3
import random
import sys

DIFFICULTY = {
    1: random.choice((4, 5, 6)),
    2: random.choice((7, 8)),
    3: random.choice((9, 10, 11)),
    4: random.choice((12, 13)),
    5: random.choice((14, 15))
}


def min_max(seq):
    sorted_seq = sorted(seq)
    return sorted_seq[0], sorted_seq[-1]


def get_words(len_=None):
    with open("/usr/share/dict/words") as word_file:
        yield from (i.strip()
                    for i in word_file
                    if len_ is None or len(i.strip()) == len_)


def get_difficulty():
    prompt = "Enter difficulty ({}-{}): ".format(*min_max(DIFFICULTY))
    while True:
        try:
            difficulty = int(input(prompt))
        except ValueError:
            print("Enter only numbers 1-5", file=sys.stderr)
        else:
            if not (0 < difficulty < 6):
                print("Enter only numbers 1-5", file=sys.stderr)
            else:
                return difficulty


def main():
    diff = get_difficulty()
    lens = DIFFICULTY[diff]
    possibles = random.sample(list(get_words(lens)), random.randint(5, 10))
    chosen = random.choice(possibles)
    print("\n".join(possibles))
    guesses = 0
    while guesses < 4:
        inp = input("Guess ({} left)? ".format(4 - guesses))
        counter = 0
        for i, j in zip(inp, chosen):
            if i == j:
                counter += 1
        print("{}/{} correct".format(counter, lens))
        if counter == lens:
            print("You win!")
            exit()
        guesses += 1
    exit("You lose!")


if __name__ == "__main__":
    main()

share
Save
Flaminx
1 point·2 years ago

I had a lot of fun with this one making it a bit more fallout themed, I've
tested it and believe it to be bug free. Now back to waiting for fallout 4....
[C++]

#include <string>
#include <iostream>
#include <fstream>
#include <vector>
#include <time.h>
using namespace std;
int Random(int min, int max)
{
        return rand() % (max-min) + min;
}
class hackingGame
{
private:
        vector <string> matchingWords;
        vector <string> possibleAnswers;
        string Answer;
public:
        void fillVector(int difficulty, int minwords, int diffIncrease, string fileName);
        bool userGuessing(string uGuess);
        void Reset();
};
void hackingGame::fillVector(int difficulty, int minwords, int diffIncrease, string fileName)
{
        string line;
        int numOfWords = minwords;
        int wordLength;
        switch(difficulty)
        {
        case 1: wordLength = Random(4, 6);
                break;
        case 2: wordLength = Random(6, 9);
                break;
        case 3: wordLength = Random(9, 11);
                break;
        case 4: wordLength = Random(11, 13);
                break;
        case 5: wordLength = Random(13, 15);
                break;
    default: wordLength = Random(4, 6);
                break;
        }
        cout <<  "----VAULT-TEC-SYSTEMS---------V1.45---------" << endl;
        int matches = 0;

        for (int i = 1; i != difficulty; i++)
        {
                numOfWords += diffIncrease;
        }
        ifstream readIntoVector(fileName);
        if (readIntoVector.is_open())
        {
                while (getline(readIntoVector, line))
                {
                        if (wordLength == line.length())
                        {
                                matchingWords.push_back(line);
                                matches++;
                        }
                }
        }
        else cout << "Cannot find word file" << endl;
        readIntoVector.close();
        for (int k = 0; k != numOfWords; k++)
        {
                possibleAnswers.push_back(matchingWords[Random(0, matches)]);
                cout << possibleAnswers[k] << endl;
        }
        Answer = possibleAnswers[Random(0, numOfWords)];
        cout << "-------------------------------" << endl;
}
bool hackingGame::userGuessing(string uGuess)
{
        if (uGuess.size() != possibleAnswers[0].size())
        {
                cout << "Thats...thats not even the right length, are you even trying?" << endl << endl;
                return false;
        }
        int charCorrect = 0;
        for (int k = 0; k != uGuess.size(); k++)
        {
                if (uGuess[k] == Answer[k])
                {
                        charCorrect++;
                }
        }
        if (charCorrect == uGuess.size())
        {
                return true;
        }
        else
        {
                cout << charCorrect << " Of " << uGuess.size() << " Correct" << endl;
                return false;
        }
}
void hackingGame::Reset()
{
        matchingWords.clear();
        possibleAnswers.clear();
}
int main()
{
        srand(time(0));
        //This block of variables allows the game to be modified and made harder/easier
        int maxLives = 4;
        int maxDif = 5;
        int minDif = 1;
        int minimumWords = 5;
        int difficultyIncrease = 2;
        hackingGame* Fallouthack = new hackingGame;
        int diffSelect = 0;
        bool gameisRunning = true;
        string userGuess;
        string wordFile = "enable1.txt";
        while (gameisRunning)
        {
                bool gameWon = false;
                int currentLives = maxLives;
                while (diffSelect < minDif || diffSelect > maxDif)
                {
                        cout << "Please enter difficulty (1-5)" << endl;
                        cin >> diffSelect;
                }
                Fallouthack->fillVector(diffSelect, minimumWords, difficultyIncrease, wordFile);
                while (currentLives > 0 && !gameWon)
                {
                        cout << endl << currentLives << " out of " << maxLives << " attempts remaining before lockout" << endl << "Please enter password: ";
                        cin >> userGuess;
                        gameWon = Fallouthack->userGuessing(userGuess);
                        currentLives--;
                }
                if (currentLives == 0) cout << "AUTHENTICATION ERROR------SYSTEM LOCKED" << endl;
                else
                {
                        cout << "Logon: Fallout4HPYE" << endl << "Password: ";
                        for (int k = 0; k != userGuess.size(); k++) cout << "*";
                        cout << endl << "Login Successful" << endl;
                }
                while (userGuess != "Y" && userGuess != "N")
                {
                        cout << "Try again? (Y/N)" << endl;
                        cin >> userGuess;
                }
                if (userGuess == "N")
                {
                        gameisRunning = false;
                        cout << "Shutting Down..." << endl;
                }
                Fallouthack->Reset();
                userGuess.clear();
                diffSelect = 0;
        }
        delete(Fallouthack);
}

share
Save
juanchi35
1 point·2 years ago·edited 2 years ago

C++11, I'm open to feedback (:

#include <fstream>
#include <iostream>
#include <vector>
#include <map>
#include <string>
#include <random>

const int numOfWords = 10;

enum difficulty {
        VERY_EASY, EASY, AVERAGE, HARD, VERY_HARD
};

std::mt19937& getRandomEngine() {
        static std::mt19937 randomEngine(std::random_device{}());
        return randomEngine;
}

class HackingGame {
        difficulty mDifficulty;
        std::vector<std::string> mWords;
        std::string mWord;
        std::map<difficulty, std::pair<unsigned, unsigned>> mMaxLengths;
        unsigned mMaxLength, mTries;

        int getRandomNumber(int min, int max) const {
                std::uniform_int_distribution<> random(min, max);
                return random(getRandomEngine());
        }

        void init() {
                mMaxLengths[VERY_EASY] = std::make_pair(4, 5);
                mMaxLengths[EASY] = std::make_pair(5, 6);
                mMaxLengths[AVERAGE] = std::make_pair(6, 7);
                mMaxLengths[HARD] = std::make_pair(7, 8);
                mMaxLengths[VERY_HARD] = std::make_pair(9, 10);

                const int rand = getRandomNumber(1, 2);

                mMaxLength = rand == 1 ?
                        mMaxLengths[mDifficulty].first : mMaxLengths[mDifficulty].second;

                std::fstream file("enable1.txt");
                std::string word;

                std::vector<std::string> wordsWithEqualSize;

                while (std::getline(file, word)) {
                        if (word.length() == mMaxLength)
                                wordsWithEqualSize.push_back(word);
                }

                for (int i = 0; i < numOfWords; ++i) {
                        int randomNumber = getRandomNumber(1, wordsWithEqualSize.size()-1);
                        mWords.push_back(wordsWithEqualSize[randomNumber]);
                }

                mWord = mWords[getRandomNumber(0, mWords.size()-1)];
        }

        void outputWords() const {
                for (auto&& word : mWords)
                        std::cout << word << "\n";
        }
public:
        HackingGame(difficulty _difficulty) : mDifficulty(_difficulty), mTries(5) { init(); }

        void run() const{
                outputWords();
                bool won = false;

                for (int i = mTries; i != 0; i--) {
                        std::string guess;
                        std::cout << "Guess (" << i << " left): ";
                        std::cin >> guess;

                        unsigned correct = 0;

                        if (guess == mWord) {
                                won = true;
                                break;
                        }

                        for (int i = 0, size = guess.size(); i < size; ++i)
                                if (guess[i] == mWord[i]) correct++;

                        std::cout << "You got " << correct << " correct\n";
                }

                if (won) std::cout << "Good job! the word was: " << mWord;
                else std::cout << "Nice try! the word was: " << mWord;
        }
};

difficulty askForDifficulty() {
        int _difficulty;
        std::cout << "What difficulty do you choose? (1-5)\n";
        std::cin >> _difficulty;
        switch (_difficulty) {
        case 1: return difficulty::VERY_EASY;
        case 2: return difficulty::EASY;
        case 3: return difficulty::AVERAGE;
        case 4: return difficulty::HARD;
        default: return difficulty::VERY_HARD;
        }
}

int main() {
        try {
                HackingGame hg(askForDifficulty());
                hg.run();
        }
        catch (std::exception& e) {
                std::cerr << e.what();
        }
}

share
Save
leolas95
1 point·2 years ago·edited 2 years ago

This is my [ugly] answer in C. This is the same that I did for the #163
intermediate challenge, which I think is the same as this. Any suggestion would
be appreciated.

#include <string.h>
    #include <ctype.h>
#include <stdlib.h>
#include <time.h>

#define MAXEASY 5
#define LENGTHEASY 8

#define MAXMEDIUM 9
#define LENGTHMEDIUM 10

#define MAXHARD 15
#define LENGTHHARD 16

char easy[MAXEASY][LENGTHEASY] =
{
        {"AARRGHH"}, {"ABASIAS"}, {"ABALONE"}, {"ABANDON"}, {"ABASERS"}
};
char medium[MAXMEDIUM][LENGTHMEDIUM] =
{
        {"COMPUTERS"}, {"ANDROMEDA"} , {"DOCUMENTS"}, {"ABAMPERES"},
        {"ABANDONED"}, {"BACKLANDS"}, {"ZOOTIMIES"}, {"ZOOSPORES"},
        {"WRONGDOER"}
};
char hard[MAXHARD][LENGTHHARD] =
{
        {"WORRISOMENESSES"}, {"WORTHLESSNESSES"}, {"VASCULARIZATION"}, {"WATERLESSNESSES"},
        {"UTILITARIANISMS"}, {"XERORADIOGRAPHY"}, {"POSTVACCINATION"}, {"SUPERGOVERNMENT"},
        {"SUPERFLUIDITIES"}, {"SEGREGATIONISTS"}, {"RENATIONALIZING"}, {"RADIOTELEPHONES"},
        {"PROTOZOOLOGISTS"}, {"PLAUSIBLENESSES"}, {"OUTMANIPULATING"}
};

/* Returns the number of hits if pattern is in source. 0 if not */
int grep(char pattern[], char source[]);
void logic(int len, char ans[]);

int main(void)
{
        int op, randpos, i;


        printf("Select the difficulty:\n");
        printf("1) Easy\n");
        printf("2) Medium\n");
        printf("3) Hard\n");
        scanf("%d", &op);
        putchar('\n');

        /* I prefer to use a bigger switch here than another function somewhere else */
        switch (op) {
        case 1:
                /* Show the options */
                for (i = 0; i < MAXEASY; i++) {
                        printf("%s\n\n", easy[i]);
                }
                putchar('\n');
                /* The variable to store the correct answer
                 * @ anse = easy answer
                 * @ ansm = medium answer
                 * @ ansh = hard answer
                 */
                char anse[LENGTHEASY];
                srand(time(NULL));
                /* Calculates a random position on the array of strings to select the answer */
                randpos = (rand() % MAXEASY);
                /* Copy that string into the answer variable */
                strncpy(anse, easy[randpos], LENGTHEASY);
                /* Passes the answer and its length to logic() */
                logic(LENGTHEASY, anse);
                break;

        case 2:
                for (i = 0; i < MAXMEDIUM; i++) {
                        printf("%s\n\n", medium[i]);
                }
                putchar('\n');
                char ansm[LENGTHMEDIUM];
                srand(time(NULL));
                randpos = (rand() % MAXMEDIUM);
                strncpy(ansm, medium[randpos], LENGTHMEDIUM);
                logic(LENGTHMEDIUM, ansm);
                break;

        case 3:
                for (i = 0; i < MAXHARD; i++) {
                        printf("%s\n\n", hard[i]);
                }
                putchar('\n');
                char ansh[LENGTHHARD];
                srand(time(NULL));
                randpos = (rand() % MAXHARD);
                strncpy(ansh, hard[randpos], LENGTHHARD);
                logic(LENGTHHARD, ansh);
                break;
        }
        return 0;
}

void logic(int len, char ans[])
{
        /* Stores the user's guess */
        char guess[len];
        /* A counter for the guesses */
        int guesses = 4;
        int i;

        while (guesses > 0) {
                guess[0] = '\0';
                printf("Guess (%d left) ? > ", guesses);
                scanf("%s", &guess);
                i = 0;
                /* Dealing with lower case guesses */
                while (guess[i]) {
                        guess[i] = toupper(guess[i]);
                        i++;
                }

                if ((strncmp(ans, guess, len)) == 0) {
                        printf("%d/%d correct\n", strnlen(guess, len), strnlen(ans, len));
                        printf("You win!\n");
                        printf("ACCES GRANTED\n");
                        break;
                } else {
                        printf("%d/%d correct\n", grep(guess, ans), strnlen(ans, len));
                }
                guesses--;
        }

        if (!(guesses)) {
                printf("TOO MUCH TRIALS. ACCESS DENIED\n");
        }
}

int grep (char pattern[], char source[])
{
        int i, j, k;
        int corrects = 0;

        for (i = 0; source[i] != '\0'; i++) {
                for (j = i, k = 0; pattern[k] != '\0' && source[j] == pattern[k]; j++, k++) {
                        corrects++;
                }
        }
        return corrects;
}

share
Save
thevjm
1 point·2 years ago

Here's another Python solution..

import random

with open('enable1.txt', 'r') as f:
    enable1 = f.read().split()

def check_answer(guess,answer): # Compares two words and returns number of matching characters in same position
    correct_letters = 0
    for i, n in enumerate(guess):
        if n == list(answer)[i]:
            correct_letters += 1
    return correct_letters

def get_words(length): # Returns list of 8 random uppercase words of length given
    word_list = [i.upper() for i in enable1 if len(i) == length]
    game_words = random.sample(word_list, 8)
    return game_words

def fallout():
    diff = int(input('Choose a difficulty (1-5): '))
    levels = {1:5,2:8,3:10,4:12,5:14}
    game_words = get_words(levels[diff])
    answer = random.choice(game_words)
    guesses = 4
    for i in game_words:
        print(i)

    while guesses >= 0:
        if guesses == 0:
            print("Game over. You lose")
            break
        user_guess = input('Enter password: ').upper()
        if user_guess == answer:
            print("{0}/{0} correct. You win!".format(len(answer)))
            break
        else:
            correct_letters = check_answer(user_guess,answer)
            print("{}/{} correct. Try again.".format(correct_letters,len(answer)))
            guesses -= 1

fallout()

share
Save
fourgbram
1 point·2 years ago

Python 3.4

import random

dict_all_words = {}
list_difficulty = [x for x in range(1,6)]
dict_word_length = {1: 5, 2: 8, 3: 10, 4: 12, 5: 15 }

with open('words.txt', 'rt') as file_obj:
    foo = file_obj.read().split()
    for x in foo:
        dict_all_words[len(x)] = dict_all_words.setdefault(len(x),[])
        dict_all_words[len(x)].append(x.upper())


def get_random_words(difficulty):
    difficult_words_list = dict_all_words[dict_word_length[difficulty]]
    list_final_words = []
    for x in range(dict_word_length[difficulty]):
        list_final_words.append(random.choice(difficult_words_list))

    return list_final_words


def get_difficulty_input():
    user_difficulty = int(input("Difficulty (1-5)? "))
    if user_difficulty not in list_difficulty:
        raise ValueError("Must be between 1-5")
    else:
        return user_difficulty


def get_user_guess(life_left):
    user_guess = input("Guess ({} left)?\t".format(life_left))
    return user_guess


def check_guess(guess):
    chars_correct = 0
    for x in guess:
        if x in the_password:
            chars_correct += 1

    return chars_correct


difficulty_user = get_difficulty_input()
list_words_to_show = get_random_words(difficulty_user)
the_password = random.choice(list_words_to_show).lower()
for x in list_words_to_show:
    print(x)


count = 4
while count > 0:
    user_guess = get_user_guess(count)
    correct = check_guess(user_guess)
    if correct == len(the_password):
        print("You win")
        break
    else:
        print("{}/{} correct".format(correct, len(the_password)))
    count -= 1

print("The correct word was {}".format(the_password))

share
Save
PharmyOf1
1 point·2 years ago

Python Feedback appreciated...

#I <3 Fallout
# Num 238 - Intermediate

from random import shuffle
from random import choice

wordList = open(path+fn,'r').read().splitlines()

dif = {1:[4,5,6],2:[6,7,8],3:[8,9,10],4:[10,11,12],5:[13,14,15]}
difficulty = (choice(dif[input(('Enter difficulty 1-5: '))]))

def getWords(wordList,wordDif):
    genWords = []
    for x in wordList:
        if len(x) == wordDif:
            genWords.append(x.upper())
    shuffle(genWords)
    return genWords[0:wordDif]

def correctLet(guess,correctAnswer):
    pos = 0
    x = zip(guess,correctAnswer)
    for y in range(len(correctAnswer)):
        if x[y][0]==x[y][1]:
            pos = pos+1
    return (pos)

def startGuesses(wordList):
    gameList = (getWords(wordList,difficulty))
    for x in gameList:
        print (x)
    correctAnswer = choice(gameList)
    for x in range(4,0,-1):
        guess = raw_input('Guess (' + str(x) + ' left):' )
        if guess not in gameList:
            print ('Guess not in word list')
        elif guess == correctAnswer:
            print ('You win!')
            return
        else:
            print (('%s/%s') % (correctLet(guess,correctAnswer),len(correctAnswer)))
    print ('!Fallout Hack Failure: System Locked out!')

startGuesses(wordList)

share
Save
netbioserror
1 point·2 years ago

D

import std.stdio,
    std.file,
    std.random,
    std.range,
    std.algorithm,
    std.string,
    std.uni,
    std.typecons,
    std.conv;

alias DifficultyInfo = Tuple!(uint, "wordLength", uint, "numWords");

DifficultyInfo genDifficulty(uint level) {
    DifficultyInfo di;
    di.wordLength = 2 * (level + 1) + dice(0.333, 0.333, 0.333);
    di.numWords = 2 * (level + 1) + 1 + dice(0.333, 0.333, 0.333);
    return di;
}

string[] wordsOfLength(DifficultyInfo di) {
    string[] words = (cast(string)read("enable1.txt"))
        .split('\n')
        .map!(w => w.strip())
        .filter!(w => w.length == di.wordLength)
        .array;
    words.randomShuffle();
    return words.take(di.numWords);
}

uint matchingChars(string target, string comparee) {
    uint ncorrect = 0;
    foreach (int i, char c; comparee) {
        if (target[i] == c) {
            ncorrect++;
        }
    }
    return ncorrect;
}

void main() {
    writeln("Difficulty (1-5)?");
    uint level = to!uint(readln().strip());
    if (level < 1 || level > 5) {
        writeln("No such difficulty.");
        return;
    }

    DifficultyInfo di = genDifficulty(level);
    string guess;
    string[] words = wordsOfLength(di);
    string targetWord = words[uniform(0, di.numWords)];

    words.map!toUpper()
        .each!writeln();

    for (int g = 0; g < 4; g++) {
        write("Guess (", 4 - g, " left)? ");
        guess = readln().strip().toLower;

        if (words.canFind(guess)) {
            uint ncorrect = matchingChars(targetWord, guess);
            writeln(ncorrect, "/", targetWord.length, " correct");

            if (ncorrect == targetWord.length) {
                writeln("You win!");
                return;
            }
        } else {
            writeln("Not in list.");
            g--;
        }
    }
    writeln("You lose :(");
}

share
Save
crossroads1112
1 point·2 years ago·edited 2 years ago

Rust

This program does a few additional things than the spec covers.

 1. It does not allow the user to input any arbitrary string, only one from the
    word list. This is to prevent cheating.

 2. It does not non-alphabetic characters (no apostrophes as this would make
    the solution easier to guess).

 3. It provides a simple menu to select the difficulty.

EDIT: Made use of rand::sample and include_str!

use std::io::{self, Write};

extern crate rand;
use rand::distributions::{Range, IndependentSample};

use Level::*;
enum Level {
    Easy,
    Medium,
    Hard,
    Extreme,
}


const FILE: &'static str = include_str!("/usr/share/dict/words");
const GUESSES: usize = 4;

fn main() {
    let words = match menu() {
        Easy => get_words(5, 5),
        Medium => get_words(7, 7),
        Hard => get_words(10, 10),
        Extreme => get_words(12, 12),
    };

    for word in &words {
        println!("{}", word);
    }

    let mut current_guess = GUESSES;
    let password_ind: usize = Range::new(0, words.len()).ind_sample(&mut rand::thread_rng());

    loop {
        print!("\nGuess ({} left): ", current_guess);
        flush();

        let buf = get_input();
        let guess = buf.trim().to_string().to_uppercase();

        if guess == words[password_ind] {
            println!("You win!!");
            break;
        } else {
            let matches = match analyze_words(&words, password_ind, &guess) {
                Ok(num) => num,
                Err(s) => {println!("\"{}\" is not a valid word. Try again", s); continue; }
            };

            println!("{}/{} correct", matches, guess.len());
            current_guess = current_guess - 1;

            if current_guess == 0 {
                println!("You lose!!");
                break;
            }
        }
    }

}

fn menu() -> Level {
   println!("Please select a level: \n\n");
   println!("    1: Easy");
   println!("    2: Medium");
   println!("    3: Hard");
   println!("    4: Extreme");
   print!("\n    Your choice: ");
   flush();

   let ret;
   loop {
       let buf = get_input();
       ret = match buf.trim() {
           "1" => Easy,
           "2" => Medium,
           "3" => Hard,
           "4" => Extreme,
           _ => {
               println!("\nERROR: Invalid input \"{}\"", buf.trim());
               print!("Try again: ");
               flush();
               continue;
           }
       };
       break;
   }
   ret
}

fn analyze_words<'a>(vec: &Vec<String>, ind: usize, guess: &'a String) -> Result<usize, &'a String> {
    let mut pos = 0;
    if !vec.contains(&guess) {
        Err(guess)
    } else {
        for chars in guess.chars().zip(vec[ind].chars()) {
            if chars.0 == chars.1 {
                pos = pos + 1;
            }
        }
        Ok(pos)
    }
}

// Wrapper functions

#[inline]
fn get_words(len: usize, numwords: usize) -> Vec<String> {
    rand::sample(&mut rand::thread_rng(), FILE.lines()
                 .filter(|word| word.len() == len)
                 .filter(|word| {
                     for ch in word.chars() {
                         if !ch.is_alphabetic() {
                             return false;
                         }
                     } true
                 }).map(|word| word.to_uppercase()), numwords)
}

#[inline]
fn get_input() -> String {
    let mut buf = String::new();
    io::stdin().read_line(&mut buf).ok().expect("Could not read input");
    buf
}

#[inline]
fn flush() {
    io::stdout().flush().ok().expect("Could not flush stdout");
}

share
Save
TheSlowestCheetah
1 point·2 years ago

Python 2.7

First time doing an intermediate challenge! And now that I finished and looked
at other python submissions, there are definitely better ways to do this than a
bunch of if statements to set word length and number of words.

import random

difficulty = input('Select difficulty (1-5) ')

def set_length():
  if difficulty == 1:
    return 4
  elif difficulty == 2:
    return random.randrange(5,7,1)
  elif difficulty == 3:
    return random.randrange(8,10,1)
  elif difficulty == 4:
    return random.randrange(11,13,1)
  elif difficulty == 5:
    return random.randrange(14,15,1)
  else:
    print "You suck at following directions, so here's a random length."
    return random.randrange(4,15,1)

lengthOfWord = set_length()
numWords = set_length()

def get_words(lengthOfWord):
  newList = []
  playlist = []
  dictionaryWords = open('enable1.txt').read().splitlines()
  for line in dictionaryWords:
    if len(line) == lengthOfWord:
      newList.append(line)
  for x in range(0, numWords):
    playlist.append(random.choice(newList))
  return playlist

def play_game():
  guesses = 4
  howManyCorrect = 0
  playlist = get_words(lengthOfWord)
  password = random.choice(playlist)
  print playlist

  while howManyCorrect < lengthOfWord and guesses > 0:
    guess = raw_input("Guess (%s left)? " % guesses)
    guesses = guesses - 1
    for x in range(0, lengthOfWord):
      if password[x] == guess[x]:
        howManyCorrect = howManyCorrect + 1
    if howManyCorrect >= lengthOfWord:
      print 'You win!'
    else:
      print '%s/%s correct' % (howManyCorrect,lengthOfWord)
      howManyCorrect = 0 # need to reset the number of correct positions

play_game()

share
Save
shadystone
1 point·2 years ago

A Clojure solution, with an effort to give it the fallout terminal
look-and-feel.

(ns fallout-hacking.core
  (:require [clojure.string :as s])
  (:gen-class))

(def rchrs (map char (concat (range 58 64) (range 123 125) (range 32 47))))
(def dict (s/split (slurp "enable1.txt") #"\s"))
(def max-cols 65)
(def max-rows 30)
(def gridn (* max-cols max-rows) )
(def RANDS (int (+ (rand 0xFFF) 0xFFF)))

(defn get-random-word [len]
  (let [word (s/upper-case (nth dict (rand (count dict))))]
    (if (= (count word) len)
      word
      (get-random-word len))))

(defn irand [m]
  (int (rand m)))

(defn hacker-noise []
  (str (nth rchrs (irand (count rchrs)))))

(defn cmp-str [f s1 s2]
  (if (f (count s1) (count s2))
    s1
    s2))

(defn letters-correct [g answer]
  (let [bigger (cmp-str > g answer)
        smaller (cmp-str <= g answer)]
  (count
    (filter true?
            (keep-indexed #(= %2 (nth bigger %1)) smaller)))))

(defn guess [gcount answer]
  (println gcount "ATTEMPTS LEFT")
  (print ">")
  (flush)
  (let [guess (s/upper-case (read-line))]
    (println (str (letters-correct guess answer) "/" (count answer)) "correct")
    (if (= guess answer)
      true
      false)))

(defn next-term-line [pos]
  (print (str " 0x" (Integer/toHexString (+ RANDS pos))) " "))

(defn make-board-list
  ([spots words] (make-board-list spots words 0 '()))
  ([spots words p lst]
  (if (= p (inc gridn))
    lst
    (let [spot (first spots)
          word (first words)]
      (if (= p spot)
        (make-board-list
          (rest spots)
          (rest words)
          (+ p (count word))
          (concat lst word))
      (make-board-list
        spots
        words
        (inc p)
        (concat lst (hacker-noise))))))))

(defn display-board [boardlist]
  (loop [lst boardlist p 0]
    (when (not (empty? lst))
      (print (first lst))
      (when (and
              (= (mod p max-cols) 0)
              (not (empty? (rest lst))))
        (println)
        (next-term-line p))
      (recur (rest lst) (inc p))))
  (println)
  (println)
  (flush))

(defn overlap? [lst1 lst2]
  (not (every? nil? (map #(some #{%1} lst1) lst2))))

(defn get-random-spots
  ([wordlen wordcount] (get-random-spots wordlen wordcount '() '()))
  ([wlen wc spots heads]
  (if (<= (count heads) wc)
    (let [spot (irand (- gridn wlen))
          maybe-spots (range spot (+ spot wlen))]
      (if (overlap? maybe-spots spots)
        (get-random-spots wlen wc spots heads)
        (get-random-spots wlen wc (concat spots maybe-spots) (conj heads spot))))
    heads)))

(defn -main [& args]
  (print "Difficulty: ")
  (flush)
  (let [difficulty-mod (try (Integer/parseInt (read-line)) (catch Exception e 1))
        wordlen (+ 4 difficulty-mod)
        wordcount (+ 6 difficulty-mod)
        words (repeatedly wordcount #(get-random-word wordlen))
        answer (nth words (rand (count words)))]

    ;(println "words:" words)
    ;(println "answer:" answer)
    (let [spots (sort (get-random-spots wordlen wordcount))
          boardlist (make-board-list spots words)]
      ;(println spots)
      (display-board boardlist))

    (if (or
          (guess 4 answer)
          (guess 3 answer)
          (guess 2 answer)
          (guess 1 answer))
      (println "Access Granted")
      (println "Access Denied")))

  (print "Play again? ")
  (flush)
  (when (= (try
           (s/lower-case (first (read-line)))
           (catch Exception e "no"))
        "y")
    (-main args)))

Output:

Difficulty: 2

 0x1a3d  REZES!++"!#$+-):${,'();'($#?(#:-%$BUSING(*%(&')&,+(,{#:>'*'+*=',?
 0x1a7e  '<";-,(=#:+;"=!<{:()|$=%=;??!#?.<='!%,-&,,.*-,>'=!-.!<&:>>:*"&##,
 0x1abf  #.:-%:|.).#&#!>" &>.'-$::{;:$)<'-,&$&*-:, !%..%'!';(*">)*!-+*## (
 0x1b00  !!%#=;-)+>??(%!.)(+!!{?;"- ;-&,&"{|(??=$)(&),;'.);;("|*)=-""'>&|{
 0x1b41  ?&+-'%);#:';|;>$|'&;{(%#.$:(<$"&?-:">;$"=?().$"*+{=$-{, |((";#>>)
 0x1b82  |>!<%)'--.|#;???{>*'({(-' ;,"*$$-);&$(:=& +*,&=$=#?%-;&:JOWLED=-{
 0x1bc3  %"-?!%)%$>)$:?(!=+|),%;' *#,:| ?.##,#&<.;$!){&*' +<$|-#'<!#)%+<%"
 0x1c04  (".(>'.(|*|<';&<,{=(:-|*.&+.%{,:-?! {$;- .",!;$);'+ =,+ $="* =?"|
 0x1c45  <)=+({#-*+%$#!:,*{= %*,<%;)<#|:":%|=<&!):->.#{{-,!*:$#;|{.*<% < !
 0x1c86  (<!!=:-#.#:,=;(.&#{>{.*{"%#<#!{% !),>?=,,;>>,"){=$";),{&).{'(:<=:
 0x1cc7  );&' !{:$<>&=,'+);,$'&)+,>>!:$)+",%<(&? ;,!='-+,{ =*>!;.&>.(|>::;
 0x1d08  "+>*,?(:;$)$#-|(=.(,!,);-!,'=+*.:(|% =#>:.{{:"= ':!.%*!?"'+-(*!#(
 0x1d49  &+? ,%(?:{- {<(:&.$>(="$<>#?;"-=.,+%'?-:('$:>'$"&)- +.<+<{?#<{;+=
 0x1d8a  ?%%?)*"(!{||>&",;%$&)|#;(";;;+{.&,(|+<&($ |.{>|!-;$%  +-*>< ${) >
 0x1dcb  |:$%&;"!({-$%)#=.&;<'(&'%|=%%??.=' &( . |<&"-{ (+:+(+#+>.=$&+"%{&
 0x1e0c  ?"|->-|#!,$?+.{"!,.<-{&&?(" =,!=,>&;#$,%!%+';(=;:&|.))DREGGY.>{"{
 0x1e4d  ,:*$<-#(!+?&, ;%?|=>")";.+.?<**:$ -=!$+?{?=$(><<#|={%!|{+$?=##=-#
 0x1e8e  ==>+:%().{,.{..$*(+=&$(->%CANARD-=) |#'(:{(!-&,#=&%+$$&>($%>;*-:)
 0x1ecf  )?|'--?<?-{<()> );>!;-|>={|#<+?%".'+)&|(+"|)>;(%%;:%.), ,+*?(?|#(
 0x1f10  #)(|>(),(?>'*'(."%%%&{)'|:,.>+.>!+.' ,.:;+=+)'".#<)))*;&#?># >$<:
 0x1f51  &<)&"$%?(#,;!&+{-;)=(|>.;.;;{')!;)"<>'?>!#:&$(>!::)>*>$+,%"'=: $<
 0x1f92  |:,<'<>)>>?$${&?(< =$"=,;=;='.*=&-<-.|.>,-,;!)=&$"{> <( ?(#{,))#;
 0x1fd3  %+$)?!+<-,;?$*<$&+-'!$.|-%*-(:.,(+<&'>|'=+:>.,<#.- <!= &%,-{=%-*$
 0x2014  (;"%.><-">"?(==-."><; #=<::-{&%*{#+,# ='(%=..##-;-#>-+'=<+!*"$ !=
 0x2055  .>$|<* #('{,"$>>)"$&?$?<{-'+=,)*=**"*?*:+?'.)| ( *#&{>>(,?%=.,=":
 0x2096  &<#"|&-#%'(:,*<){'&.>!%?&(;):"&"#!*?=;$<="+&)'<?>+%$+ ";+%{+:.''%
 0x20d7  ->=, ;,;$$.*$'+)>+.)$,;('!=*-*:=(KILLED%;.<%{,{='-!,){,!(#)+|"=>.
 0x2118  ;TATERS!-#"<;{!=*< .+>! |=*$*'(<;,;-.>?#!(:'?("$?!!&:+?{|;,#+;<::
 0x2159  ',, -{-|*;<',{(*#{+!&)><-*)*>{,,{%!|=?"'><.*:":|.{=',*= ANGELS*'&
 0x219a  ..??.'>?|#'>{*=)*<,#%{!."'$=->|!<)|<="(#*. >?|'?;(+,&| *>){&+>*?#

4 ATTEMPTS LEFT
>REZES
0/6 correct
3 ATTEMPTS LEFT
>KILLED
0/6 correct
2 ATTEMPTS LEFT
>TATERS
0/6 correct
1 ATTEMPTS LEFT
>DREGGY
6/6 correct
Access Granted
Play again? n

share
Save
darklamouette
1 point·2 years ago

Python 3.4 # -- coding: utf-8 --

import random

def pick_words(nWord, lWord):
    listWord, pick = [], []
    with open('enable1.txt', 'r') as words:
        for word in words:
            if len(word) == lWord+1:
                listWord.append(word)
        pick = random.sample(range(1, len(listWord)), nWord)
        return [listWord[k][:-1] for k in pick]


if __name__ == '__main__':
    nTry, nTry_max = 1, 4
    guessList = pick_words(8,8)
    winWord = guessList[random.randrange(1,8)]
    print(guessList)
    while nTry <= nTry_max:
        nbOK = 0
        for i, letter in enumerate(input('Try n.' + str(nTry) + ': ').lower()):
            if letter == winWord[i]:
                nbOK += 1
        if nbOK == 8:
            print('You won !')
            nTry = nTry_max+1
        else:
            print(str(nbOK) + '/8 correct \n')
        nTry += 1

share
Save
poole141
1 point·2 years ago

python, this was a lot of fun! cool prompt.

import random
import math
WORD_FILE = r'enable1.txt'

VERY_EASY = 1
EASY = 2
AVERAGE = 3
HARD = 4
VERY_HARD = 5
GUESSES = 4

DIFFICULTY_NUMBER_OF_WORDS_LETTERS = { VERY_EASY : (5, 4),
                                       EASY : (7,7),
                                       AVERAGE : (10, 10),
                                       HARD : (13, 13),
                                       VERY_HARD : (15, 15)}

DIFFICULTY_GAME_STRATEGIES = { VERY_EASY : ["NORMAL", "DUPLICATES_ALLOWED"],
                               EASY : ["NORMAL"],
                               AVERAGE : ["NORMAL", "LOW_MATCHING"],
                               HARD : ["NORMAL", "LOW_MATCHING", "NO_MATCHING"],
                               VERY_HARD : ["NORMAL", "LOW_MATCHING", "NO_MATCHING", "NO_WINNER", "MISSING_LETTERS"]}

word_length_options = {}

def complete_strategy(strategy, words_count, length_of_words):
    if strategy == "NORMAL" or strategy == "NO_WINNER":
      return make_word_choices_basic(words_count, length_of_words, "NORMAL")
    elif strategy == "DUPLICATES_ALLOWED":
      return make_word_choices_basic(words_count, length_of_words, "DUPLICATES_ALLOWED")
    elif strategy == "LOW_MATCHING":
      return make_word_choices_hard(words_count, length_of_words, "LOW_MATCHING")
    else:
      return make_word_choices_hard(words_count, length_of_words, "NO_MATCHING")

def generate_list_of_choices(length_of_words):
    if length_of_words in word_length_options.keys():
        return word_length_options[length_of_words]
    else:
        words_file = open(WORD_FILE, 'r')
        words_count = 0
        word_options = {}
        for line in words_file:
            word = line.strip()
            if len(word) == length_of_words:
                word_options.update({words_count:word})
                words_count += 1
        word_length_options.update({length_of_words:word_options})
        return word_options

def make_word_choices_basic(num_of_words, length_of_words, strategy = "NORMAL"):
    word_list = generate_list_of_choices(length_of_words)
    random_nums = []
    x = 0
    while x < num_of_words:
        next_num = random.randrange(0, len(word_list) - 1)
        if next_num not in random_nums or strategy == "DUPLICATES_ALLOWED":
            random_nums.append(next_num)
            x += 1

    words = [word_list[x] for x in random_nums]
    return words

def make_word_choices_hard(num_of_words, length_of_words, strategy):
    length_of_words -= 2
    word_list = generate_list_of_choices(length_of_words)
    max_matching = int(math.floor(length_of_words/3))

    if strategy == "NO_MATCHING":
        max_matching = 0
        num_of_words = int(math.floor(num_of_words/3))

    matching_positions = 0
    random_nums = []
    letter_index_dictionaries = {}
    words = []
    rejected_nums = []

    x = 0
    while x < num_of_words:
        next_num = random.randrange(0, len(word_list) - 1)
        if next_num in random_nums or next_num in rejected_nums:
            continue
        next_word = word_list[next_num]
        next_word_matching_positions = 0
        next_word_dictionary = make_word_letter_dictionary(next_word)
        i = 0
        while i < len(next_word):
            letter = next_word[i]
            if letter in letter_index_dictionaries.keys() and i in letter_index_dictionaries[letter]:
                next_word_matching_positions += 1
                if strategy == "NO_MATCHING":
                    break
            if next_word_matching_positions > 0 and strategy == "NO_MATCHING":
                break
            i += 1

        if next_word_matching_positions + matching_positions <= max_matching:
            for (k,v) in next_word_dictionary.iteritems():
                if k in letter_index_dictionaries.keys():
                    letter_index_dictionaries[k] += v
                else:
                    letter_index_dictionaries.update({k:v})
            words.append(word_list[next_num])
            random_nums.append(next_num)
            x += 1
        else:
            rejected_nums.append(next_num)

    return words

def make_word_letter_dictionary(correct_word):
    correct_word_position_dict = {}
    x = 0
    while x < len(correct_word):
        letter = correct_word[x]
        if letter in correct_word_position_dict.keys():
            correct_word_position_dict[letter].append(x)
        else:
            correct_word_position_dict.update({letter:[x]})
        x += 1
    return correct_word_position_dict

def get_correct_word(words_list):
    correct_word = words_list[random.randrange(0, len(words_list)-1)]
    correct_word_position_dict = make_word_letter_dictionary(correct_word)
    return (correct_word, correct_word_position_dict)

def valid_num(num, words_length):
    return num > 0 and num <= words_length

def get_next_guess(words):
    next_guess_input = ""
    words_string = ""
    x = 0
    while x < len(words):
        words_string += str(x + 1) + "." + words[x] + "\n"
        x += 1
    next_guess = 0
    while next_guess_input.isdigit() == False or valid_num(int(next_guess_input), len(words)) == False:
        next_guess_input = raw_input("Choose from options [enter number next to word]:\n" + words_string)
        if next_guess_input.isdigit():
            next_guess = int(next_guess_input)
    return next_guess

def make_guesses(words, correct_word, correct_word_position_dict):
    correct_positions = 0
    guesses = 0
    while guesses < GUESSES:
        if guesses > 0:
           print("You have guessed " + str(correct_positions) + "/" + str(len(correct_word)) + " letters")
        next_guess = get_next_guess(words)
        play_again_input = ''
        if words[next_guess - 1] == correct_word:
            play_again_input = raw_input("Congrats you have won the game, enter p to play again")
        elif guesses + 1 == GUESSES:
            play_again_input = raw_input("Game is over, you lost, enter p to play again")
        if play_again_input.lower() == 'p':
            play_game()
        elif next_guess != correct_word:
            x = 0
            while x < len(words[next_guess - 1]):
                letter = words[next_guess - 1][x]
                if letter in correct_word_position_dict.keys() and x in correct_word_position_dict[letter]:
                    correct_positions += 1
                    correct_word_position_dict[letter].remove(x)
                x += 1
            words.remove(words[next_guess - 1])
        guesses += 1

def initialize_game():
    game_input = ""
    difficulty_of_game = 0
    while game_input.isdigit() == False or (difficulty_of_game in DIFFICULTY_NUMBER_OF_WORDS_LETTERS.keys()) == False:
        game_input = raw_input("How hard should this game be: (enter a number from 1-5)")
        if game_input.isdigit():
            difficulty_of_game = int(game_input)

    number_words_letters = DIFFICULTY_NUMBER_OF_WORDS_LETTERS[difficulty_of_game]
    num_of_words = number_words_letters[0]
    length_of_words = number_words_letters[1]
    strategy_list = DIFFICULTY_GAME_STRATEGIES[difficulty_of_game]
    strategy = strategy_list[random.randrange(0, len(strategy_list) - 1)]
    print(strategy)
    words = complete_strategy(strategy, num_of_words, length_of_words)

    return (words, strategy, length_of_words)

def play_game():
    words, strategy, words_length = initialize_game()
    if strategy == "NO_WINNER":
        correct_word = '-' * words_length
        correct_word_position_dict = {}
    else:
        correct_word, correct_word_position_dict = get_correct_word(words)
    make_guesses(words, correct_word, correct_word_position_dict)

play_game()

share
Save
spamburghlar
1 point·2 years ago

Java

package challenge238_intermediate;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Random;


public class FalloutHacking {

        enum GameDifficulty {VERY_EASY, EASY, AVERAGE, HARD, VERY_HARD;}
        private Map Words;
        private String answer;
        private List<String> candidates;
        private int wordLength;
        private int numberOfWords;
        private int guessesRemaining;
        public FalloutHacking() {

                Words = new Hashtable();
                try {
                        this.readWordsToMap();

                } catch (FileNotFoundException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
        }
        public void reset(GameDifficulty gd) {
                answer = null;
                candidates = null;
                guessesRemaining = 4;
                this.setGameDifficulty(gd);
        }
        private void setGameDifficulty(GameDifficulty gd){
                Random rdm = new Random();
                switch(gd){
                case VERY_EASY: wordLength = rdm.nextInt(2) + 4;
                                                numberOfWords = rdm.nextInt(2) + 5;
                                                break;
                case EASY:              wordLength =  rdm.nextInt(2) + 6;
                                                numberOfWords = rdm.nextInt(2) + 7;
                                                break;
                case AVERAGE:   wordLength =  rdm.nextInt(3) + 8;
                                                numberOfWords = rdm.nextInt(2) + 9;
                                                break;
                case HARD:              wordLength =  rdm.nextInt(3) + 11;
                                                numberOfWords = rdm.nextInt(2) + 11;
                                                break;
                case VERY_HARD: wordLength =  rdm.nextInt(2) + 14;
                                                numberOfWords = rdm.nextInt(3) + 13;
                                                break;
                }
                this.setCandidates();
        }
        private void setCandidates(){
                Random selector = new Random();
                List<String> wordList = (List<String>)Words.get(wordLength);
                int randBound = wordList.size();
                candidates = new ArrayList<String>();
                for(int i = 0; i < numberOfWords; i++){
                        candidates.add(wordList.get(selector.nextInt(randBound)));
                }
                randBound = candidates.size();
                answer = candidates.get(selector.nextInt(randBound));
        }
        public void getCandidates(){
                for(String s: candidates){
                        System.out.println(s);
                }
        }
        public int tryAnswer(String s){
                if(s.equals(answer)){
                        return answer.length();
                }else{
                        char[] input = s.toCharArray();
                        char[] ans = answer.toCharArray();
                        int correctPositions = 0;
                        for(int i = 0; i < input.length; i++){
                                if(input[i] == ans[i]){
                                        correctPositions++;
                                }
                        }
                        guessesRemaining--;
                        return correctPositions;
                }
        }
        public int getNumberOfRemainingGuesses(){
                return guessesRemaining;
        }
        private void readWordsToMap() throws FileNotFoundException{
                File wordSource = new File("enable1.txt");
                Scanner input = new Scanner(wordSource);


                while(input.hasNext()){
                        String listVal = input.next();
                        int listKey = listVal.length();

                        if(Words.containsKey(listKey)){
                                List<String> tempList = (List<String>)Words.get(listKey);
                                tempList.add(listVal);
                        }else{
                                List<String> tempList = new ArrayList<String>();
                                tempList.add(listVal);
                                Words.put(listKey, tempList);
                        }
                }
                input.close();
        }

        public static void main(String[] args) {
                FalloutHacking fh = new FalloutHacking();
                boolean playing = true;
                String guess;
                int positions;
                Scanner keyboard = new Scanner(System.in);

                System.out.print("Difficulty (1 - 5): ");
                int difficulty = keyboard.nextInt();
                switch(difficulty){
                case 1: fh.reset(GameDifficulty.VERY_EASY); break;
                case 2: fh.reset(GameDifficulty.EASY); break;
                case 3: fh.reset(GameDifficulty.AVERAGE); break;
                case 4: fh.reset(GameDifficulty.HARD); break;
                case 5: fh.reset(GameDifficulty.VERY_HARD); break;
                }

                fh.getCandidates();
                while(playing){

                        System.out.print("\nEnter guess: ");
                        guess = keyboard.next();
                        positions = fh.tryAnswer(guess);
                        if(positions == guess.length()){
                                System.out.println("Correct!");
                                playing = false;
                        }else{
                                System.out.println(positions + "/" + guess.length() + " correct");
                                System.out.println("Guesses remaining: " + fh.guessesRemaining);
                        }
                        if(fh.guessesRemaining < 1){
                                playing = false;
                        }
                }


        }

}

share
Save
redragon11
1 point·2 years ago

Late, but whatever, randomly assigns word length/number of words, also checks
for invalid input.

VB.NET (feedback appreciated):

Imports System.IO
Module Module1
Dim rand As New Random()
Sub Main()
    Dim words(rand.Next(5, 15)) As String
    Dim wordList() As String = File.ReadAllLines("enable1.txt")
    Dim length As Integer = rand.Next(4, 15)
    Dim count As Integer = 0
    Do While count < words.Length
        Dim line As String = wordList(rand.Next(0, wordList.Length - 1))
        If line.Length = length Then
            words(count) = line
            count += 1
        End If
    Loop
    Dim answer() As Char = words(rand.Next(0, words.Length - 1)).ToLower().ToCharArray()
    For Each s As String In words
        Console.WriteLine(s.ToUpper())
    Next
    For i As Integer = 0 To 3
        Console.WriteLine("Guess " + (i + 1).ToString())
        Dim guess(length - 1) As Char
        Do While 1 > 0
            Dim line As String = Console.ReadLine().Trim().ToLower()
            If line.Length = length And words.Contains(line) Then
                guess = line.ToCharArray()
                Exit Do
            End If
            Console.WriteLine("Your input is invalid.")
        Loop
        Dim correct As Integer = 0
        For j As Integer = 0 To length - 1
            If answer(j) = guess(j) Then
                correct += 1
            End If
        Next
        Console.WriteLine(correct.ToString() + "/" + length.ToString() + " correct")
        If correct = length Then
            Console.WriteLine("You win!")
            Exit For
        End If
    Next
    Console.ReadLine()
End Sub
End Module

share
Save
ntwt
1 point·2 years ago

Java

public class Main
{
public static Scanner scanner;
public static Random random;

public static int[][] WORD_LENGTH = { { 4, 5 }, { 6, 7 }, { 8, 9, 10 }, { 11, 12, 13 }, { 14, 15 } };
public static int[][] NUMBER_OF_WORDS = { { 5, 6 }, { 7, 8 }, { 9, 10, 11 }, { 12, 13 }, { 14, 15 } };

public static void main(String[] args)
{
        scanner = new Scanner(System.in);
        random = new Random();

        int difficulty;
        int lives = 4;
        String selectedWord = "";
        ArrayList<String> wordsList;

        // Get difficulty from player
        difficulty = getDifficulty();

        // Generate words list based on difficulty
        wordsList = generateWordslist(difficulty);

        // Select a random word from the words list
        selectedWord = wordsList.get(random.nextInt(wordsList.size()));

        // Display the list of words to the player
        for (String s : wordsList)
        {
                System.out.println(s.toUpperCase());
        }

        // Game loop
        while (lives > 0)
        {
                System.out.print("Guess (" + lives + " left)? ");

                // Read player's answer
                String answer = scanner.next().trim();
                scanner.nextLine();

                // Check the player's answer
                int correct = checkAnswer(selectedWord, answer);
                System.out.println(correct + "/" + selectedWord.length() + " correct");

                // Check win condition
                if (correct == selectedWord.length())
                {
                        System.out.println("You win!");
                        return;
                }
        }

        // Player is out of lives
        scanner.close();
        System.out.println("Game over!");
}

public static int getDifficulty()
{
        int difficulty = 0;
        while (!(difficulty >= 1 && difficulty <= 5))
        {
                System.out.print("Difficulty (1-5)? ");
                try
                {
                        difficulty = scanner.nextInt();
                        scanner.nextLine();
                }
                catch (Exception e)
                {
                        scanner.nextLine();
                }
        }
        return difficulty;
}

public static ArrayList<String> generateWordslist(int difficulty)
{
        // Get the word length for each word and the number of total words based on the difficulty
        int[] wordLengthRange = WORD_LENGTH[difficulty - 1];
        int wordLength = wordLengthRange[random.nextInt(wordLengthRange.length)];
        int[] numberOfWordsRange = NUMBER_OF_WORDS[difficulty - 1];
        int numberOfWords = numberOfWordsRange[random.nextInt(numberOfWordsRange.length)];

        ArrayList<String> words = new ArrayList<String>();
        ArrayList<String> tmp = new ArrayList<String>();

        File file = new File("enable1.txt");
        try
        {
                Scanner sc = new Scanner(file);
                String line;
                while (sc.hasNextLine())
                {
                        line = sc.nextLine().trim();
                        // Word satisfies our word length requirement
                        if (line.length() == wordLength)
                        {
                                tmp.add(line);
                        }
                }
                sc.close();

                // From our tmp list, select "numberOfWords" of words
                while (words.size() < numberOfWords)
                {
                        int index = random.nextInt(tmp.size());
                        words.add(tmp.get(index));
                        tmp.remove(index);
                }
        }
        catch (Exception e)
        {
                e.printStackTrace();
                System.exit(0);
        }

        return words;
}

public static int checkAnswer(String selectedWord, String answer)
{
        int correct = 0;
        // Convert words to lower case to ignore case when comparing
        String chosenWordLower = selectedWord.toLowerCase();
        String answerLower = answer.toLowerCase();

        for (int i = 0; i < chosenWordLower.length() && i < answerLower.length(); i++)
        {
                if (chosenWordLower.charAt(i) == answerLower.charAt(i))
                {
                        correct++;
                }
        }
        return correct;
}

}

share
Save
[deleted]
1 point·2 years ago

Java. Quick and dirty

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.*;

public enum Difficulty {
        very_easy,
        easy,
        average,
        hard,
        very_hard
}


public class Main {

        public static void main(String[] args) {
                Scanner in = new Scanner(System.in);
                int level = -1;

                while(level != 0) {
                        printRules();
                        level = in.nextInt();
                        Game game;
                        switch(level) {
                                case 1:
                                        game = new Game(Difficulty.very_easy);
                                        break;
                                case 2:
                                        game = new Game(Difficulty.easy);
                                        break;
                                case 3:
                                        game = new Game(Difficulty.average);
                                        break;
                                case 4:
                                        game = new Game(Difficulty.hard);
                                        break;
                                case 5:
                                        game = new Game(Difficulty.very_hard);
                                        break;
                                case 0:
                                        System.out.println("Good bye");
                                        System.exit(1);
                                default:
                                        System.out.println("Invalid selection. Using average");
                                        game = new Game(Difficulty.average);
                                        break;
                        }
                        game.play();
                        level = -1;
                }
        }

        public static void printRules() {
                System.out.println("Select difficulty");
                System.out.println("\t(1) Very easy");
                System.out.println("\t(2) Easy");
                System.out.println("\t(3) Average");
                System.out.println("\t(4) Hard");
                System.out.println("\t(5) Very hard");
                System.out.println("\t(0) Quit");
        }
}

class Game {
        private FileReader fr;
        private Difficulty difficulty;
        private int remainingGuesses;
        private String password;
        private String[] wordList;
        private Random rand;

        public Game(Difficulty level){
                rand = new Random();
                difficulty = level;
                remainingGuesses = 4;
        }

        public void play() {
                Scanner sc = new Scanner(System.in);
                makeWordList();

                for(int i=0; i<wordList.length; i++) {
                        System.out.println(wordList[i]);
                }

                System.out.println("Guess (" + remainingGuesses + " left)? ");
                String guess = sc.nextLine();

                while(!guess.equalsIgnoreCase(password) && --remainingGuesses > 0) {
                        System.out.println(checkLetter(guess));
                        System.out.println("Guess (" + remainingGuesses + " left)? ");
                        guess = sc.nextLine();
                }

                if(!guess.equalsIgnoreCase(password))
                        System.out.println("The password was \"" + password + "\" Better luck next time\n");
                else
                        System.out.println("You did it!\n");
        }

        public void makeWordList() {
                try {
                        fr = new FileReader("..\\src\\enable1.txt");
                } catch (FileNotFoundException e) {
                        System.out.println(e);
                }

                switch(difficulty) {
                        case very_easy:
                                wordList = makeWordList(4, 5);
                                break;
                        case easy:
                                wordList = makeWordList(5, 6);
                                break;
                        case average:
                                wordList = makeWordList(8, 8);
                                break;
                        case hard:
                                wordList = makeWordList(10, 12);
                                break;
                        case very_hard:
                                wordList = makeWordList(13, 15);
                                break;
                        default:
                                wordList = makeWordList(8, 8);
                                break;
                }

                // Set password
                password = wordList[rand.nextInt(wordList.length-1)];
        }

        public String[] makeWordList(int wordLength, int numWords) {
                ArrayList<String> bigList = new ArrayList<>();
                String[] list = new String[numWords];
                Scanner sc = new Scanner(fr);
                String line;

                // Get all words of specified length
                while(sc.hasNext()) {
                        line = sc.nextLine();
                        if(line.length() == wordLength)
                                bigList.add(line);
                }

                // Select a specified number of randomly selected words
                for(int i=0; i<numWords; i++) {
                        list[i] = bigList.remove(rand.nextInt(bigList.size()-1));
                }

                return list;
        }

        public String checkLetter(String g) {
                int correct = 0;

                // Check each
                for (int i=0; i<password.length(); i++) {
                        if(g.charAt(i) == password.charAt(i))
                                correct++;
                }

                return String.format("%d/%d correct", correct, pass.length);
        }
}

share
Save
coolirisme
1 point·2 years ago·edited 2 years ago

C99 solution. Reviews welcome.

//Fallout Hacking Game
//Use a dictionary file with UNIX line endings

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <string.h>

int32_t get_words(const uint32_t word_count,const uint32_t word_length,
                                FILE *fp,char *buffer);

int main(int argc,char **argv)
{
        if(argc < 2)
        {
                fprintf(stderr,"Give me a dictionary file to work with.\n");
                fprintf(stderr,"Usage : %s <dictionary.txt>\n",argv[0]);
                fprintf(stderr,"Note : Dictionary should be encoded with UNIX Line Endings\n");
                return -1;
        }

        uint8_t difficulty = 0,word_len = 0,word_count = 0,word_choice = 0;
        uint8_t letter_match_count = 0,solved = 0,guess_rem = 4;
        FILE *fp = fopen(argv[1],"r");

        difficulty_prompt:
        fprintf(stderr,"Difficulty (1 - 5)? ");
        scanf("%d",&difficulty);

        if((difficulty > 5) || (difficulty < 1))
        {
                fprintf(stderr,"\nChoice outside bounds.\n");
                goto difficulty_prompt;
        }

        word_len = difficulty + 5;
        word_count = difficulty + 6;
        char *words = (char *)malloc(sizeof(char) * (word_len * word_count));

        //Get words from dictionary
        get_words(word_count,word_len,fp,words);

        //Choose a random word from words as password
        uint8_t correct = (uint8_t)rand()%(word_count - 1);
        char *correct_word = (char *)malloc(sizeof(char) * word_len);
        correct_word = strncpy(correct_word,(words + word_len * correct),word_len);

        //Print words
        for(int32_t i = 0; i < word_count; i++)
        {
                fprintf(stderr,"%d) ",i);
                for(int32_t j = 0; j < word_len; j++)
                        fprintf(stderr,"%c",words[i * word_len + j]);
                fprintf(stderr,"\n");
        }

        char *guessed_word;
        while(guess_rem != 0)
        {
                fprintf(stderr,"\nGuess remaining(%d)\n",guess_rem);
                choice_prompt:
                fprintf(stderr,"Word choice(0 - %d)? ",word_count-1);
                scanf("%d",&word_choice);
                if((word_choice > (word_count - 1)) || (word_choice < 0))
                {
                        fprintf(stderr,"\nChoice outside bounds\n");
                        goto choice_prompt;
                }

                //Compare password with guess word
                guessed_word = words + (word_len * word_choice);
                for(int32_t i = 0; i < word_len; i++)
                {
                        if(guessed_word[i] == correct_word[i])
                                letter_match_count++;
                }

                if(letter_match_count == word_len)
                {
                        solved = 1;
                        break;
                }
                else
                        fprintf(stderr,"%d/%d letter(s) match.\n",letter_match_count,word_len);

                letter_match_count = 0;
                guess_rem--;
        }

        if(solved)
                fprintf(stderr,"You win!! Password : %s\n",correct_word);
        else
                fprintf(stderr,"You failed. Correct password : %s\n",correct_word);

        free(words);
        fclose(fp);
        return 0;
}

int32_t get_words(const uint32_t word_count,const uint32_t word_length,
                                FILE *fp,char *buffer)
{
        char temp[4096];
        char *word = (char *)malloc(sizeof(char) * word_length);
        int32_t i = 0,len = 0,offset = 0,generated = 0;
        off_t random_int;

        //Determine dictionary length
        fseeko(fp,0,SEEK_END);
        off_t file_len = ftello(fp);

        srand(time(NULL));

        loop_begin:
        //Generate random number between 0 and file_len
        random_int = (off_t)rand()%(file_len - 4097);
        srand(random_int);//Seed again

        //Seek to random position at dictionary
        fseeko(fp,random_int,SEEK_SET);
        fread(temp,sizeof(char),sizeof(temp),fp);

        while(1)
        {
                if(temp[i] == '\n')
                        break;
                i++;
        }

        while(1)
        {
                len = 0;
                while(1)
                {
                        i++;
                        if(temp[i] == '\n')
                                break;
                        len++;
                }
                if(len == word_length)
                {
                        word = strncpy(word,(temp+i-word_length),word_length);
                        generated++;
                        strncpy((buffer+offset),word,word_length);
                        offset += word_length;
                        break;
                }
                if(i == 4096)
                        break;
        }

        i = 0;
        if(generated < word_count)
                goto loop_begin;

        free(word);
        return generated;
}

Output

share
Save
Comment deleted2 years ago
CaptainCa
1 point·2 years ago

wrong thread buddy

share
Save
MondayMonkey1
1 point·2 years ago

Here's my node implementation. Aside from a few fat arrows, it's all es5.
Cheers!

var fs = require('fs')
var readLine = require('readline');
var Promise = require('bluebird');
var difficulty = 1;
var wordLength;
var win = false;
var attemptsLeft;
var targetWord = '';
var wordBank = [];

var rl = readLine.createInterface({
        input:process.stdin,
        output:process.stdout
});

rl.question("Difficulty? (1-5)",function(response){
        difficulty = +response;
        attemptsLeft = 10-difficulty;
        wordLength = difficulty+2;
        getWords().then(function(words){
                var eligWords = words.filter(function(word){
                        return word.length === wordLength;
                });
                for(var i = 0;i<(difficulty*3);i++){
                        var index = Math.floor(Math.random()*eligWords.length);
                        targetWord = eligWords[index];
                        if(wordBank.indexOf(targetWord) != -1){
                                i--;
                        }
                        else{
                                wordBank.push(targetWord)
                        }
                }
                console.log(wordBank)
                console.log(`Guess? (${attemptsLeft} left)`)
        })
})

rl.prompt();
rl.on('line',function(guess){
        guess = guess.toLowerCase();
        var matches = 0;
        guess.split('').forEach(function(char,i){
                if(char === targetWord[i])
                        matches++;
        })

        if(matches === targetWord.length) {
                win = true;
                console.log('you won');
                process.exit();
        }
        else{

                if(attemptsLeft-- === 1){
                        console.log('you lost');
                        return process.exit();
                }
                console.log(`${matches}/${targetWord.length} correct`)
                console.log(`Guess (${attemptsLeft} left)`)
        }
})

var getWords = exports.getWords = ()=>{
        return new Promise(function(resolve,reject){
                fs.readFile('enable1.txt',function(err,data){
                        if(err) reject(err);
                        else resolve(data.toString().split('\r\n'));
                })
        })
}

share
Save
sort_of_a_username
1 point·2 years ago

Python 2.7

import random

def play():

    dif_dict = {1: random.randint(4, 5),
                2: random.randint(6, 8),
                3: random.randint(9, 10),
                4: random.randint(11, 12),
                5: random.randint(13, 15)}

    pass_len = dif_dict[input('Difficulty (1-5)? ')]

    # create word list
    with open('words.txt', 'r') as f:
        words = [word for word in [l.rstrip() for l in list(f)] if len(word) == pass_len]

    # choose random password
    password = random.choice(words)

    # print possible passwords
    displayed = random.sample(words, random.randint(4, 14))
    displayed.append(password)

    for word in displayed:
        print word.upper()

    # start game
    tries = 4
    while tries > 0:

        guess = raw_input('Guess (%s left)? ' % tries).lower()

        correct = [guess[i] for i in xrange(len(guess)) if guess[i] == password[i]]

        if len(correct) == len(password):
            print 'You win!'
            return

        else:
            print '%s/%s correct' % (len(correct), len(password))
            tries -= 1

play()

share
Save
nommywommyo
1 point·2 years ago·edited 2 years ago

Haskell. Been on a Fallout 4 binge so I thought this was appropriate

import Control.Applicative((<$>))
import Control.Monad.Random
import Control.Monad.Trans(liftIO)
import Data.Char
import Data.List
import Data.Maybe
import System.IO
import System.Random

main :: IO ()
main = do
    putStr "Difficulty (1-5)? " >> hFlush stdout
    runHackingGame =<< read <$> getLine

runHackingGame :: Int -> IO ()
runHackingGame difficulty = evalRandT (playHackingGame difficulty) =<< getStdGen

playHackingGame :: RandomGen g => Int -> RandT g IO ()
playHackingGame difficulty = do
    wordLength <- getRandomR (fromJust $ lookup difficulty lengthByDifficulty)
    wordCount  <- getRandomR (fromJust $ lookup difficulty countByDifficulty)
    dictionary <- map (map toUpper) . filter ((==wordLength) . length) . lines <$> (liftIO $ readFile "enable1.txt")
    words <- (map (dictionary !!) . take wordCount) <$> getRandomRs (0, length dictionary)
    word  <- (words !!) <$> getRandomR (0, wordCount - 1)
    liftIO $ mapM_ putStrLn words
    liftIO $ promptPlayer 4 word

promptPlayer :: Int -> String -> IO ()
promptPlayer 0 _ = putStrLn "You Lose!"
promptPlayer guessesLeft targetWord = do
    putStrLn $ "Guess (" ++ show guessesLeft ++ " left)? "
    guess <- map toUpper <$> getLine
    let similarity = length $ filter id $ zipWith (==) guess targetWord
    putStrLn $ show similarity ++ "/" ++ (show $ length targetWord) ++ " correct"
    if guess == targetWord
        then putStrLn "You Win!"
        else promptPlayer (guessesLeft - 1) targetWord

countByDifficulty :: [(Int, (Int, Int))]
countByDifficulty =
    [
     (1, (5 ,6 ))
    ,(2, (7 ,8 ))
    ,(3, (9 ,10))
    ,(4, (11,12))
    ,(5, (13,15))
    ]

lengthByDifficulty :: [(Int, (Int, Int))]
lengthByDifficulty =
    [
     (1, (4 ,4 ))
    ,(2, (5 ,6 ))
    ,(3, (7 ,8 ))
    ,(4, (9 ,11))
    ,(5, (12,15))
    ]

share
Save
chemicalphysicist
1 point·2 years ago·edited 2 years ago

C++/C

I'm a newbie programmer and I wanted to make this into more of a project for
myself (although, it is probably excessively long).

removed

  • I used C-style strings for this project/game so I'd have a chance to
    practice their usage and get comfortable working with mutable strings and
    dynamic memory allocation (although, I believe errors with freeing the
    memory still exist).

  • There is probably a way to make this much shorter... my plan for now is to
    rewrite the game with either std::vector or std::array and to use
    std::string since I imagine this'll make many of the issues I was
    struggling with disappear.

I hope someone reads this... even if it is a month old post.

share
Save
Tarroy
1 point·2 years ago·edited 2 years ago

Bad C++ Solution

I'm a beginner in C++ so if you got improvements please let me know.

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <random>
#include <algorithm>
#include <time.h>

using namespace std;


//Here you can select the difficulty
int difficultySelection()
{
        cout << "Please select difficulty:" << endl
                << "Very Easy   = 1 : Passwort Length 4-5" << endl
                << "Easy                = 2 : Passwort Length 6-8" << endl
                << "Average             = 3 : Passwort Length 9-10" << endl
                << "Hard                = 4 : Passwort Length 11-12" << endl
                << "Very Hard   = 5 : Passwort Length 13-15" << endl;

        int diff;
        cin >> diff;

        if (5 >= diff && 1 <= diff)
        {
                cout << "Choosen difficulty: " << diff << endl;
                return diff;
        }
        else
        {
                cout << "Wrong input. Only Interger 1-5 allowed!" << endl
                        << "Please Try again.\n" << endl;
                difficultySelection();
        }
        return -1;
}

//get the length with the formula: length = minLength + (rand() % maxLength-minLength + 1
int getRandomPasswordLength(int diff)
{
        srand(time(nullptr));

        switch (diff)
        {
        case 1:
                return 4 + (rand() % 2);

        case 2:
                return 6 + (rand() % 3);

        case 3:
                return 9 + (rand() % 2);

        case 4:
                return 11 + (rand() % 2);

        case 5:
                return 13 + (rand() % 3);

        default:
                return 1;
        }
}

//Prove if the word from Textfile has the correct Length
bool isValidWord(string word, int passwordLength)
{
        return passwordLength == word.length();
}

//Get all words from TextFile with the correct wordlength
vector<string> readTextFile(string textFileName, int passwordLength)
{
        ifstream textFile(textFileName);
        string word;
        vector<string> validWords;
        while (getline(textFile, word))
        {
                if(isValidWord(word, passwordLength))
                {
                        transform(word.begin(), word.end(), word.begin(), toupper);
                        validWords.push_back(word);
                }
        }
        return validWords;
}


//Choose one Random word from a vector
string chooseRandomWord(vector<string> words)
{
        random_device seed;
        mt19937 engine(seed());
        uniform_int_distribution<unsigned long int> choose(0, words.size() - 1);

        return words.at(choose(engine));
}

//get the words for this round
vector<string> getFinalWords(vector<string> words, int wordsLength)
{
        vector<string> finalWords;

        for (int i = 0; i < wordsLength;++i)
                finalWords.push_back(chooseRandomWord(words));

        return finalWords;
}

//print the words for this round
void printWords(vector<string> validWords)
{
        for (vector<string>::iterator wordsIter = validWords.begin(); wordsIter != validWords.end(); ++wordsIter)
                cout << *wordsIter << endl;
}

//get the guessed word from user
string guess(int passwordLength)
{
        string word;
        cin >> word;
        if (word.length() != passwordLength)
        {
                cout << "Incorrect length of Word!\n";
                guess(passwordLength);
        }

        transform(word.begin(), word.end(), word.begin(), toupper);
        return word;
}

//prove the correct Letters from userinput and password
int getCorrectLetters(string word, string password)
{
        int counter = 0;
        for (int i = 0; i < password.length(); ++i)
        {
                if (password[i] == word[i])
                        ++counter;
        }
        return counter;
}

//Here you start the game
void playGame(vector<string> words, string password, int passwordLength)
{
        int correctLetters = 0;
        int guesses = 4;

        string word = "";
        printWords(words);

        while(word != password && 0 != guesses)
        {
                cout << "Guess (" << guesses << " left) ? ";
                word = guess(passwordLength);
                correctLetters = getCorrectLetters(word, password);
                cout << correctLetters << "/" << passwordLength << " correct\n";

                --guesses;
        }


        if (password == word)
                cout << "You win\n";
        else
        {
                cout << "You loose\n";
                cout << "The correct word was: " << password << endl;
        }
        cout << "The End.\n";

}

void main()
{
        int diff = difficultySelection();
        int passwordLength = getRandomPasswordLength(diff);

        vector<string> validWords = readTextFile("enable1.txt", passwordLength);
        vector<string> finalWords = getFinalWords(validWords, 10);
        string password = chooseRandomWord(finalWords);

        playGame(finalWords, password, passwordLength);
}

share
Save
r4n
1 point·2 years ago

Java approach:

package com.reddiy.FalloutHackingGame;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.ThreadLocalRandom;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.Predicate;

public class FalloutHackingGame {

        private enum DifficultySettings {
                EASY(4,5),
                MIDEASY(6,7),
                MEDIUM(9,9),
                MIDMEDIUM(12,12),
                HARD(15,15);

                private final int wordLength;
                private final int numWords;

                private DifficultySettings(int wordLength, int numWords){
                this.wordLength = wordLength;
                this.numWords = numWords;
            }

                public int getWordLength() {
                        return wordLength;
                }

                public int getNumWords() {
                        return numWords;
                }

                public static DifficultySettings getByDifficulty(int difficulty){

                        DifficultySettings difficultToReturn = DifficultySettings.EASY;
                        if(difficulty == 1){
                                difficultToReturn = DifficultySettings.EASY;
                        }else if(difficulty == 2){
                                difficultToReturn = DifficultySettings.MIDEASY;
                        }else if(difficulty == 3){
                                difficultToReturn = DifficultySettings.MEDIUM;
                        }else if(difficulty == 4){
                                difficultToReturn = DifficultySettings.MIDMEDIUM;
                        }else if(difficulty == 5){
                                difficultToReturn = DifficultySettings.HARD;
                        }
                        return difficultToReturn;
                }


        }

        private static final int OPPORTUNITIES = 4;

        public static void main (String [] args ){

                List<String> gameWords = readInput();
                int difficulty = readDifficulty();

                List<String> wordsToShow = getWordsToShow(difficulty,gameWords);
                playGame(wordsToShow, difficulty);
        }

        private static void playGame(List<String> wordsToShow, int difficulty) {

                int currentOpportunities = OPPORTUNITIES;
                String winnerWord = wordsToShow.get(ThreadLocalRandom.current().nextInt(0, wordsToShow.size()));
                @SuppressWarnings("resource")
                Scanner scanner = new Scanner(System.in);
                String guessWord;
                boolean solved = false;

                printScreen(wordsToShow);
                while(currentOpportunities > 0 && !solved){
                        System.out.print("Guess ("+currentOpportunities+" left) ? ");
                        guessWord = scanner.next();

                        solved = checkGuess(wordsToShow, winnerWord, guessWord);
                        currentOpportunities--;
                }

                if(solved == true){
                        System.out.println("You win!");
                }else{
                        System.out.println("FAIL. Correct one was "+winnerWord);
                }
        }

        private static boolean checkGuess(List<String> wordsToShow, String winnerWord, String guessWord) {
                boolean solved = false;
                if(winnerWord.equals(guessWord)){
                        solved = true;
                }else{
                        solved = false;
                        int count=0;
                        for(int i=0; i<winnerWord.length();i++){
                                if(winnerWord.charAt(i) == guessWord.charAt(i)){
                                        count++;
                                }
                        }
                        System.out.println(count+"/"+winnerWord.length()+" correct");
                }

                return solved;

        }

        private static void printScreen(List<String> wordsToShow) {
                for(String word : wordsToShow){
                        System.out.println(word);
                }
        }

        private static List<String> getWordsToShow(int difficulty, List<String> gameWords) {

                DifficultySettings enumDifficulty = DifficultySettings.getByDifficulty(difficulty);

                int wordLength = enumDifficulty.getWordLength();
                int numWords = enumDifficulty.getNumWords();

                List<String> wordsOfLength = getWordsByLength(gameWords, wordLength);
                List<String> exactWordsToShow = getExactWordsToShow(wordsOfLength, numWords);

                return exactWordsToShow;
        }

        private static List<String> getExactWordsToShow(List<String> wordsOfLength, int numWords) {
                List<String> listWords = new ArrayList<String>();
                int random;
                for(int i=0;i<numWords;i++){
                        random = ThreadLocalRandom.current().nextInt(0, wordsOfLength.size());
                        listWords.add(wordsOfLength.get(random));
                }

                return listWords;

        }

        private static List<String> getWordsByLength(List<String> gameWords, final int wordLength) {

                Collection<String> filteredCollection = CollectionUtils.select(gameWords,new Predicate<String>() {
                    @Override
                    public boolean evaluate(String o) {
                        return o.length() == wordLength;
                    }});

                return (List<String>) filteredCollection;
        }

        private static int readDifficulty() {
                @SuppressWarnings("resource")
                Scanner scanner = new Scanner(System.in);

                System.out.print("Enter dificulty (1-5): ");
                int difficulty = scanner.nextInt();
                System.out.print("difficulty = "+difficulty);

                return difficulty;
        }

        private static List<String> readInput() {

                List<String> files = null;
                try {
                        files = Files.readAllLines(Paths.get("D:\\TECH\\REDDITDAILYPROGRAMMER\\enable1.txt"), StandardCharsets.UTF_8);
                } catch (IOException e) {
                        System.err.println("ERROR READING FILE");
                }

                return files;

        }

}

share
Save
duckofdoom12
1 point·2 years ago

http://ma.cruxpanel.nl/PROJECTS/PROJECTS-fallout-hacking-game/

r8 m80's

done in JS, made as part of a birthday present for a friend

share
Save
BBPP20
1 point·2 years ago

C++

Code: http://pastebin.com/gdAcu3Z7 Words are from enable1.txt file. Only
problem is that searching the file for acceptable words can take up to 5
seconds.

share
Save
ganska_bra
0 points·2 years ago

Rust

extern crate rand;
use rand::Rng;

use std::io::BufReader;
use std::io::prelude::*;
use std::fs::File;

const DICT_FILE: &'static str = "/usr/share/dict/american-english";
const GUESSES: u32 = 4;

fn ask_number(prompt: &str) -> u32 {
    println!("{} ", prompt);
    let mut number = String::new();

    std::io::stdin().read_line(&mut number)
        .ok()
        .expect("Reading number failed!");
    println!("");

    number.trim().parse()
        .ok()
        .expect("Parsing number failed!")
}

fn get_words(word_len: usize, n_words: usize) -> Vec<String> {
    let f = File::open(DICT_FILE).unwrap();
    let f = BufReader::new(f);

    f.lines()
        .map(|x| x.unwrap())
        /* Filter out words with "'s" */
        .filter(|x| x.len() == word_len && !x.contains("'"))
        .take(n_words)
        .collect()
}

fn take_guess(password: &str, guesses: u32) -> bool {
    println!("Guess ({} left)? ", guesses);
    let mut guess = String::new();

    std::io::stdin().read_line(&mut guess)
        .ok()
        .expect("Reading guess failed!");

    let guess = guess.trim().to_lowercase();

    if guess.len() != password.len() {
        return false;
    }

    let mut correct_chars = 0;
    for (i, c) in password.chars().enumerate() {
        if c.to_lowercase().next().unwrap() == guess.chars().nth(i).unwrap() {
            correct_chars += 1;
        }
    }

    println!("{}/{} correct\n", correct_chars, password.len());

    correct_chars == password.len()
}

fn main() {
    let (word_len, word_count) = match ask_number("Difficulty (1-5)?") {
        0 => (2, 2),
        1 => (3, 5),
        2 => (5, 6),
        3 => (7, 7),
        4 => (8, 8),
        _ => (15, 10)
    };

    let words = get_words(word_len as usize, word_count as usize);
    for word in &words {
        println!("{}", word);
    }
    println!("");

    let password = &words[rand::thread_rng().gen_range(0, word_count) as usize];

    for i in 0..GUESSES {
        if take_guess(&password, GUESSES - i) {
            break;
        }
    }

    println!("Password: {}", password);
}

and the output:

Difficulty (1-5)?
5

Americanization
Czechoslovakian
Gewürztraminer
Huitzilopotchli
Liechtensteiner
Netzahualcoyotl
Presbyterianism
Rumpelstiltskin
Zoroastrianisms
acclimatization

Guess (4 left)?
americanization
3/15 correct

Guess (3 left)?
liechtensteiner
1/15 correct

Guess (2 left)?
presbyterianism
15/15 correct

Password: Presbyterianism

share
Save
crossroads1112
1 point·2 years ago

You know you can use print! to print text without the trailing newline (good
for user input), right? Although, you'll have to flush stdout afterwords
(std::io::stdout().flush() which requires the std::io::Write trait to be in
scope). Secondly, it'd be nice to see you select a random sample of words of
the desired length. You also might want to guard against the user inputting a
guess different from the possible words as this could be used to cheat.

share
Save
ganska_bra
1 point·2 years ago

Ah, didn't know about flush and didn't even thought about cheating like that,
good points. I initially considered taking random words from the dict but
didn't notice any obvious ways to do that, but it could be a nice exercise.

Thanks for the comments!

share
Save
Community Details
r/dailyprogrammer

142k

Subscribers

158

Online

**Welcome to r/DailyProgrammer!** First time visitors of Daily Programmer
please [Read the Wiki] (http://www.reddit.com/r/dailyprogrammer/wiki/index) to
learn everything about this subreddit. 3 Programming Challenges a week!

SubscribeCreate Post
aboutcareerspress
advertisebloghelp
the reddit appreddit goldreddit gifts
content policy| privacy policy
user agreement| mod policy
© 2018 Reddit, Inc. All rights reserved
back to top
