close this window
jump to content
my subreddits
edit subscriptions

  • popular
  • -all
  • -random
  • -users

 | 

  • AskReddit
  • -worldnews
  • -videos
  • -funny
  • -todayilearned
  • -pics
  • -gaming
  • -movies
  • -news
  • -gifs
  • -mildlyinteresting
  • -aww
  • -Showerthoughts
  • -television
  • -Jokes
  • -science
  • -OldSchoolCool
  • -sports
  • -IAmA
  • -Documentaries
  • -TwoXChromosomes
  • -explainlikeimfive
  • -personalfinance
  • -books
  • -tifu
  • -Futurology
  • -dataisbeautiful
  • -WritingPrompts
  • -nottheonion
  • -food
  • -Music
  • -photoshopbattles
  • -EarthPorn
  • -philosophy
  • -Art
  • -nosleep
  • -GetMotivated
  • -askscience
  • -LifeProTips
  • -space
  • -UpliftingNews
  • -DIY
  • -history
  • -gadgets
  • -creepy
  • -listentothis
  • -blog
  • -announcements
  • -InternetIsBeautiful

more >>
dailyprogrammer dailyprogrammer

  • comments

Want to join? Log in or sign up in seconds.|

  • English

[                    ][]
[ ]limit my search to r/dailyprogrammer

use the following search parameters to narrow your results:

subreddit:subreddit
    find submissions in "subreddit"
author:username
    find submissions by "username"
site:example.com
    find submissions from "example.com"
url:text
    search for "text" in url
selftext:text
    search for "text" in self post contents
self:yes (or self:no)
    include (or exclude) self posts
nsfw:yes (or nsfw:no)
    include (or exclude) results marked as NSFW

e.g. subreddit:aww site:imgur.com dog

see the search faq for details.

advanced search: by author, subreddit...

this post was submitted on  12 Aug 2013
66 points (95% upvoted)
shortlink:  [https://redd.it/1k7s]
[                    ][                    ]
[ ]remember mereset password
login
Submissions restricted
Only approved users may post in this community.

dailyprogrammer

subscribeunsubscribe142,051 readers

120 users here now

 1. Challenge #321: Easy
 2. Challenge #321: Intermediate
 3. Challenge #321: Hard
 4. Weekly #25: Escape the trolls

Welcome to r/DailyProgrammer!

First time visitors of Daily Programmer please Read the Wiki to learn
everything about this subreddit.

  • Solution Submission Tutorial
  • Solution Submission Guidelines
  • Code / Peer-Review Guidelines
  • Problem Submission Guidelines
  • Achievements System
  • Community Projects
  • Links to other Programming subreddits
  • Special Thanks

Can't submit solutions?

If you are a new or unverified account, and are unable to post comment replies,
please click here to verify your account. Otherwise, read the Solution
Submission Tutorial for a walkthrough of submitting a solution, or click below
to message the moderators for assistance.

Write your own challenge!

To help the community and write your own challenge to be submitted, head on
over to /r/DailyProgrammer_Ideas and share your project - read the sidebar in
that subreddit for more information.

IRC Channel

Message the Moderators

Challenge List in Chronological Order

created by nottoobadguya community for 6 years
message the moderators

MODERATORS

  • rya111113 1
  • nint221 2
  • Cosmologicon2 3
  • Elite68091 1
  • XenophonOfAthens2 1
  • jnazario2 0
  • Godspiral3 3
  • Blackshell2 0
  • fvandepitte0 0
  • G33kDude1 1
  • about moderation team >>

discussions in r/dailyprogrammer
<>
X
 
42 . 10 comments
[2018-05-09] Challenge #360 [Intermediate] Find the Nearest Aeroplane
 
60 . 26 comments
[2018-05-04] Challenge #359 [Hard] Primes in Grids
 
44 . 37 comments
[2018-05-02] Challenge #359 [Intermediate] Unwrap Some Text
 
64 . 111 comments
[2018-04-30] Challenge #359 [Easy] Regular Paperfold Sequence Generator
 
67 . 12 comments
[2018-04-27] Challenge #358 [Hard] Puzzle me this
 
49 . 36 comments
[2018-04-25] Challenge #358 [Intermediate] Everyone's A Winner!
 
73 . 75 comments
[2018-04-23] Challenge #358 [Easy] Decipher The Seven Segments
 
53 . 28 comments
[2018-04-20] Challenge #357 [Hard] Continued Fractions
 
53 . 26 comments
[2018-04-19] Challenge #357 [Intermediate] Kolakoski Sequences
 
74 . 114 comments
[2018-04-11] Challenge #356 [Intermediate] Goldbach's Weak Conjecture

Welcome to Reddit,

the front page of the internet.

Become a Redditor

and subscribe to one of thousands of communities.

x

65
66
67

[08/13/13] Challenge #135 [Easy] Arithmetic Equations (self.dailyprogrammer)

submitted 4 years ago by nint221 2

 (Easy): Arithmetic Equations

Unix, the famous multitasking and multi-user operating system, has several
standards that defines Unix commands, system calls, subroutines, files, etc.
Specifically within Version 7 (though this is included in many other Unix
standards), there is a game called "arithmetic". To quote the Man Page:

Arithmetic types out simple arithmetic problems, and waits for an answer to be typed in. If the answer
is correct, it types back "Right!", and a new problem. If the answer is wrong, it replies "What?", and
waits for another answer. Every twenty problems, it publishes statistics on correctness and the time
required to answer.

Your goal is to implement this game, with some slight changes, to make this an
[Easy]-level challenge. You will only have to use three arithmetic operators
(addition, subtraction, multiplication) with four integers. An example equation
you are to generate is "2 x 4 + 2 - 5".

Author: nint22

Formal Inputs & Outputs

Input Description

The first line of input will always be two integers representing an inclusive
range of integers you are to pick from when filling out the constants of your
equation. After that, you are to print off a single equation and wait for the
user to respond. The user may either try to solve the equation by writing the
integer result into the console, or the user may type the letters 'q' or 'Q' to
quit the application.

Output Description

If the user's answer is correct, print "Correct!" and randomly generate another
equation to show to the user. Otherwise print "Try Again" and ask the same
equation again. Note that all equations must randomly pick and place the
operators, as well as randomly pick the equation's constants (integers) from
the given range. You are allowed to repeat constants and operators. You may use
either the star '*' or the letter 'x' characters to represent multiplication.

Sample Inputs & Outputs

Sample Input / Output

Since this is an interactive application, lines that start with '>' are there
to signify a statement from the console to the user, while any other lines are
from the user to the console.

0 10
> 3 * 2 + 5 * 2
16
> Correct!
> 0 - 10 + 9 + 2
2
> Incorrect...
> 0 - 10 + 9 + 2
3
> Incorrect...
> 0 - 10 + 9 + 2
1
> Correct!
> 2 * 0 * 4 * 2
0
> Correct!
q

  • 155 comments
  • share
  • save
  • hide
  • report

all 155 comments
sorted by:
best
topnewcontroversialoldrandomq&alive (beta)
 [                    ]

Want to add to the discussion?

Post a comment!

Create an account

[–]Maiddog 28 points29 points30 points 4 years ago (6 children)

Made in poorly obfuscated C. I thought leaving it in the original formatting
would be too boring so I tried to make a sphere, but that turned out badly. Oh
well.

Not sure how portable it is, but it compiles and works fine for me using gcc
4.6.3 on Windows.

Would be neat if someone could have a hand at de-obfuscating it. The techniques
I used aren't too difficult to reverse.

                    #include <time.h>
                    #include <stdint.h>
                void *m,*n,*w;int i = 25637,
           o;char *y;uint64_t u = 0x6425203E;ts()
        {srand(time(0));m=malloc(010);n=malloc(020);y
      =malloc(80);w=malloc(12);for(int h=-2;h;)scanf( &i,
   (m+(h+++2)*4));main(100);}oa(v){o*=*(int*)(n+v*4);return
  0xa;}ob(v){o += *(int*)(n+v*4);return 0xb;}od(v){o-=*(int*)
(n+v*4);return 0xd;}random(l){for(int h=-2;h<2;)*(int*)(n+(h+++
2)*4)= (rand()%(*(int*)(m+4)-*(int*)m+1)+*(int*)m);sprintf(y, &u,
*(int*)n);o = *(int *)n;int f = 0,k=0;for(int g=1;g<sizeof(char)*
4;){char j = rand(), *s=malloc(80);j=j<0?j-j*2:j;f|=(j%4)<<(4*g);
j=j%4?j%4-1?ob(g):oa(g):od(g);sprintf(s, " %c %d", 32^j,*(int*)(n
+g++*4));strcat(y, s);}o = 0;for(int t=1;t<4;t++){int q=k=(f&(0xF
<<(t*4)))>>(t*4);if(q==1){*(int*)(n+(4*t))*=*(int*)(n+(4*t-4));*(
int*)(n+(4*t-4))=*(int*)(n+(4*t));}}for(int t=1;t<4;t++){int q=
 k=(f & (0xF << (t*4)))>>(t*4);if(q!=1&&q)*(int*)(n+(4*t))+=*(
  int*)(n+(4*t-4));else if(!q)*(int*)(n+(4*t))=*(int*)(n+(4*t-
   4))-*(int*)(n+(4*t));else*(int*)(n+(4*t)) = *(int*)(n+(4*t
    -4));}o=*(int*)(n+12);int x;do{puts(y);scanf(&i,&x);puts(
        x==o?"Correct!":"Incorrect...");}while(x!=o);main(l)
          ;}main(a,e) {a-1?a-90?random(a):exit(0):ts();}

  • permalink
  • embed
  • save
  • give gold

[–]skeeto-9 8 7 points8 points9 points 4 years ago (1 child)

I can see your int-as-string trick only works on little endian computers!

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]Maiddog 2 points3 points4 points 4 years ago (0 children)

I didn't think of this, but you'd be right. An easy idea that comes to mind is
in the starting function I just check if &i[0] == 0 and set i and u
appropriately. I guess I could try to factor that in and edit the above code,
but I don't have any other machine to test on.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]nint221 2[S] 8 points9 points10 points 4 years ago (0 children)

Oh wow... just... woooooooow...

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]dabarnes 4 points5 points6 points 4 years ago (1 child)

well i think i got it spaced out?

edit: hmm i think i may of hit dd in vim somewhere....

#include <time.h>
#include <stdint.h>
void *m,*n,*w;
int i = 25637,
{
    srand(time(0));
    m=malloc(010);
    n=malloc(020);
    y=malloc(80);
    w=malloc(12);
    for(int h=-2;h;)
        scanf( &i,(m+(h+++2)*4));
    main(100);
}

oa(v){
    o*=*(int*)(n+v*4);
    return;
    0xa;
}

ob(v){
    o += *(int*)(n+v*4);
    return 0xb;
}

od(v){
    o-=*(int*)(n+v*4);
    return 0xd;
}
random(l){
    for(int h=-2;h<2;)
        *(int*)(n+(h+++2)*4)= (rand()%(*(int*)(m+4)-*(int*)m+1)+*(int*)m);
    sprintf(y, &u,*(int*)n);
    o = *(int *)n;
    int f = 0,k=0;
    for(int g=1;g<sizeof(char)*4;) {
        char j = rand(), *s=malloc(80);
        j=j<0?j-j*2:j;
        f|=(j%4)<<(4*g);
        j=j%4?j%4-1?ob(g):oa(g):od(g);
        sprintf(s, " %c %d", 32^j,*(int*)(n+g++*4));
        strcat(y, s);
    }
    o = 0;
    for(int t=1;t<4;t++) {
        int q=k=(f&(0xF<<(t*4)))>>(t*4);
        if(q==1) {
            *(int*)(n+(4*t))*=*(int*)(n+(4*t-4));
            *(int*)(n+(4*t-4))=*(int*)(n+(4*t));
        }
    }
    for(int t=1;t<4;t++) {
        int q=k=(f & (0xF << (t*4)))>>(t*4);
        if(q!=1&&q)
            *(int*)(n+(4*t))+=*(int*)(n+(4*t-4));
        else if(!q)
            *(int*)(n+(4*t))=*(int*)(n+(4*t-4))-*(int*)(n+(4*t));
        else
            *(int*)(n+(4*t)) = *(int*)(n+(4*t-4));
    }
    o=*(int*)(n+12);
    int x;
    do{
        puts(y);
        scanf(&i,&x);
        puts(x==o?"Correct!":"Incorrect...");
    } while (x!=o)
    main(l);
}
main(a,e) {
    a-1?a-90?random(a):exit(0):ts();
}
o;
char *y;
uint64_t u = 0x6425203E;
ts()

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]Maiddog 4 points5 points6 points 4 years ago (0 children)

You got the gist of it. The only problems I see is you have a few declarations
on the bottom as if you accidentally cut the start and put it at the end and
the "oa" function's return statement has a semi-colon and newline in the wrong
place (should just be return 0xa;).

Other than that very well done.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]Steve1320 1 12 points13 points14 points 4 years ago (4 children)

Oddly succinct C++11

#include<iostream>
#include<random>
using namespace std;

struct equation_t
{
    size_t data[4];
    uint32_t ops;
    operator size_t() const
    {
        #define ENTRY(x,y,z) data[0] x data[1] y data[2] z data[3]
        #define ROW(x,y)     ENTRY(x,y,+),ENTRY(x,y,-),ENTRY(x,y,*)
        #define SET(x)       ROW(x,+),ROW(x,-),ROW(x,*)
        size_t alleval[27]={SET(+),SET(-),SET(*)};
        return alleval[ops];
    }
    equation_t(size_t min,size_t max,default_random_engine& g)
    {
        uniform_int_distribution<size_t> d(min,max);
        uniform_int_distribution<size_t> od(0,27);
        ops=od(g);
        for(unsigned int i=0;i<4;i++)
        {
            data[i]=d(g);
        }
    }
};

ostream& operator<<(ostream& out,const equation_t& e)
{
    const char opchars[]="+-*";
    size_t opc=e.ops;
    return out << e.data[0] << opchars[e.ops/9] << e.data[1]
                    << opchars[e.ops/3 % 3] << e.data[2]
                    << opchars[e.ops % 3] << e.data[3];
}

int main()
{
    size_t a,b,input;
    cin >> a >> b;
    default_random_engine g;
    equation_t eq(a,b,g);
    cout << eq;
    while(cin >> input)
    {
        if(input==eq)
        {
            cout << "Correct!";
            eq=equation_t(a,b,g);
        }
        else
        {
            cout << "Incorrect!";
        }
        cout << eq;
    }
    return 0;
}

  • permalink
  • embed
  • save
  • give gold

[–]skeeto-9 8 9 points10 points11 points 4 years ago (0 children)

Very clever use of preprocessor macros.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]MDTKBS 3 points4 points5 points 4 years ago (2 children)

Can you explain the code block with "while(cin >> input)"? I've never seen cin
used like that before and I would love to learn your reasoning behind it.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]Steve1320 1 7 points8 points9 points 4 years ago (1 child)

There is a type-conversion operator defined for istream

istream::operator bool() const;

that allows implicit casts from istream to bool when istream is used like a
bool. The value of the boolean returned is whether or not the stream is in a
'good' state or not, and it can flip to 'bad' on an input failure, (such as
when the stream ends, or a formatted input fails because the input is not the
right type).

In addition, the >> operator on istream returns a reference to the original
istream.

So, parsing that, two things basically happen...first, the expression "cin >>
input" is evaluated. This attempts to read an integer and store it as input. If
it fails, it returns a reference to the stream and sets the bad bit on that
stream.

The returned reference to the stream can be converted to bool, so the bad bit
is read, and it returns false.

So, basically, what happens on that line is that at the start of the loop every
iteration it tries to read an integer from stdin, and the loop terminates if
anything that wasn't an integer is put in.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]MDTKBS 1 point2 points3 points 4 years ago (0 children)

Wow. I never would have thought of that in a million years. Very clever. Thanks
for the explanation!

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]winged_scapula 11 points12 points13 points 4 years ago* (10 children)

Python

Feast yer eyes:

import random
from sys import argv

script, n1, n2 = argv

def random_operations(n1, n2):
    while True:
        equation = ''
        for cycle in range(4):
            equation += str(random.randint(int(n1), int(n2))) + ' '
            equation += random.choice(['+','-','*']) + ' '

        equation = equation[:-2]  #snips that extra operation
        print equation
        answer = raw_input('>')
        result = eval(equation)

        if answer in 'qQ':
            break
        elif not answer.isdigit():
            print 'Enter integer next time.'
            continue
        elif int(answer) == result:
            print 'Correct!'
        else:
            print 'Incorrect...'


random_operations(n1, n2)

EDIT: Code slightly changed on bluMyst suggestion. See the response bellow.

  • permalink
  • embed
  • save
  • give gold

[–][deleted] 4 points5 points6 points 4 years ago* (4 children)

script, n1, n2 = argv

That's really clever. I never thought of doing that. What happens if the user
passes too many or too few arguments? I'm on my sister's laptop so I can't
check right now but you've got me curious.

EDIT: Here are some changes that I would make in the interests of constructive
criticm. I'm not claiming that any of these changes are better per se but I
just wanted to give my perspective if that's okay.

I would change

if answer == 'q' or answer == 'Q':

to

if answer in 'qQ':

I think that that's just as readable but is also shorter. Also, instead of just
referring to equation[:-2] I would just go ahead and say equation = equation
[:-2] and be done with it.

  • permalink
  • embed
  • save
  • parent

[–][deleted] 4 years ago (3 children)

[deleted]

[–][deleted] 1 point2 points3 points 4 years ago (2 children)

You're welcome for the suggestions. I also understand not handling the
ValueError since most people will understand what's going on and fix their
arguments.

  • permalink
  • embed
  • save

[–]Fakesantaclaus 4 points5 points6 points 4 years ago (1 child)

Sorry, i'm new to python, what does equation[:-2] mean? or do?

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]donblas 2 points3 points4 points 4 years ago (0 children)

See http://stackoverflow.com/questions/493046/
i-dont-understand-slicing-with-negative-bounds-in-python-how-is-this-supposed

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]neptunDK 2 points3 points4 points 4 years ago (1 child)

script, n1, n2 = argv

I'm not sure I understand this. I know what general unpacking is, but I suspect
something else, something cleaver beyond beginner level is going on there. :)

result = eval(equation)

This one line is why I could figure out how to do this daily programmer.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]neptunDK 1 point2 points3 points 4 years ago (0 children)

script, n1, n2 = argv

I think I understand that line now. It means he can unpack the arguments
directly when running the script. Fx:

Script.py 0 10

Will feed 0 and 10 into the script. So its extending the functionality a bit
further than what was required by the challenge description. For a bit I
thought it was required in some way, hence it confused me.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]PolloFrio 0 points1 point2 points 4 years ago (0 children)

I've got a question about if the answer is incorrect. I don't think this
repeats the same equation and instead generates a new random equation. I'm not
sure how to go about repeating the equation.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]PupPop 0 points1 point2 points 4 years ago (1 child)

I know this is SUPER old, but I believe because of the isdigit(), that this
program will not accept negative numbers even if they are correct. Is there
anyway around this? Also, on an incorrect answer, it produces a new problem
instead of staying on the same one.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]winged_scapula 0 points1 point2 points 4 years ago (0 children)

Please note that this is not very good code, it has many flaws and dead ends, I
wrote it to quickly complete this challenge. On the isdigit() problem, first
that come to my mind is something like this:

try:
    if int(answer) == result:
        print 'Correct!'
    else:
        print 'Incorect!'
except:
    print 'Wrong value!'

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]134671 1 9 points10 points11 points 4 years ago (3 children)

Ruby

$ops = %w(+ - *)
$nums = Range.new(*gets.split.map(&:to_i)).to_a

def random_expr
  expr = "#{$nums.sample}"
  3.times { expr << " #{$ops.sample} #{$nums.sample}" }
  return expr
end

loop do
  puts (expr = random_expr)
  break unless (input = gets) =~ /^\d+/
  puts case input.to_i == eval(expr)
    when false then "Try again."
    when true  then "Correct!"
  end
end

  • permalink
  • embed
  • save
  • give gold

[–]BinofBread 2 points3 points4 points 4 years ago (1 child)

Nice work. Will you explain what this line means?

$nums = Range.new(*gets.split.map(&:to_i)).to_a

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]134671 1 2 points3 points4 points 4 years ago (0 children)

Yeah, that line was definitely too clever to leave unexplained. Basically two
numbers from stdin are read into an Array, whose values passed as arguments to
Range#new using *:

# Reading input as two numbers:
gets                   # "1 8\n"
gets.split             # ["1", "8"]
gets.split.map(&:to_i) # [1, 8]

# Making a range:
Range.new(1, 8)        # 1..8
Range.new(1, 8).to_a   # [1, 2, 3, 4, 5, 6, 7, 8]

Then $nums.sample will return one of those numbers at random.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]TweenageDream 0 points1 point2 points 4 years ago (0 children)

Nice work, but there are two errors with your code, When the answer is a
negative number, it breaks the loop. Also, when answered incorrectly the same
equation is supposed to be presented, your solution gives a new expression
every time. Otherwise nice work, I really like the get input, split and make a
range all in one line.

You can modify your regex like so /^[+-]?\d+/

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]shangas 7 points8 points9 points 4 years ago (0 children)

Haskell

{-# LANGUAGE FlexibleContexts #-}

import Control.Applicative ((<$>),(<*>))
import Control.Monad.State (State, evalState, fix)
import Data.Random (RVar, uniform, sample, randomElement, MonadRandom)
import System.Random.Mersenne.Pure64 (newPureMT)

-- Represent the equation as a tree with Val leaves and Infix branches.
data Equation = Val Int | Infix Equation Operator Equation
data Operator = Add | Subtract | Multiply

-- Define precedence for different operators.
precedence :: Operator -> Int
precedence Add      = 1
precedence Subtract = 1
precedence Multiply = 2

-- Generate a random equation from the given lower and upper bound
-- for constants.
randomEquation :: Int -> Int -> RVar Equation
randomEquation minInt maxInt = step (4 :: Int) where
    step 1 = Val <$> int
    step n = Infix <$> (Val <$> int) <*> op <*> step (n-1)
    op     = randomElement [Add, Subtract, Multiply]
    int    = uniform minInt maxInt

-- Evaluate an equation. During evaluation, restructure the tree according
-- to operator precedence if necessary.
evalEquation :: Equation -> Int
evalEquation (Val i) = i
evalEquation (Infix a op (Infix b op' c))
    | precedence op >= precedence op' = evalEquation $ Infix (Infix a op b) op' c
evalEquation (Infix (Infix a op b) op' c)
    | precedence op < precedence op' = evalEquation $ Infix a op (Infix b op' c)
evalEquation (Infix a op b) = apply op (evalEquation a) (evalEquation b) where
    apply Add      = (+)
    apply Subtract = (-)
    apply Multiply = (*)

-- Convert an equation into a string which can be shown to the user.
instance Show Equation where
    show (Val i) = show i
    show (Infix l op r) = unwords [show l, show op, show r]

instance Show Operator where
    show Add      = "+"
    show Subtract = "-"
    show Multiply = "*"

-- Match a list of equation with a list of answers from the user and
-- return a list of lines to output to the console.
match :: [Equation] -> [String] -> [String]
match (e:es) ~(a:as) = show e : continue where
    continue
        | "q" <- a = []
        | [(answer, "")] <- reads a
        , evalEquation e == answer = "Correct!"  : match es as
        | otherwise                = "Try again" : match (e:es) as

-- Utility function to generate an endless stream of samples from
-- a random variable.
samples :: MonadRandom (State s) => RVar t -> s -> [t]
samples var = evalState (fix $ (fmap (:) (sample var) <*>))

main :: IO ()
main = do
    header:answers <- lines <$> getContents
    let [minInt, maxInt] = read <$> words header
    questions <- samples (randomEquation minInt maxInt) <$> newPureMT
    putStr . unlines $ match questions answers

Handling operator precedence was the only slightly tricky thing in this one and
I consider all solution that side-step the problem by using some form of "eval"
to be cheating. ;)

(Except for the one which used C #defines to emulate "eval". That was very
clever.)

  • permalink
  • embed
  • save
  • give gold

[–]skeeto-9 8 7 points8 points9 points 4 years ago (1 child)

JavaScript. Wanting to avoid cheating with eval, it's messier than I had hoped.
The tricky part isn't representing the expression as a data structure but
printing it without any parenthesis, relying only on precedence.

function Operator(name, precedence, f) {
    this.name = name;
    this.precedence = precedence;
    this.call = f;
}

Operator.prototype.toString = function() { return this.name; };

var operators = {
    '+': new Operator('+', 0, function(a, b) { return a + b; }),
    '-': new Operator('-', 0, function(a, b) { return a - b; }),
    '*': new Operator('*', 1, function(a, b) { return a * b; })
};


function Expr(a, op, b) {
    this.a = a;
    this.op = op;
    this.b = b;
    this.negated = false;
}

Expr.prototype.negate = function() {
    this.negated ^= true;
    return this;
};

Expr.prototype.valueOf = function() {
    return this.op.call(this.a, this.b);
};

Expr.prototype.toString = function() {
    var op = this.op;
    if (this.negated && this.op.precedence === 0) {
        op = op.name === '+' ? operators['-'] : operators['+'];
    }
    return [this.a, op, this.b].join(' ');
};


function rand(min, max) {
    return Math.floor(min + Math.random() * (max - min));
}

function getOp(precedence) {
    var ops = Object.keys(operators).map(function(key) {
        return operators[key];
    });
    var subset = ops.filter(function(op) {
        return op.precedence >= precedence;
    });
    return subset[rand(0, subset.length)];
}

function generate(min, max) {
    var num = function() { return rand(min, max + 1); },
        middle = getOp(0),
        left = getOp(middle.precedence),
        right = getOp(middle.precedence),
        expr = new Expr(new Expr(num(), left, num()),
                        middle,
                        new Expr(num(), right, num()));
    if (middle.name === '-') expr.b.negate();
    return expr;
}

I skipped the interaction part, so here are some sample outputs:

[[0, 10], [4, 12], [10, 30]].map(function(range) {
    var expr = generate(range[0], range[1]);
    return [expr.toString(), expr.valueOf()];
});
// => [["10 - 2 + 9 + 6",    23],
//     ["10 + 11 + 6 * 8",   69],
//     ["28 * 29 + 12 - 30", 794]]

  • permalink
  • embed
  • save
  • give gold

[–]billy_tables 2 points3 points4 points 4 years ago (0 children)

Never seen x ^= true before - that's really nice!

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]Glassfish0 0 7 points8 points9 points 4 years ago (5 children)

Python3:

from random import choice
def start(min,max):
        op=['+','-','*']
        r=range(min,max+1)
        exit=False
        while(not exit):
                q='{0} {1} {2} {3} {4} {5} {6}'.format(choice(r),choice(op),choice(r),choice(op),choice(r),choice(op),choice(r))
                a=eval(q)
                correct=False
                while(not correct):
                        print(q)
                        i=input()
                        if i=='q':
                                exit=True
                                break
                        if int(i)==a:
                                print('Correct!')
                                correct=True
                        else:
                                print('Incorrect!')

  • permalink
  • embed
  • save
  • give gold

[–]hamsolo474 1 point2 points3 points 4 years ago (4 children)

Good use of format, i was thinking of doing that but couldn't remember off the
top of my head.

Very clean code.

Commenting because I cant upvote twice.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]Glassfish0 0 0 points1 point2 points 4 years ago (3 children)

Thanks :D

I'm still learning Python and i can't tell if my code is really Pythonesque.

Probably it would have been more elegant using functional programming

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]SurpriseTRex 2 points3 points4 points 4 years ago (0 children)

Based quite a lot on the python3 version above, it made for good practice! I've
never really used python3 syntax before.

import random as rand

def begin(minimum, maximum):
    ops = ['+', '-', '*', '/']
    numRange = range(minimum, maximum+1)
    running = 1
    score = 0
    attemptNum = 0

    while running:
    question = '{0} {1} {2} {3} {4} {5} {6}'.format(rand.choice(numRange), rand.choice(ops), rand.choice(numRange), rand.choice(ops), rand.choice(numRange), rand.choice(ops), rand.choice(numRange))
            print('')
            print(question)
            answer = eval(question)

            guess = input(">> ")

            if guess == answer:
                    print('Correct!')
                    score += 1
                    attemptNum += 1
            elif guess.lower() == 'q':
        running = 0
    else:
        print('No!')
        attemptNum += 1

    if attemptNum % 5 == 0:
        print('Your success rate: {0} correct answers over {1} questions.'.format(score, attemptNum))

minimum = int(input('Low-end of integer range: '))
maximum = int(input('High-end of integer range: '))

begin(minimum, maximum)

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]robin-gvx0 2 1 point2 points3 points 4 years ago (1 child)

In this case, I would personally have used

' '.join([choice(r),choice(op),choice(r),choice(op),choice(r),choice(op),choice(r)])`

or even

' '.join(([choice(r),choice(op)] * 4)[:-1])

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]Glassfish0 0 0 points1 point2 points 4 years ago (0 children)

Oh yeah, you're right.

Your second solution is way better than mine since i could have used the same
list four times, and join of course.

Thanks about that!

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]JerMenKoO0 0 6 points7 points8 points 4 years ago* (4 children)

python 3.x code-golfed:

a, b = map(int, input().split()); p = __builtins__.print
while 1:
    eq = ''.join(list(__import__('itertools').chain(*zip(["{}".format(__import__('random').randint(a, b)) for i in range(4)], list(sorted(['+', '-', '*'], key=lambda *args: __import__('random').random()))))) + ["{}".format(__import__('random').randint(a, b))])
    p("> {}".format(eq))
    while 1:
        _ = input()
        if _ == "{}".format(eval(eq)): p("welldone");break
        elif _ == "q": exit(p("quitting"))
        else: p("tryagain")

  • permalink
  • embed
  • save
  • give gold

[–][deleted] 1 point2 points3 points 4 years ago (3 children)

Care to explain what the heck is going on here? :P

  • permalink
  • embed
  • save
  • parent

[–]JerMenKoO0 0 3 points4 points5 points 4 years ago (0 children)

sorry, I have been recently very busy, are you still interested in an
explanation?

  • permalink
  • embed
  • save
  • parent
  • give gold

[–][deleted] 4 years ago* (1 child)

[deleted]

[–][deleted] 5 points6 points7 points 4 years ago (1 child)

Man, this challenge is harder than I thought.

I'm trying it in C++, and I can do it, but it ends up just being way longer
than it should and just an abomination.

  • permalink
  • embed
  • save

[–]nint221 2[S] 5 points6 points7 points 4 years ago (0 children)

I realized after implementing my own version that yeah... this wasn't an [Easy]
challenge because computing the result of a randomly generated equation is
non-trivial. My mistake; it happens :-/

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]nint221 2[S] 6 points7 points8 points 4 years ago* (2 children)

Sometimes you get it wrong, and have to rewrite a big part of your solution!
Just happened to me, so don't let it discourage others from trying the
challenge.

This is my initial attempt in C++, where I took a quick and hacky approach that
works most of the time, but not all! The specific error here is that by not
removing the elements that get multiplied together, adjacent add/subs
incorrectly refer to the wrong result. A specific equation that I fail to
compute for correctly is "0 + 6 * 7 * 7".

The more correct approach would of been to use an STL list, and pop out /
replace the appropriate elements that get computed. I tried to avoid any sort
of dynamic list, since that complicates code very quickly, but in this case
it's almost needed (unless I take a polish-notation approach, but that is a big
beefy solution to such a small challenge). I'll post that as soon as I'm done
programming it.

Edit: Just re-wrote it with a different approach to the solution-computation..

#include <stdlib.h>
#include <stdio.h>

int main()
{
    int min, max;
    char opChars[3] = { '+', '-', 'x' };
    scanf("%d %d", &min, &max);

    int consts[4];
    char ops[3];

    // Infinite loop unless user exists...
    bool correct = true;
    int correctResult = 0;
    while(true)
    {
        // If correct, generate new challenge
        if(correct)
        {
            for(int i = 0; i < 4; i++)
                consts[i] = min + rand() % (max - min + 1); // +1 since we're inclusive
            for(int i = 0; i < 3; i++)
                ops[i] = opChars[rand() % 3];

            // Compute the correct response... do all multiplication first; we could use shunting yard algo., but that's overkill
            int workspace[4] = { consts[0], consts[1], consts[2], consts[3] };

            // Do all multiplication first, storing the result to the right of the op
            for(int i = 0; i < 3; i++)
            {
                if(ops[i] == 'x')
                {
                    workspace[i + 1] *= workspace[i];
                    workspace[i] = workspace[i + 1];
                }
            }

            // Do all add/sub next, storing the results as a whole
            for(int i = 0; i < 3; i++)
            {
                if(ops[i] == '+')
                {
                    workspace[i + 1] += workspace[i];
                }
                else if(ops[i] == '-')
                {
                    workspace[i + 1] = workspace[i] - workspace[i + 1];
                }
                else
                {
                    // Subtle trick again: overwrite old mult. results to get the operand accesible to the next loop's add/sub
                    workspace[i + 1] = workspace[i];
                }
            }
            correctResult = workspace[3];
        }

        printf("%d %c %d %c %d %c %d\n", consts[0], ops[0], consts[1], ops[1], consts[2], ops[2], consts[3]);
        printf("Solution: %d\n", correctResult);

    }
}

  • permalink
  • embed
  • save
  • give gold

[–]oasisguy 1 point2 points3 points 4 years ago* (0 children)

I'm afraid of overlooking something blindingly obvious here, but wouldn't it
solve your problem if first you iterated through the expression backwards, and
eliminated multiplications by writing the result to the left of the "x"
operator, replacing the operator itself and the one operand on its right by a
"+ 0" ?

EDIT: ...or even iterating forward - see http://www.reddit.com/r/
dailyprogrammer/comments/1k7s7p/081313_challenge_135_easy_arithmetic_equations/
cbn3yt9 by /u/spfy.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]mips32 1 point2 points3 points 4 years ago* (0 children)

Correct me if I'm wrong but I think you can just solve for the multiplications
from left to right (placing the product in the operands before and after the
'x' operator like you have) and then just solve for '+' and '-' starting with
ops[2] and decrementing instead of starting with ops[0] and incrementing.

Edit: Scratch that, evaluating it right to left violates basic order of
operations.

Instead, I just moved all the multiplications as left as I could then evaluated
left to right like normal.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]BadArgumentHippie 6 points7 points8 points 4 years ago* (6 children)

Adhering to the output description (not the sample I/O, tho ;)...

from random import randint, choice
from sys import exit

low, hi = map(int, raw_input().split())
D = lambda: randint(low, hi)
O = lambda: choice(['*', '+', '-'])

while "you won't give me your love :-(":
    s = '%d %s %d %s %d %s %d' % (D(), O(), D(), O(), D(), O(), D())
    while True:
        print s
        i = raw_input()
        if i == 'q':
            exit(0)
        if eval(s) == eval(i):
            break
        print 'Try again'
    print 'Correct!'

Edit: Typo.

  • permalink
  • embed
  • save
  • give gold

[–]JerMenKoO0 0 0 points1 point2 points 4 years ago (5 children)

if you eval(s) before the second while loop, you will save evaling the whole
expression again and again when user enters a bad answer

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]BadArgumentHippie 0 points1 point2 points 4 years ago (4 children)

The performance gain from factoring out one of the two evals, is not something
I would spend a whole LOC on.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]JerMenKoO0 0 0 points1 point2 points 4 years ago (3 children)

eval is an expensive function call, so it would be better

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]BadArgumentHippie 1 point2 points3 points 4 years ago (2 children)

That is objective truth? Indeed, eval will usually be among the most expensive
features in any language supporting it (by orders of magnitude), but in this
case

  • this (very interactive) program will be sleeping 99...% of the time,
    waiting for user input, and the heavy-lifting in the eval-line will be
    practically negligible in all reasonable senses
  • we already need to do one eval, so we are basically in the eval-ballpark,
    asymptotically speaking, already. Hoisting out the one "constant" eval
    should at most yield a linear speedup by two.

I do not see hoisting the eval out as a "mandatory" optimization, and would
generally question such constant-factor improvements, if they weren't strictly
necessary to meet performance bounds.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]JerMenKoO0 0 0 points1 point2 points 4 years ago (1 child)

I agree with you. :) I just wanted to point out that it could be optimized.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]BadArgumentHippie 1 point2 points3 points 4 years ago (0 children)

That I agree with! Have a good day, kind Sir :-)

  • permalink
  • embed
  • save
  • parent
  • give gold

[–][deleted] 4 points5 points6 points 4 years ago (1 child)

My first DailyProgrammer challenge!

Java:

package arithmeticequations;

import java.util.Scanner;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;

public class ArithmeticEquations {

    private static int numCorrect;
    private static int[] numbers;
    private static double[] answers;
    private static char[] operators;
    private static long timeStart;
    private static long timeStop;
    private static String[] questions;
    private static Scanner stdin;

    private static ScriptEngineManager scrMan = new ScriptEngineManager();
    private static ScriptEngine scrEng = scrMan.getEngineByName("JavaScript");

    public static void main(String[] args) {

        int j = 0;
        numCorrect = 0;
        questions = new String[20];
        answers = new double[20];
        stdin = new Scanner(System.in);

        while(j < 20) {

            numbers = new int[4];
            operators = new char[3];
            for (int i = 0; i < numbers.length; i++)
                numbers[i] = (int)(Math.random()*10) + 1;
            for (int i = 0; i < operators.length; i++)
                operators[i] = getOperator();

            questions[j] = numbers[0] + " " + operators[0] + " " + numbers[1]
                    + " " + operators[1] + " " + numbers[2] + " " + operators[2]
                    + " " + numbers[3];
            try {
                answers[j] = (double)scrEng.eval(questions[j]);
            } catch (ScriptException ex) {
                System.out.println("FATAL ERROR: " + ex.getMessage());
                System.exit(0);
            }
            j++;

        }

        timeStart = System.nanoTime();
        for (int i = 0; i < 20; i++) {

            System.out.println(questions[i]);
            double ans = stdin.nextDouble();
            if (answers[i] == ans) {
                numCorrect++;
            }

        }

        timeStop = System.nanoTime();

        System.out.println("Number of correct questions: " + numCorrect +
                "\nTime Elapsed: " +
                (double)((timeStop - timeStart)/1000000000.0) + "secs");

    }

    public static char getOperator() {

        int operator = (int)(Math.random()*4);
        if (operator == 0) return '+';
        else if (operator == 1) return '-';
        else if (operator == 2) return '*';
        else return '/';

    }

}

Although not very elegant, it does seem to work.

  • permalink
  • embed
  • save

[–]JoePrau96 0 points1 point2 points 4 years ago (0 children)

I'm not getting a response for the correct/incorrect

The time taken was a good addition though.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]blimey1701 5 points6 points7 points 4 years ago (0 children)

Clojure! It took me a good long while to learn how to parse text and transform
it into an AST ;)

(ns arithmetic-evaluator)

(def ^:private operators ["*" "/" "+" "-"])

(defn- operator? [c] (boolean (some #(= c %) operators)))

(defn- split-on [operator coll]
  [(take-while #(not= operator %) coll)
   operator
   (rest (drop-while #(not= operator %) coll))])

(defn- highest-precedence-operation [coll]
  (let [match-op (fn [op] (filter #(= op %) coll))]
    (last
      (flatten
        (map match-op operators)))))

(defn compute [el]
  (if-not (coll? el)
    el
    (apply (first el) (map compute (rest el)))))

(defn- parse-token [t]
  (if (coll? t) (map parse-token t)
    (let [s (str t)]
      (cond
        (operator? s) (deref (resolve (symbol s)))
        :else (Integer. s)))))

(defn parse-tree [coll]
  (let [n     (count coll)
        pivot (highest-precedence-operation coll)]
    (if (= 1 n) (parse-token (first coll))
      (let [[left op right] (split-on pivot coll)]
        [(parse-token op) (parse-tree left) (parse-tree right)]))))

(defn tokenize [text]
  (clojure.string/split text #"\s+"))

(defn math-eval [str]
  (compute (parse-tree (tokenize str))))

(defn generate-equation
  ([] (generate-equation 0 10))
  ([from to]
   (let [int-count       4
         operators       ["*" "+" "-"]
         digits          (range from (inc to))
         generate-token  #(rand-nth (if (odd? %) operators digits))]
     (clojure.string/join " " (map generate-token (range (dec (* 2 int-count))))))))

(defn game
  ([] (game 0 10))
  ([from to]
   (loop [last-equation nil]
     (let [equation (or last-equation (generate-equation 0 10))]
       (do
         (println (str "> " equation))
         (let [input         (read-line)
               keep-playing? (not= "q" (clojure.string/lower-case input))
               answer        (math-eval equation)]
           (if keep-playing?
             (if (= answer
                    (try (Integer. input)
                      (catch Exception e (inc answer))))
               (do
                 (println "Correct!")
                 (recur nil))
               (do
                 (println "Incorrect!")
                 (recur equation)))
             (println "Goodbye!"))))))))

  • permalink
  • embed
  • save
  • give gold

[–]MATTtheSEAHAWK 3 points4 points5 points 4 years ago (2 children)

Excuse my language, but fuck me. I didn't see the no need for division. My
punishment for skimming is my attempt to write this abomination: http://
pastebin.com/yfms8G3f

I tried to do it without eval for fun, but that didn't work out. If it wasn't
12:45 and I didn't have work tomorrow, I would try it again, but not tonight.
Tonight is for sleep.

  • permalink
  • embed
  • save
  • give gold

[–]monumentshorts 0 points1 point2 points 4 years ago (1 child)

The no division is to save you from having to deal with divide by zero

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]MATTtheSEAHAWK 1 point2 points3 points 4 years ago (0 children)

Yeah, I know. I'll give this another shot sometime.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]killedbythegrue 3 points4 points5 points 4 years ago (1 child)

Hello everyone, I just stumbled across this subreddit and had some time on my
hands so have some Erlang.

-module(arith).
-compile(export_all).

%% Create a closure that will generate a random integer
%% within a defined, inclusive, range.
%%
genRand(Min,Max) ->
    Range = Max - Min + 1,
    Offset = Min - 1,
    fun() -> random:uniform(Range) + Offset end.


%% Evaluate the string as an Erlang statement and return the result
%%
evalStr(Str) ->
    {ok, Tok, _} = erl_scan:string(Str ++ "."),
    {ok, Exp} = erl_parse:parse_exprs(Tok),
    {value, Val, _} = erl_eval:exprs(Exp, []),
    Val.


%% Create a closure that will return a random arithmetic expression
%% and its solution.
%%
genExpr(Min,Max) ->
    Ops = dict:from_list([{1,"+"},{2,"-"},{3,"*"}]),
    RandVal = genRand(Min, Max),
    RandOpKey = genRand(1,3),
    fun() ->
        Expr = lists:concat([   RandVal(), " ",
                                dict:fetch(RandOpKey(),Ops), " ",
                                RandVal(), " ",
                                dict:fetch(RandOpKey(),Ops), " ",
                                RandVal(), " ",
                                dict:fetch(RandOpKey(),Ops), " ",
                                RandVal() ] ),
        Val = evalStr(Expr),
        {Expr, Val}
    end.


%% Check the user's answer against the value
%%
checkAnsw("q", _) -> quit;
checkAnsw(Ans, Val) ->
    try list_to_integer(Ans) =:= Val of
        true -> good;
        false -> wrong
    catch
        _:_ -> wrong
    end.


%% Main loop, run until the user quits
%%
loop(ExprFun, {Expr, Val}) ->
    {ok, [Ans]} = io:fread([Expr, " = " ], "~s"),
    case checkAnsw(Ans, Val) of
        good ->
            io:fwrite("Correct!\n"),
            loop(ExprFun, ExprFun());
        wrong ->
            io:fwrite("Incorrect... \n"),
            loop(ExprFun, {Expr, Val});
        _ -> ok
   end.

%% module entry point
metic(Min, Max) when Min >= 0, Min =< Max ->
    ExprFun = genExpr(Min,Max),
    loop(ExprFun, ExprFun() ).

And program output

Eshell V5.9.3.1  (abort with ^G)
1> c(arith).
{ok,arith}
2> arith:metic(2,5).
3 * 5 - 3 - 5 = 7
Correct!
4 - 4 + 2 * 2 = 6
Incorrect...
4 - 4 + 2 * 2 = 4
Correct!
4 + 3 - 2 - 3 = f
Incorrect...
4 + 3 - 2 - 3 = q
ok
3>

  • permalink
  • embed
  • save
  • give gold

[–]zengargoyle 0 points1 point2 points 4 years ago (0 children)

I wish I had more of a reason to use Erlang for something to get back into it a
bit deeper. I managed to hack together a custom user auth and a simple MUC
browser for an ejabbed server using a really minimal web framework (ERL or
something like that). All I can say about Erlang now is that the ejabberd XMPP
server I setup for $WORK has been chugging along with no software related
downtime for years and years.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]DetectiveWoofles 2 points3 points4 points 4 years ago* (0 children)

Python

EDIT: Fixed my original solution to fit in 80 chars per line.

from random import randint, seed

signs = [ "+", "-", "*" ]
while True:
    try:
        min_num, max_num = [int(x) for x in raw_input("Range? ").split()]
        break
    except ValueError:
        print "Not a valid number, try again!"
seed()
playing = True
while playing:
    eq = ""
    for i in range(0,4):
        eq = eq + str(randint(min_num, max_num))
        eq = eq + signs[randint(0,2)] if i != 3 else eq
    answer = eval(eq)
    correct = False
    while not correct:
        print eq
        try:
            guess = raw_input()
            numguess = int(guess)
            correct = answer == numguess
            print "Correct!" if correct else "Incorrect..."
        except ValueError:
            (playing,correct) = \
                (False,True) if guess.lower() == "q" else (True,True)
            print "Incorrect..." if guess.lower() != "q" else ""

  • permalink
  • embed
  • save
  • give gold

[–]Blackllama79 2 points3 points4 points 4 years ago (3 children)

It's in Java. Sort of. I'm a dirty cheater. Didn't feel doing the math
calculation myself so used javascript's eval instead XD.

import java.util.Random;
import java.util.Scanner;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
public class ArithmeticGame{
    public static void main(String[] args) throws ScriptException{
        int min, max, answer, input;
        Scanner scan = new Scanner(System.in);
        Random r = new Random();
        String[] signs = {"+", "-", "*"};
        int[] nums = new int[4];
        String[] operators = new String[3];
        int games = 0;
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine se = manager.getEngineByName("JavaScript");
        System.out.println("Enter min value:");
        min = scan.nextInt();
        System.out.println("Enter max value:");
        max = scan.nextInt();
        while(games < 20){
            for(int i = 0; i < nums.length; i++)
                nums[i] = r.nextInt(max + 1 - min) + min;
            for(int i = 0;i<operators.length;i++){
                operators[i] = signs[r.nextInt(3)];
            }
            System.out.println(nums[0]+operators[0]+nums[1]+operators[1]+nums[2]+operators[2]+nums[3]);
            answer = (int)((double) se.eval(nums[0]+operators[0]+nums[1]+operators[1]+nums[2]+operators[2]+nums[3]));
            input = scan.nextInt();
            while(input != answer){
                System.out.println("Try again!");
                input = scan.nextInt();
            }
            System.out.println("Correct!");
            games++;
        }
    }
}

  • permalink
  • embed
  • save
  • give gold

[–]froggert 1 point2 points3 points 4 years ago (1 child)

When you have a declaration, condition, and iteration, use a for loop! I make
this mistake too often.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]Blackllama79 0 points1 point2 points 4 years ago (0 children)

You're right, not sure why I chose to do that.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]Xredo 1 point2 points3 points 4 years ago (0 children)

I like how you just casually resort to Javascript to compute the expression's
result.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]Garth5689 2 points3 points4 points 4 years ago (0 children)

Matlab

range=input('Range?\n','s');
range=regexp(range,' ','split');
lowrange=str2num(range{1});
uprange=str2num(range{2});
operations = containers.Map({1,2,3}, {'*','-','+'});

while(true)
    numbers=randi([lowrange,uprange],[1,4]);
    opint=randi([1,3],[1,3]);
    equation=strcat(num2str(numbers(1)),...
                    num2str(operations(opint(1))),...
                    num2str(numbers(2)),...
                    num2str(operations(opint(2))),...
                    num2str(numbers(3)),...
                    num2str(operations(opint(3))),...
                    num2str(numbers(4)));
    disp(equation);
    answer=input('','s');
    if(answer=='q'|answer=='Q')
        break
    end
    if(eval(equation)==str2num(answer))
        disp('Correct!');
        disp('');
    else
        disp('Incorrect...');
        disp('');
    end
end

  • permalink
  • embed
  • save
  • give gold

[–][deleted] 4 years ago (1 child)

[deleted]

[–]diosio 0 points1 point2 points 4 years ago (0 children)

I borrowed these lines from you !

die "expected 'number number'" unless <STDIN> =~ /^(\d+)\s+(\d+)/;
my ($low, $high) = ($1, $2);

So much cleaner than my ifs :P

  • permalink
  • embed
  • save
  • give gold

[–]diosio 2 points3 points4 points 4 years ago (6 children)

Second perl solution! Thanks to /u/microwavecookietime for his way of verifying
the arguments :P

use POSIX ;
print "Please give number range (use Q to quit):\n";
die 'Usage : sum.pl <num> <num>' unless <STDIN> =~ m/^(\d)+\s+(\d)+$/;
($start, $end ) = ($1, $2);
@ops = qw(- + *) ;

while (1){
    $eq = gen();
    print "> $eq\n";
    $ans = <STDIN>;
    if ($ans =~ m/^-?\d+$/){
        print "Correct!\n" if ($ans == eval($eq));
    }elsif ($ans =~ m/q/i){
        exit ;
    }
}

sub gen(){
    $r = '' ;
    for(1 .. 4){
        $r .= ceil($start + rand($end - $start));
        $r .= $ops[-1 + ceil(rand(3))] unless $_ == 4;
    }
    return $r;
}

  • permalink
  • embed
  • save
  • give gold

[–]zengargoyle 1 point2 points3 points 4 years ago (3 children)

If your Perl is less than 5 years old or so... version 5.10 and later... You
can save yourself some hassle.

use v5.10;
# or
use feature 'say';

print "foo\n";
# vs
say "foo";

And

$ops[-1 + ceil(rand(3))]
# same as
$ops[rand(@ops)]

An @array in scalar context returns its length, and the [] will drop any
fractional part. I get using ceil(), but if you're only going to use one little
function that can be worked around.

$start + int(rand($end + 1 - $start))

And just for future reference, actually using \d in this way is fraught with
dangers. Perl's \d matches any Unicode digit.

my $is_digit = "\N{TIBETAN DIGIT ONE}";
say "is $is_digit a digit? " . ($is_digit =~ /\d/ ? 'yes' : 'no');

is ༡ a digit? yes

Give perldoc perlrecharclass a browse if you want to be prepared Unicode
strangeness.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]diosio 0 points1 point2 points 4 years ago (2 children)

in the beginning I used for the digits /^-?[0-9]+\s+[0-9]+$/ but \d seemed a
lot cleaner!

And since we are on the safety part of the comments, are we meant to be solving
these assuming that input provided will always be correct or not?

Cheers for the comments!

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]zengargoyle 0 points1 point2 points 4 years ago (1 child)

I've only done a few of these challenges and the first one said something like
'assume input is valid', so I haven't really been checking.

For numbers, a common thing is

use Scalar::Util qw(looks_like_number);
for (qw( 1 -1 1.4 -1.4 foo 123foo)) {
  say "$_ ", looks_like_number($_) ? "yes" : "no";
}

1 yes
-1 yes
1.4 yes
-1.4 yes
foo no
123foo no

Scalar::Util is a core module.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]diosio 0 points1 point2 points 4 years ago (0 children)

cheers for that, it looks very useful ! I haven't delved deep enough into
perl's modules I am afraid :/

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]catchingExceptions 0 points1 point2 points 4 years ago (1 child)

I didn't think of using unless to stop the extra operator from printing. Much
neater than tacking an extra concatination after the for loop.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]diosio 0 points1 point2 points 4 years ago (0 children)

wasn't my idea, I borrowed the style from microwavecookietime's perl solution!

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]hamsolo474 2 points3 points4 points 4 years ago* (0 children)

Yet another python solution, its not pretty but it gets the job done. I might
refine it a bit in the morning.

BTW since when is eval cheating!

import random

def gen_problem():
    number=[random.randrange(intRange[0],intRange[1]), random.randrange(intRange[0],intRange[1]), random.randrange(intRange[0],intRange[1]), random.randrange(intRange[0],intRange[1])]
    output=[number[0],operators[random.randrange(3)],number[1],operators[random.randrange(3)],number[2],operators[random.randrange(3)],number[3]]
    output=str(output).replace(',',"")
    output=output.replace("'","")
    output=output.strip("[|]")
    return output, eval(output)

text=''
operators=['+','-','*']
frun=1

while True:
    if frun:
        try:
            intRange=input().split()
            for i, j in enumerate(intRange):
                intRange[i]=int(j)
            frun=0
        except ValueError:
            print("NaN")

    question=gen_problem()
    text=input(str(question[0])+": ")
    try:
        if int(text) == question[1]:
            print("Correct!")
        else:
            print("Incorrect!")

    except ValueError:
        if text.lower() != 'q':
            print('NaN!')
        else:
            break

print("Quitting!")

P.S. I'm open to feed back this is my first submission, atm i am thinking of
redefining number with a list comprehension (Inspired by /u/toodim, operators
with a string (inspired by /u/missedtheplane), that whole output thing with
format (inspired by /u/Glassfish)

  • permalink
  • embed
  • save
  • give gold

[–]MatthewASobol 2 points3 points4 points 4 years ago (0 children)

Java

/* ArithmeticGame.java */

import java.util.Scanner;

public class ArithmeticGame
{
    public static void main(String args[])
    {
        Scanner sc = new Scanner(System.in);
        Problem aProblem;
        String uAnswer = new String();
        int games = 0;
        int min = sc.nextInt();
        int max = sc.nextInt();

        for (int games = 0; games < 20; games++)
        {
            aProblem = new Problem(min, max);
            System.out.println(">" + aProblem.asText);
            uAnswer = sc.next();
            while (Integer.parseInt(uAnswer) != aProblem.solution)
            {
                System.out.println("Incorrect...");
                System.out.println(">" + aProblem.asText);
                uAnswer = sc.next();
            }
            System.out.println("Correct!");
        }
    }
}


/* Problem.java */

import java.util.Random;
import java.util.Deque;
import java.util.ArrayDeque;

public class Problem
{
    public final String OPERATORS[] = {"*", "+", "-"};
    public final Random RANDOM = new Random();
    public int solution;
    public String asText;

    public Problem(int min, int max)
    {
        int operand;
        String asText = new String();
        int solution = 0;
        String operator;
        boolean negativeNext = false;
        boolean multiplyNext = false;
        Deque<Integer> stack = new ArrayDeque<>();
        for (int i = 0; i < 7; i++)
        {
            if (i % 2 == 0)
            {
                operand = RANDOM.nextInt(max-min)+min;
                asText = asText + operand + " ";
                if (negativeNext) // Preceeded by "-"
                {
                    operand *= -1;
                    negativeNext = false;
                }
                if (multiplyNext) // Preceeded by "*"
                {
                    operand = (stack.removeFirst() * operand);
                    multiplyNext = false;
                }
                stack.addFirst(operand);
            }
            else
            {
                operator = OPERATORS[RANDOM.nextInt(3)];

                if (operator.equals("*"))
                {
                    multiplyNext = true;
                }
                if (operator.equals("-"))
                {
                    negativeNext = true;
                }
                asText = asText + operator + " ";
            }
        }

        for (Integer num : stack)
        {
            solution += num;
        }

        this.solution = solution;
        this.asText = asText;
    }
}

  • permalink
  • embed
  • save
  • give gold

[–]Rhinoceros_Party 2 points3 points4 points 4 years ago* (2 children)

First time poster. Took 236 lines since I did some tricks to make it scalable.
I got to use enums, and that's always fun. Critiques welcome. EDIT: Using Java.

package org.reddit.rhinocerosparty.easy;

import java.io.Console;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Random;

/**
 * Based on the problem found here:
 * http://www.reddit.com/r/dailyprogrammer/comments
 * /1k7s7p/081313_challenge_135_easy_arithmetic_equations/ problem submitted on
 * August 13, 2013
 *
 * @author Rhinoceros_Party
 *
 */
public class ArithmeticEquations {
  private static final Random RANDOM = new Random();
  private static final boolean DEBUG = false;

  private List<Operation> operations;
  private List<Integer> operands;
  private int lowerBound = 0;
  private int upperBound = 0;
  private Difficulty d;
  private int answer = 0;

  private static enum Difficulty {
    EASY(3);

    private int numOperations = 1;

    private Difficulty(int numOperations) {
      this.numOperations = numOperations;
    }

    public int getNumOperations() {
      return this.numOperations;
    }
  }

  private static enum Operation {
    ADDITION("+"), SUBTRACTION("-"), MULTIPLICATION("*");

    private String symbol;

    public String toString() {
      return " " + symbol + " ";
    }

    private Operation(String symbol) {
      this.symbol = symbol;
    }

    // caching the array of operations to be accessed easily during random calls
    private static final List<Operation> VALUES = Collections
        .unmodifiableList(Arrays.asList(values()));
    private static final int SIZE = VALUES.size();
    private static final Random RANDOM = new Random();

    public static Operation getRandomOperation() {
      return VALUES.get(RANDOM.nextInt(SIZE));
    }

    private static int solve(Operation o, int a, int b) {
      int ret = 0;

      switch (o) {
      case MULTIPLICATION:
        ret = a * b;
        break;
      case ADDITION:
        ret = a + b;
        break;
      case SUBTRACTION:
        ret = a - b;
        break;
      }

      return ret;
    }
  }

  public static ArithmeticEquations getArithmeticEquations(String lower,
      String upper) {
    // we should do something graceful if they enter invalid numbers
    return new ArithmeticEquations(Integer.parseInt(lower),
        Integer.parseInt(upper));
  }

  public static void main(String[] args) {
    ArithmeticEquations ae;
    // apparently you can't get a console in Eclipse, so you'll have to
    // run this from command line
    Console console = System.console();
    String input = console.readLine("Enter parameter range:"
        + System.lineSeparator());
    String[] bounds = input.split(" ");
    String output = "";

    ae = getArithmeticEquations(bounds[0], bounds[1]);
    while (true) {
      input = console.readLine(ae.toString() + System.lineSeparator());
      output = ae.guess(input);
      if (output == null) {
        System.exit(0);
      }
      System.out.println(output);
    }
  }

  /**
   * tells the user whether their guess was correct or not. a return value of
   * null signals that the program should exit
   *
   * @param input
   * @return
   */
  public String guess(String input) {
    String ret = "";

    if ("q".equalsIgnoreCase(input)) {
      ret = null;
    } else {
      if (Integer.parseInt(input) == this.answer) {
        ret = "Correct!";
        generateEquation();
      } else {
        ret = "Try Again";
      }
    }

    return ret;
  }

  private ArithmeticEquations(int lower, int upper) {
    if (lower > upper) {
      int temp = lower;
      lower = upper;
      upper = temp;
    }

    this.lowerBound = lower;
    this.upperBound = upper;
    this.d = Difficulty.EASY;
    this.operations = new ArrayList<Operation>();
    this.operands = new ArrayList<Integer>();

    generateEquation();
  }

  private int getRandomNumber() {
    // this math and the math on the return line are based around the bounds
    // being inclusive, while the random function's parameter being exclusive
    // and also generating between 0 and the parameter
    int ret = RANDOM.nextInt(this.upperBound - this.lowerBound + 1);

    return ret + this.lowerBound;
  }

  private void generateEquation() {
    this.operations.clear();
    this.operands.clear();

    this.operands.add(getRandomNumber());
    for (int i = 0; i < this.d.getNumOperations(); i++) {
      this.operands.add(getRandomNumber());
      this.operations.add(Operation.getRandomOperation());
    }

    this.answer = solve(this);
  }

  private static int solve(ArithmeticEquations ae) {
    int ret = 0;
    List<Operation> operations = new ArrayList<Operation>(ae.getOperations());
    List<Integer> operands = new ArrayList<Integer>(ae.getOperands());

    // Collections.copy(operations, ae.getOperations());
    // Collections.copy(operands, ae.getOperands());

    // PEMDAS time!
    // first pass, multiplication
    for (int i = 0; i < operations.size(); i++) {
      if (operations.get(i).equals(Operation.MULTIPLICATION)) {
        operands.set(
            i,
            Operation.solve(operations.get(i), operands.get(i),
                operands.get(i + 1)));
        operands.remove(i + 1);
        operations.remove(i);
        i--;
      }
    }

    // only addition and subtraction left
    while (operations.size() > 0) {
      operands.set(0,
          Operation.solve(operations.get(0), operands.get(0), operands.get(1)));
      operands.remove(1);
      operations.remove(0);
    }

    ret = operands.get(0);

    return ret;
  }

  public String toString() {
    String ret = "";

    if (this.operands.size() > 0) {
      ret += this.operands.get(0);
    }

    for (int i = 0; i < this.operations.size(); i++) {
      ret += this.operations.get(i).toString();
      ret += this.operands.get(i + 1);
    }

    if (DEBUG) {
      ret += " solution = " + this.answer;
    }

    return ret;
  }

  public List<Operation> getOperations() {
    return operations;
  }

  public List<Integer> getOperands() {
    return operands;
  }
}

  • permalink
  • embed
  • save
  • give gold

[–]nint221 2[S] 1 point2 points3 points 4 years ago (1 child)

Whoa whoa whoa, since when does Java allow enums? I'm embarrassed for/of
myself.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]Rhinoceros_Party 1 point2 points3 points 4 years ago* (0 children)

Since at least when I was in college, and I graduated college in 2007. :D

I like to use them for switch statements since switch statements execute faster
than long if else statements, and switch can only operate on primitives or
enums.

EDIT: Apparently in JE 7, switch statements can now be used on Strings. I had
no idea.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]spacepotatoe[🍰] 2 points3 points4 points 4 years ago (0 children)

Not very elegant, and nowhere near as impressive as Maiddog's solution, but
here is my working C solution :)

include <stdio.h>

#include <stdlib.h>
#include <math.h>
#include <string.h>

int main(int argc, char *argv[])
{
    srand(atoi(argv[1]));

    int total_value, mult_count = 0, is_negative = 0, i, j, k, l,m;
    int bottom_range, upper_range, print_val;
    int values[7] = {0}, print_array[7] = {0}, array_length, has_exited = 0;
    int guess = '\0';

    while(has_exited == 0){
        if(scanf("%d %d", &bottom_range, &upper_range) != 2){
            break;
        }
        total_value = 0;
        print_val = 1;
        array_length = 7;
        for(i = 0; i <= 6; i+= 2){
            is_negative = rand()%2;
            values[i] = rand()%upper_range+1;
            if(is_negative == 1 && bottom_range < 0){
                values[i] = values[i] * -1;
            }
            print_array[i] = values[i];
        }

        for(m = 1; m <= 5 - 2*mult_count; m+= 2){
            values[m] = rand()%3;
            print_array[print_val] = values[m];

            if(values[m] == 2){

                values[m- 1] = values[m - 1] * values [m + 1];
                for(j =  m + 2; j < 7; j++){
                    values[j - 2] = values[j];
                }
                array_length -= 2;
                m -= 2;
                mult_count += 1;
            }
            print_val += 2;
        }

        total_value = values[0];

        for(k = 1; k < array_length - 1; k+= 2)
        {
            switch(values[k]){
            case 0: total_value = total_value + values[k + 1];
                continue;
            case 1: total_value = total_value - values[k + 1];
                continue;
            }
        }

        for(l = 0; l < 7; l++)
        {

            if(l%2 == 0)
            {
                printf(" %d ", print_array[l]);
            }

            else{

                switch(print_array[l]){
                case 0: printf(" + ");
                    continue;
                case 1: printf(" - ");
                    continue;
                case 2: printf(" * ");
                    continue;
                }
            }
        }

        printf("\n");
        scanf("%d", &guess);

        if(total_value == guess){
            printf("CORRECT!\n");
        }

        if(total_value != guess ){
            printf("NOPE!\n");
        }
    }
    return 0;
}

  • permalink
  • embed
  • save
  • give gold

[–]CaptainCaffeine 2 points3 points4 points 4 years ago (0 children)

Alright here's my code, written in python 3.3. Did it without using eval(), and
also my first time posting a solution to dailyprogrammer, criticisms are
welcome!

#!/usr/bin/python3

import random

op_table = {'*': lambda x,y: x*y,
            '-': lambda x,y: x-y,
            '+': lambda x,y: x+y}

def operations(op, expr):
    try:
        while True:
            op_place = expr.index(op)
            expr.pop(op_place)
            result = op_table[op](expr.pop(op_place-1), expr.pop(op_place-1))
            expr.insert(op_place-1, result)
    except ValueError:
        pass
    return expr


def math_eq(lower, upper):
    rng = random.Random()
    ops = ('*', '-', '+')
    expr = []
    for i in range(4):
        expr.append(rng.randrange(lower, upper))
        if i != 3:
            expr.append(rng.choice(ops))
    original = ""
    for ele in expr:
        original += str(ele) + " "
    answer = 0
    for op in ops:
        expr = operations(op, expr)
    return expr[0], original


range_request = """Hello! Please type in two numbers separated by a space
to define the range you want the random constants to be in.\n"""


def main():
    str_range = input(range_request).split()
    lower, upper = (int(i) for i in str_range)
    while True:
        answer, equation = math_eq(lower, upper)
        while True:
            print(equation)
            response = input("Answer: ")
            if response.lower() == "q":
                return
            elif not response.isdigit():
                print("Please type in an integer, or type 'q' to exit")
            elif int(response) == answer:
                print("Correct! Here's another:")
                break
            else:
                print("Incorrect.")


main()

  • permalink
  • embed
  • save
  • give gold

[–]keithnorm 2 points3 points4 points 4 years ago (0 children)

Implemented a really basic version of the shunting yard algorithm in C.

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <time.h>

void print_equation(char *arr[], int len) {
  for (int i = 0; i < len - 1; i++) {
    printf("%s ", arr[i]);
  }
  printf("%s: ", arr[len - 1]);
}

int solve_polish(char *equation[], int len) {
  int intStack[10];
  signed int stackPointer = -1;
  stackPointer = -1;

  for (int i = 0; i < len; i++) {
    char *a = equation[i];
    if (atoi(a)) {
      // a is num, push onto stack
      stackPointer++;
      intStack[stackPointer] = atoi(a);
    }
    else {
      // a is op
      char op = *a;
      int secondNum = intStack[stackPointer--];
      int firstNum = intStack[stackPointer--];
      switch (op) {
        case '+':
          intStack[++stackPointer] = firstNum + secondNum;
          break;
        case '-':
          intStack[++stackPointer] = firstNum - secondNum;
          break;
        case '*':
          intStack[++stackPointer] = firstNum * secondNum;
          break;
        default:
          break;
      }
    }
  }
  return intStack[0];
}

void shunting_yard(char *equation[], int len, char *output[]) {
// given an infix equation like:
//  char *equation[] = {"25", "-", "5", "*", "4"};
// sets output to reverse polish notation:
//  {"25", "5", "4", "*", "-"}
  char opStack[100];
  int opStackPointer = -1;
  char *outputQueue[len];
  int outputQueueLength = 0;
  char *buffer;
  for (int i = 0; i < len; i++) {
    char *a = equation[i];
    if (atoi(a)) {
      // its a number, add it to the queue
      outputQueue[outputQueueLength] = a;
      outputQueueLength++;
    } else {
      // assume its an operator - no bracket support yet
      char op = *a;
      char topStack = opStack[opStackPointer];
      while ((topStack == '*' && (op == '+' || op == '-')) || (topStack == '-' && (op == '+' || op == '-'))) {
        buffer = malloc(1);
        sprintf(buffer, "%c", topStack);
        outputQueue[outputQueueLength] = buffer;
        outputQueueLength++;
        topStack = opStack[--opStackPointer];
      }
      opStack[++opStackPointer] = op;
    }
  }

  for (; opStackPointer > -1; opStackPointer--) {
    char op = opStack[opStackPointer];
    buffer = malloc(1);
    sprintf(buffer, "%c", op);
    outputQueue[outputQueueLength] = buffer;
    outputQueueLength++;
  }
  for (int i = 0; i < outputQueueLength; i++) {
    output[i] = outputQueue[i];
  }
  free(buffer);
}

int random_in_range (unsigned int min, unsigned int max) {
  return ( rand() % (max - min + 1) ) + min;
}

void ask_question(int low, int high) {
  char *buf;
  char *equation[10];
  char *ops[] = {"+", "-", "*"};
  for (int i = 0; i <= 7; i++) {
    // if i is even, pick a number, if odd, pick an operation
    if (i % 2 == 0) {
      int digit = random_in_range(low, high);
      // get number of digits in digit, to malloc the right amount
      int nDigits = floor(log10(abs(digit))) + 1;
      if (nDigits <= 0) {
        nDigits = 1;
      }
      buf = malloc(nDigits * sizeof(char));
      sprintf(buf, "%d", digit);
      equation[i] = buf;
    }
    else {
      equation[i] = ops[random_in_range(0, 2)];
    }
  }
  print_equation(equation, 7);
  char *shunting_yard_output[7];
  shunting_yard(equation, 7, shunting_yard_output);
//  to make sure shunting yard equation was generated correctly
//  printarr(shunting_yard_output, 7);
  int solution = solve_polish(shunting_yard_output, 7);
  char answerChar[100];
  scanf("%s", answerChar);
  if (*answerChar == 'q') {
    printf("Bye! Thanks for stopping by! \n");
    exit(0);
  }
  int answer = atoi(answerChar);
  if (answer == solution) {
    printf("you rawk! \n");
  }
  else {
    printf("you are no smart... answer is %d \n", solution);
  }
  free(buf);
  ask_question(low, high);
}

void start() {
  int low, high;
  printf("Enter a number range: ");
  scanf("%d %d", &low, &high);
  ask_question(low, high);
}

int main(int argc, const char * argv[]) {
  srand((unsigned int)time(NULL));
  start();
  return 0;
}

  • permalink
  • embed
  • save
  • give gold

[–]chunes1 2 2 points3 points4 points 4 years ago* (0 children)

I hate this exercise. It took me hours and hours of hair-pulling to solve this.

Java:

package dailyprogrammer;

import java.util.Random;
import java.util.Scanner;

public class Easy135 {

    public static void main(String[] args) {
        Random rand = new Random();
        int min = Integer.parseInt(args[0]);
        int range = Integer.parseInt(args[1]) - min + 1;
        Scanner s = new Scanner(System.in);
        String estr = generateQuestion(min, range, rand);
        String ans = parseAnswer(estr);
        String input = "";

        while (true) {
            System.out.print(estr + "\n> ");
            input = s.nextLine();
            if (input.equalsIgnoreCase("q"))
                break;
            else if (input.equals(ans)) {
                System.out.println("Correct!");
                estr = generateQuestion(min, range, rand);
                ans = parseAnswer(estr);
            }
            else
                System.out.println("Incorrect...");
        }
        s.close();
    }

    //return the answer to the given question.
    private static String parseAnswer(String estr) {
        String e = estr;
        for (int i = 0; i < 3; i++)
            e = scanForOp(e, "*");
        for (int i = 0; i < 3; i++)
            e = scanForOp(e, "+-");
        return e.trim();
    }

    //returns true if the "-" substring at index b indicates
    //subtraction.
    //returns false if it indicates a negative number.
    private static boolean checkForCorrectness(int b, String exp) {
        if (b > 0) {
            char a = exp.charAt(b - 1);
            char c = exp.charAt(b + 1);
            return c == ' ' && a == ' ';
        }
        return false;
    }

    //returns the index in exp of the first instance of a
    //subtraction sign.
    private static int properNegIndex(String exp) {
        for (int i = 0; i < exp.length(); i++) {
            if (exp.charAt(i) == '-' && checkForCorrectness(i, exp)) {
                return i;
            }
        }
        return -9999;
    }

    //returns a String after evaulating exp for the first
    //valid operator given by op.
    private static String scanForOp(String exp, String op) {

        int index = 0;

        if (op.equals("*"))
            index = exp.indexOf(op);
        else {
            int a = exp.indexOf("+");
            int b = properNegIndex(exp);
            if (a == -1 && b == -1)
                index = -1;
            else if (a == -1 && b > -1)
                index = b;
            else if (a != -1 && b == -1)
                index = a;
            else
                if (b > -1)
                    index = Math.min(a, b);
                else
                    index = a;
        }

        String estr = "";
        if (index == -1)
            estr = exp;
        else {

            op = exp.charAt(index)+"";

            String[] tokens = exp.split("\\s+");
            int zindex = -2000;
            for (int i = 0; i < tokens.length; i++)
                if (tokens[i].equals(op)) {
                    zindex = i;
                    break;
                }

            int z = 0;
            int l = Integer.parseInt(tokens[zindex - 1]);
            int r = Integer.parseInt(tokens[zindex + 1]);
            switch (op) {
            case "*" : z = l * r;
            break;
            case "+" : z = l + r;
            break;
            case "-" : z = l - r;
            }
            estr = exp.substring(0, index - 1 - tokens[zindex-1].length()) + z + exp.substring(index + 2 + tokens[zindex+1].length(), exp.length());
        }
        return estr;
    }

    //generate a random question
    private static String generateQuestion(int min, int range, Random rand) {
        String estr = "";
        for (int i = 0; i < 4; i++) {
            estr += rand.nextInt(range) + min + " ";
            if (i != 3)
                estr += getRandomOperator(rand);
        }
        return estr;
    }

    //return a random operator
    private static String getRandomOperator(Random r) {
        switch(r.nextInt(3)) {
        case 0: return "+ ";
        case 1: return "- ";
        case 2: return "* ";
        default: return null;
        }
    }
}

  • permalink
  • embed
  • save
  • give gold

[–]Edward_H 2 points3 points4 points 4 years ago (0 children)

My rather belated COBOL solution:

       IDENTIFICATION DIVISION.
       PROGRAM-ID. maths-equations.

       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01  Operators               PIC X(3) VALUE "+-*".
       78  Ignore-Val              VALUE -9999999.

       01  input-str               PIC X(20).
           88  quit                VALUE "Q", "q".

       01  min-str                 PIC X(20).
       01  max-str                 PIC X(20).

       01  min-num                 PIC S9(7).
       01  max-num                 PIC S9(7).

       01  ops                     PIC X OCCURS 3.
       01  nums                    PIC S9(7) OCCURS 4 TIMES.

       01  i                       PIC 9(5).

       01  seed                    PIC 9(8).
       01  rand-num                PIC 9(5).

       01  prev-val                PIC 9(5).

       01  edited-num              PIC -9(7).
       01  offset                  PIC 9(5) VALUE 1.
       01  equation-str            PIC X(50).

       01  user-answer             PIC S9(7).
       01  answer                  PIC S9(7).

       PROCEDURE DIVISION.
       main-line.
           ACCEPT input-str
           UNSTRING input-str DELIMITED BY SPACES INTO min-str, max-str
           MOVE FUNCTION NUMVAL(min-str) TO min-num
           MOVE FUNCTION NUMVAL(max-str) TO max-num

           PERFORM UNTIL quit
               PERFORM generate-equation
               PERFORM write-equation-str
               PERFORM eval-equation

               PERFORM get-answer WITH TEST AFTER
                   UNTIL user-answer = answer OR quit
           END-PERFORM

           GOBACK
           .
       generate-equation.
           *> Seed RANDOM
           MOVE FUNCTION CURRENT-DATE (9:8) TO seed
           MOVE FUNCTION RANDOM(seed) TO rand-num

           *> Choose the operators
           PERFORM VARYING i FROM 1 BY 1 UNTIL 3 < i
               COMPUTE rand-num = (FUNCTION RANDOM * 3) + 1
               MOVE Operators (rand-num:1) TO ops (i)
           END-PERFORM

           *> Choose the numbers
           PERFORM VARYING i FROM 1 BY  1 UNTIL 4 < i
               COMPUTE nums (i)  =
                   min-num + (FUNCTION RANDOM * (max-num - min-num))
           END-PERFORM
           .
       write-equation-str.
           INITIALIZE offset, equation-str ALL TO VALUE
           PERFORM VARYING i FROM 1 BY 1 UNTIL 4 < i
               MOVE nums (i) to edited-num
               MOVE edited-num TO equation-str (offset:)

               IF nums (i) IS POSITIVE
                   MOVE "+" TO equation-str (offset:1)
               END-IF

               ADD 8 TO offset

               IF i < 4
                   MOVE " " TO equation-str (offset:)
                   MOVE ops (i) TO equation-str (offset + 1:)
                   MOVE " " TO equation-str (offset + 2:)
                   ADD 3 TO offset
               END-IF
           END-PERFORM
           .
       eval-equation.
           *> Parse multiplication
           PERFORM VARYING i FROM 1 BY 1 UNTIL 3 < i
               IF ops (i) = "*"
                   PERFORM find-prev-val
                   MULTIPLY nums (i + 1) BY nums (prev-val)
                   MOVE Ignore-Val TO nums (i + 1)
               END-IF
           END-PERFORM

           *> Parse addition and subtraction
           PERFORM VARYING i FROM 1 BY 1 UNTIL 3 < i
               IF ops (i) = "*"
                   EXIT PERFORM CYCLE
               END-IF

               PERFORM find-prev-val

               EVALUATE ops (i)
                   WHEN "+"
                       ADD nums (i + 1) TO nums (prev-val)
                   WHEN "-"
                       SUBTRACT nums (i + 1) FROM nums (prev-val)
               END-EVALUATE

               MOVE Ignore-Val TO nums (i + 1)
           END-PERFORM

           MOVE nums (1) TO answer
           .
       find-prev-val.
           MOVE i TO prev-val
           PERFORM UNTIL nums (prev-val) NOT = Ignore-Val
               SUBTRACT 1 FROM prev-val
           END-PERFORM
           .
       get-answer.
           DISPLAY equation-str
           ACCEPT input-str

           IF quit
               EXIT PARAGRAPH
           END-IF

           MOVE FUNCTION NUMVAL(input-str) TO user-answer
           IF user-answer = answer
               DISPLAY "Correct!"
           ELSE
               DISPLAY "Try Again."
           END-IF
           .

  • permalink
  • embed
  • save
  • give gold

[–]7f0b 2 points3 points4 points 4 years ago (0 children)

Solution in PHP with comments and HTML form. I use eval to get the answer to
equation, but equation is fully known and generated server side with no user
input, so it should be safe.

// Game stores state in session since PHP is not persistent in the traditional sense
session_start();


class Arithmetic
{
    // Build game state
    public function __construct()
    {
        if(!isset($_SESSION['started']))  $_SESSION['started'] = false;
        if(!isset($_SESSION['min']))      $_SESSION['min'] = 0;
        if(!isset($_SESSION['max']))      $_SESSION['max'] = 0;
        if(!isset($_SESSION['equation'])) $_SESSION['equation'] = '';
        if(!isset($_SESSION['answer']))   $_SESSION['answer'] = 0;
        if(!isset($_SESSION['output']))   $_SESSION['output'] = '';
    }

    // User input is handled by this function
    public function input($input)
    {
        // Record user input
        $_SESSION['output'].= $input."\n";

        // User quits - reset state of game
        if($input == 'q')
        {
            $this->resetGame();
            return true;
        }

        // Game has started - input should be a single integer
        if($_SESSION['started'])
        {
            // Check if answer is correct
            if((int)$input == (int)$_SESSION['answer'])
            {
                $_SESSION['output'].= "> Correct!\n";
                $this->generateNewEquation();
                $_SESSION['output'].= "> ".$_SESSION['equation']."\n";
            }
            else
            {
                $_SESSION['output'].= "> Incorrect!\n";
                $_SESSION['output'].= "> ".$_SESSION['equation']."\n";
            }
            return true;
        }

        // Game has not started - input should be a string with two integers separated by a space
        else
        {
            // Get the two integers from the string
            $values = explode(' ', $input);

            // Error if explode failed
            if(!$values)
            {
                $_SESSION['output'].= "> Incorrect! Please enter two integers separated by a space.\n";
                return false;
            }

            // Make sure result contains two values
            if(count($values) != 2)
            {
                $_SESSION['output'].= "> Incorrect! Please enter two integers separated by a space.\n";
                return false;
            }

            // Cast values as integers
            $values[0] = (int)$values[0];
            $values[1] = (int)$values[1];

            // Make sure first value is less than second value
            if($values[0] >= $values[1])
            {
                $_SESSION['output'].= "> Incorrect! First integer must be less than second integer.\n";
                return false;
            }

            // Set min and max values
            $_SESSION['min'] = $values[0];
            $_SESSION['max'] = $values[1];

            // Generate new equation and output it
            $this->generateNewEquation();
            $_SESSION['output'].= "> ".$_SESSION['equation']."\n";
            $_SESSION['started'] = true;
            return true;
        }
    }

    private function generateNewEquation()
    {
        // Reset equation and answer
        $_SESSION['equation'] = '';
        $_SESSION['answer'] = 0;

        // Signs that can be used
        $signs = array('+', '-', '*');

        // Build new equation
        for($i = 0; $i < 4; $i ++)
        {
            // Get random number and sign
            $randSign = $signs[mt_rand(0, 2)];
            $randNum = mt_rand($_SESSION['min'], $_SESSION['max']);

            // Add to equation
            if($i > 0) $_SESSION['equation'].= ' '.$randSign.' ';
            $_SESSION['equation'].= $randNum;
        }

        // Get answer using eval
        $_SESSION['answer'] = eval('return '.$_SESSION['equation'].';');
    }

    // Resets all of the game's values
    private function resetGame()
    {
        $_SESSION['started'] = false;
        $_SESSION['min'] = 0;
        $_SESSION['max'] = 0;
        $_SESSION['equation'] = '';
        $_SESSION['answer'] = 0;
        $_SESSION['output'] = '';
    }
}


$game = new Arithmetic();


// Get user's input and run it through the game
if(isset($_GET['input']))
{
    $game->input($_GET['input']);
    header('Location: /arithmetic');
    exit;
}


// HTML form for user to interact with
echo '<!DOCTYPE html><html><head><title>Arithmetic</title></head><body>'
. '<form name="fo" method="get">Input: <input name="input" type="text">'
. '<input type="submit" value="Submit"></form><br>'
. '<script>document.fo.input.focus()</script>'
. '<textarea style="width:700px;height:500px">'.$_SESSION['output'].'</textarea>'
. '</body></html>';

  • permalink
  • embed
  • save
  • give gold

[–]mips32 2 points3 points4 points 4 years ago (0 children)

C99

// #include files
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// #define
#define MAXCHAR 128

int main(int argc, char* argv[]){

    int operands[4];                            // Holds the integer operands of the equation.
    int compAns;                                // Computer answer to the equation.
    int userAns;                                // User answer to the equation.
    int upperBound;                             // Upper and lower bounds for the
                                                //  range of numbers in the equation.
    int lowerBound;
    char operators[3] = {'+', '-', '*'};        // Holds the operators that can be found
                                                //  in an equation.
    char ops[3];                                // Holds the operators of the equation.
    char eqtn[MAXCHAR];                         // Holds the equation.
    char userResponse[MAXCHAR];                 // User either enters a number or 'q'/'Q'.


    scanf("%d %d", &lowerBound, &upperBound);   // Can expect the user range will be given in
                                                //  the format "%d %d".

    do{
        for(int i = 0; i < 4; i++){                                     // Generate operands.
            operands[i] = lowerBound + rand() % (upperBound - lowerBound + 1);
        }
        for(int i = 0; i < 3; i++){                                     // Generate operators.
            ops[i] = operators[rand()%3];
        }

        sprintf(eqtn, "%d %c %d %c %d %c %d", operands[0], ops[0], operands[1], ops[1],
                                                        operands[2], ops[2], operands[3]);
        printf("> %s\n", eqtn);

        for(int i = 0; i < 3; i++){
            if(ops[i] == '*'){
                operands[i+1] = operands[i] * operands[i+1];
                operands[i] = operands[i+1];
                //printf("> %d %c %d %c %d %c %d\n", operands[0], ops[0], operands[1],
                //                                  ops[1], operands[2], ops[2], operands[3]);
            }
        }

        for(int i = 2; i >= 0; i--){        // Shift the products to the left for
                                            //  easier calculation.
            if(ops[i] == '*'){
                operands[i] = operands[i+1];
            }
        }
        for(int i = 0; i < 3; i++){                             // Evaulate the '+' and '-'.
            if(ops[i] == '+'){
                operands[i+1] = operands[i] + operands[i+1];
            }
            else if(ops[i] == '-'){
                operands[i+1] = operands[i] - operands[i+1];
            }
            else{
                operands[i+1] = operands[i];
            }
        }

        compAns = operands[3];

        // Print Eqtn
        printf("compAns: %d\n", compAns);
        scanf("%s", userResponse);


        if(userResponse[0] == 'q' || userResponse[0] == 'Q'){
            printf("Goodbye\n");
            exit(0);
        }
        else{
            userAns = atoi(userResponse);
        }


        while(compAns != userAns){
            printf("> Incorrect\n");
            printf("> %s\n", eqtn);
            scanf("%s", userResponse);

            if(userResponse[0] == 'q' || userResponse[0] == 'Q'){
                printf("Goodbye\n");
                exit(0);
            }
            else{
                userAns = atoi(userResponse);
            }
        }
        if(compAns == userAns){
            printf("> Correct!\n");
        }
    }while(1);

    return 0;
}

  • permalink
  • embed
  • save
  • give gold

[–]toodim 1 point2 points3 points 4 years ago (1 child)

Python 3

import random

r = input("Enter range").split()

def arithmetic(range_start, range_stop):
    operations = "*+-"
    nums = [random.randint(range_start, range_stop) for x in range(4)]
    problem = " ".join([str(x) +" "+ random.choice(operations) for x in nums])[:-1]
    user_answer = input(problem)
    real_answer = str(eval(problem))
    if user_answer == "Q" or user_answer == "q":
        print ("Thanks for playing!")
    elif user_answer == real_answer:
        print ("Correct! The answer was " + real_answer)
        arithmetic(range_start, range_stop)
    else:
        print ("Incorrect! The answer was " + real_answer)
        arithmetic(range_start, range_stop)

arithmetic(int(r[0]),int(r[1]))

  • permalink
  • embed
  • save
  • give gold

[–]hamsolo474 1 point2 points3 points 4 years ago (0 children)

Ahhh, list comprehensions! Why didn't I think of that!

Good job.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]Dutsj 1 point2 points3 points 4 years ago (1 child)

This was a bit tougher than it looked in C++11. It's the first challenge I'm
taking part in. Took me a while, and I almost got it. I'll be working on the
last 2 things tomorrow: having a q/Q exit instead of EOF, and having the
operator precedence the right way. As of now it evaluates 0-1+2 as 0-(1+2)
instead of the right way around. I'll have to rewrite the function that returns
the answer, but I'm waaaay to tired to continue now. I've uploaded it here.
Indentation is a bit wider than it's supposed to be on my text editor, but
still quite readable I hope. I

  • permalink
  • embed
  • save
  • give gold

[–]Ocean_Ghost 0 points1 point2 points 4 years ago (0 children)

A good tip for the operator precedence is to realise that the only one which
comes first is multiplication. So if you do all the multiplications first, and
then do the rest from left to right, it should give the right answer.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]GPK_Ethan0 0 1 point2 points3 points 4 years ago* (0 children)

Java.

Originally I had split this all up into 3 methods(not including main) but I
decided to smash it all into one so it's not so huge. I would love some
feedback as well.

private static void arithmeticGame(int start, int end) throws ScriptException {

    Random rand = new Random();
    Scanner scan = new Scanner(System.in);
    ScriptEngineManager manager = new ScriptEngineManager();
    ScriptEngine eng = manager.getEngineByName("JavaScript");

    int i = 0;
    int timesTried = 0;

    while(i < 20) {

        int[] nums = { (rand.nextInt(end) + start),
                       (rand.nextInt(end) + start),
                       (rand.nextInt(end) + start),
                       (rand.nextInt(end) + start) };

        String[] addSubMult = {"+", "-", "*"};

        String equasions = nums[0] + " " + addSubMult[ rand.nextInt(3) ] + " " +
                           nums[1] + " " + addSubMult[ rand.nextInt(3) ] + " " +
                           nums[2] + " " + addSubMult[ rand.nextInt(3) ] + " " +
                           nums[3] ;

        System.out.println("> " + equasions);
        double ansInput = scan.nextDouble();

        double answer = (double)eng.eval(equasions);

        while(ansInput != answer) {

            System.out.println("> Incorrect!");
            System.out.println("> " + equasions);
            ansInput = scan.nextDouble();

            timesTried++;

        }

        System.out.println("> Correct!");

        timesTried++;
        i++;
    }

    System.out.println("Percent Correct: " + ( ( (double)i + 1 ) / (double)timesTried) * 100  );

}

  • permalink
  • embed
  • save
  • give gold

[–]TimeCannotErase 1 point2 points3 points 4 years ago (0 children)

Here's my solution, written in R:

rm(list=ls())   #Clear list
#Read in two intergers to serve as inclusive endpoints for range of values
numrange<-as.numeric(scan(n=2,what="numeric",sep=" ",quiet=TRUE))
rangemax<-max(numrange)
rangemin<-min(numrange)

nums<-seq(rangemin,rangemax)
operators<-c("+","-","*")
response<-"a"   #Place-holder for response
while(response!="q" & response!="Q"){   #While user doesn't want to quit
#Select pieces for equation
num1<-sample(nums,1)
num2<-sample(nums,1)
num3<-sample(nums,1)
num4<-sample(nums,1)

op1<-sample(operators,1)
op2<-sample(operators,1)
op3<-sample(operators,1)

answer<-eval(parse(text=paste(num1,op1,num2,op2,num3,op3,num4,sep=" ")))    #Find solution to equation
cat("\n",paste(num1,op1,num2,op2,num3,op3,num4,sep=" "),"\n")   #Display equation to be solved
response<-scan(what="",n=1,quiet=TRUE)  #Store response
    while(!is.na(as.numeric(response)!=answer) & as.numeric(response)!=answer){     #If response is incorrect, reprompt with equation
        cat("\n","Try Again","\n")
        cat("\n",paste(num1,op1,num2,op2,num3,op3,num4,sep=" "),"\n")
        response<-scan(what="",n=1,quiet=TRUE)
    }
    if(!is.na(as.numeric(response)==answer) & as.numeric(response)==answer){cat("\n","Correct!","\n")}  #If equation is correct, generate another
}

  • permalink
  • embed
  • save
  • give gold

[–]kirsybuu0 1 1 point2 points3 points 4 years ago (0 children)

D Language. A bit long for the sake of being relatively extendable, mainly with
fun template subclasses.

import std.stdio, std.conv, std.random, std.array, std.string;

abstract class Node {
    long eval() const;
    override string toString() const;
}
class Num : Node {
    long value;
    this(long v) { value = v; }
    override long eval() const {
        return value;
    }
    override string toString() const {
        return text(value);
    }
}
class Op(string op) : Node {
    Node left, right;
    this(Node l, Node r) { left = l; right = r; }
    override long eval() const {
        return mixin("left.eval() " ~ op ~ " right.eval()");
    }
    override string toString() const {
        return "%s %s %s".format(left, op, right);
    }
}

void main(string[] argv) {
    long low = argv[1].to!long, high = argv[2].to!long;

    Node randomFactors() {
        switch (dice(5,1)) {
            case 0: return new Num(uniform!"[]"(low, high));
            default:return new Op!"*"(randomFactors(), randomFactors());
        }
    }
    Node randomTerms() {
        switch(dice(4,2,3)) {
            case 0: return randomFactors();
            case 1: return new Op!"+"(randomTerms(), randomTerms());
            default:return new Op!"-"(randomTerms(), randomFactors());
        }
    }

    while(true) {
        const eq = randomTerms();
        const question = text(eq);
        const answer = eq.eval();

        while(true) {
            writeln("> ", question);
            auto guess = readln().strip();

            if (guess is null) return; // stop on end of input
            if (guess.empty) continue; // ignore empty line
            if (guess.front == 'q' || guess.front == 'Q') return;
            try {
                if (guess.to!long == answer) {
                    writeln("> Correct!");
                    break;
                }
                else {
                    writeln("> Try Again.");
                }
            }
            catch(ConvException) {
                writeln("> Invalid Input.");
            }
        }
    }
}

Sample Run:

$ rdmd arithmatic_game.d -10 10
> 4
4
> Correct!
> 9 - -5 - -8
22
> Correct!
> -8 - 10 + 7 - -3 - -2 * 3
71
> Try Again.
> -8 - 10 + 7 - -3 - -2 * 3
ju6vcju7vnuvt
> Invalid Input.
> -8 - -5 - -7 * 3 + -4
20
> Try Again.
> -8 - -5 - -7 * 3 + -4

> -8 - -5 - -7 * 3 + -4
14
> Correct!
q
$

  • permalink
  • embed
  • save
  • give gold

[–]nullmove1 0 1 point2 points3 points 4 years ago (0 children)

Python 3

import random

a = input().split()
operators=['+','-','*']

def gen_ques(operators):
    string=''
    for i in range(3):
        string+=str(random.randint(int(a[0]),int(a[1])))+(random.choice(operators))
    string+=str(random.randint(int(a[0]),int(a[1])))
    return string

def evaluate(string,answer):
    if answer:
        if eval(string)==int(answer):return True
        else:return False

def main():
    answer=None
    string=''
    while answer not in ('q','Q'):
        value=evaluate(string,answer)
        if value:print('Correct!!')
        if value == False:print('Incorrect....')
        string=gen_ques(operators)
        answer=input("Ques: {0}? \nPlease insert your answer here or press Q to quit:".format(string))

if __name__='__main__':
    main()

  • permalink
  • embed
  • save
  • give gold

[–][deleted] 1 point2 points3 points 4 years ago (0 children)

In python:

import random

operators = ["+", "-", "*"]

inp = raw_input("")
inp = inp.split(" ")
inp[0], inp[1] = int(inp[0]), int(inp[1])

while True:
    ec = str(random.randint(inp[0], inp[1]))

    opNumber = random.randint(1, 6)  # Number of operators

    for i in range(opNumber):
        ec += operators[random.randint(0, len(operators) - 1)]
        ec += str(random.randint(inp[0], inp[1]))
    print ec

    ans = raw_input("= ")
    if ans == "q":
        print("Exit!")
        break
    if int(ans) == eval(ec):
        print("Correct!")
    else:
        print("Incorrect")

  • permalink
  • embed
  • save

[–]spfy 1 point2 points3 points 4 years ago (1 child)

Java. Holy shit this was annoying. I originally started this with hundreds of
switch/case statements. That was out of control; I managed to think it through
a little better this way.

I keep getting Exceptions if I don't enter integers for input, everything I try
is not helping. Still learning, I guess.

import java.io.*;
import java.util.*;
public class Arithmetic
{
    private int num1;
    private int num2;

    public Arithmetic(int min, int max)
    {
        num1 = min;
        num2 = max;
    }
    public int getEquation()
    {
        int a, b, c, d, op1, op2, op3;
        String answer;
        String[] ops = {"-", "+", "*"};
        Random rand = new Random();
        a = rand.nextInt(num2 + 1 - num1) + num1;
        b = rand.nextInt(num2 + 1 - num1) + num1;
        c = rand.nextInt(num2 + 1 - num1) + num1;
        d = rand.nextInt(num2 + 1 - num1) + num1;
        op1 = rand.nextInt(3);
        op2 = rand.nextInt(3);
        op3 = rand.nextInt(3);
        answer = a + ops[op1] + b + ops[op2] + c + ops[op3] + d;
        System.out.println(answer);
        if (op1 == 2) {
            b = a * b;
            if (op2 != 2) {
                if (op3 != 2) {
                    if (op2 == 1) {
                        if (op3 == 1)
                            return b + c + d;
                        else
                            return b + c - d;
                    } else {
                        if (op3 == 1)
                            return b - c + d;
                        else
                            return b - c - d;
                    }
                } else {
                    c = d * c;
                    if (op2 == 1)
                        return b + c;
                    else
                        return b - c;
                }
            } else {
                c = b * c;
                if (op3 != 2) {
                    if (op3 == 1)
                        return c + d;
                    else
                        return c - d;
                } else {
                    return c * d;
                }
            }
        } else {
            if (op2 != 2) {
                    if (op3 != 2) {
                        if (op1 == 1) {
                            if (op2 == 1) {
                                if (op3 == 1)
                                    return a + b + c + d;
                                else
                                    return a + b + c - d;
                            } else {
                                if (op3 == 1)
                                return a + b - c + d;
                            else
                                return a + b - c - d;
                        }
                    } else {
                        if (op2 == 1) {
                            if (op3 == 1)
                                return a - b + c + d;
                            else
                                return a - b + c - d;
                        } else {
                            if (op3 == 1)
                                return a - b - c + d;
                            else
                                return a - b - c - d;
                        }
                    }
                } else {
                    c = c * d;
                    if (op1 == 1) {
                        if (op2 == 1)
                            return a + b + c;
                        else
                            return a + b - c;
                    } else {
                        if (op2 == 1)
                            return a - b + c;
                        else
                            return a - b - c;
                    }
                }
            } else {
                c = b * c;
                if (op1 == 1) {
                    if (op3 == 1)
                        return a + c + d;
                    else
                        return a + c - d;
                } else {
                    if (op3 == 1)
                        return a - c + d;
                    else
                        return a - c - d;
                }
            }
        }
    }
    public static void main(String[] args)
    throws java.io.IOException
    {
        int answer;
        int correct = 0;
        int tries = 0;
        int guess = 0;
        String strGuess = "lol";
        InputStreamReader isr = new InputStreamReader(System.in);
        BufferedReader br = new BufferedReader(isr);
        Scanner sc = new Scanner(System.in);
        Arithmetic game = new Arithmetic(sc.nextInt(), sc.nextInt());
        for (int i = 0; i < 20; i++) {
            answer = game.getEquation();
            while (strGuess != "Q" && strGuess != "q") {
                strGuess = br.readLine();
                guess = Integer.parseInt(strGuess);
                if (guess == answer) {
                    ++tries;
                    ++correct;
                    break;
                } else {
                    System.out.println("try again");
                    ++tries;
                    continue;
                }
            }
        }
        System.out.println(tries + " tries and " + correct + "right");
    }
}

  • permalink
  • embed
  • save
  • give gold

[–]spfy 5 points6 points7 points 4 years ago (0 children)

I had an epiphany in the shower this morning. This way is much simpler, and
probably more reliable.

public static int getAnswer(int a, int b, int c, int d, String op1,
                        String op2, String op3)
{
    if (op1 == "*") {
        b = a * b;
        a = 0;
    } else if (op1 == "-") {
        b *= -1;
    }
    if (op2 == "*") {
        c = b * c;
        b = 0;
    } else if (op2 == "-") {
        c *= -1;
    }
    if (op3 == "*") {
        d = c * d;
        c = 0;
    } else if (op3 == "-") {
        d *= -1;
    }
    return a + b + c + d;
}

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]ThrowawayXTREME 1 point2 points3 points 4 years ago* (0 children)

I did it in C#. Had to be a little creative. My first submission :) Looking
forward to learning more.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.Xml.XPath;

namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
         Start:
            Random rnd = new Random();

            //Generating Random Numbers and storing copies as strings for output to Console
            int firstNum = rnd.Next(0, 10);
            int secondNum = rnd.Next(0, 10);
            int thirdNum = rnd.Next(0, 10);
            int fourthNum = rnd.Next(0, 10);
            string str_firstNum = firstNum.ToString();
            string str_secondNum = secondNum.ToString();
            string str_thirdNum = thirdNum.ToString();
            string str_fourthNum = fourthNum.ToString();

            //Creating array of operands, randomly picking 3 and storing those values
            string[] operators = { "+", "-", "*" };
            string operatorOne = operators[rnd.Next(0, operators.Length)];
            string operatorTwo = operators[rnd.Next(0, operators.Length)];
            string operatorThree = operators[rnd.Next(0, operators.Length)];

            //The resulting equation with random numbers and operands
string QuestionString = str_firstNum + operatorOne + str_secondNum + operatorTwo + str_thirdNum + operatorThree + str_fourthNum;

            //Asking the Question
            Console.WriteLine(QuestionString);

            //This is how I calculated the answer with the operands as strings
            //This was the most difficult part, C# does not have a built in mechanism to convert strings to
          //operators
            XPathExpression expr = XPathExpression.Compile(QuestionString);
            XmlDocument xmlDoc = new XmlDocument();
            XPathNavigator xPathNavigator = xmlDoc.CreateNavigator();
            var Ans = xPathNavigator.Evaluate(expr);

            //Adding the q, wrong answer, right answer interactions
            var AnswerString = Console.ReadLine();
            if (AnswerString == "q")
            {
                Environment.Exit(0);
                }
            if (AnswerString == Ans.ToString())
            {
                Console.WriteLine("Correct!");
                goto Start;
            }
            else
            {
                Console.WriteLine("Try Again");
                goto Start;
            }

        }
    }
}

  • permalink
  • embed
  • save
  • give gold

[–]Urist_Mc_George 1 point2 points3 points 4 years ago (0 children)

And here my Python solution. One of my first Python programs.

import random
# split the first input to get the range of int
a,b = raw_input().split()

def rand():
    return random.randint(int(a),int(b))

# 4 ints, 3 operators
def genEqu():
    equ = ""
    equ += str(rand())

    for i in range(3):
        equ += " "+random.choice(["+","-","*"])
        equ += " "+ str(rand())

    return equ

equ = genEqu()
while True:

    print "> "+equ

    input = raw_input("> ")

    if input == "Q" or input == "q":
        break
    elif int(input) == eval(equ):
        equ = genEqu()
        print "> Correct!"
    else:
        print "> Incorrect..."

  • permalink
  • embed
  • save
  • give gold

[–]Taunk 1 point2 points3 points 4 years ago (0 children)

Added a few operators, which was actually pretty fun to play with.

Python:

from random import randint #randint for parameters, random for operator choice
import random
min=int(raw_input("Enter a min:"))#take input
max=int(raw_input("Enter a max:"))
randops=['+','-','*','**','%']#declare operators
correct=0#initialize the arrays, initialize scores
total=0
while True:#continuously loop until input=q|Q
    var=[randint(min,max) for i in range(0,4)]  #re-randomize the parameters and operators
    op=[random.choice(randops) for i in range(0,3)]
    problem = "%d %s %d %s %d %s %d" % (var[0],op[0],var[1],op[1],var[2],op[2],var[3])  #construct the equation
    answer = raw_input(problem + "\n Enter your answer:\n")#print the equation and prompt for answer
    if answer in ('q','Q'):#check if the answer is q to exit
        break
    elif int(answer) == eval(problem): #check for the correct answer
        total+=1
        correct+=1
        score=100*correct/total #re-calculate score
        print "Correct! \nScore: " + str(score) +"%"
    else: #any other case (incorrect answer, keyboard flailing)
        total+=1
        score=100*correct/total
        print "No, the correct answer is " + str(eval(problem)) +"\n Score: " + str(score) + "%"

  • permalink
  • embed
  • save
  • give gold

[–]hafela 1 point2 points3 points 4 years ago (1 child)

It was actually quite fun. Any tip to check whether the input is transformable
to int?

# Python3.32
import random

def main():
    print("Got big or go home!\nGood Luck!")
    while True:
        challenge = ""
        for i in range(random.randint(1, 5)):
            challenge += str(random.randint(1, 10))
            challenge += random.choice('+-*/%')
            if challenge.endswith('/'):
                challenge += '/'
        challenge += str(random.randint(1, 10))
        print(">", challenge)
        answer = input()
        if answer == 'q' or answer == 'Q':
            break
        elif int(answer) == eval(challenge):
            print("correct")
        else:
            print("Go home!")
main()

  • permalink
  • embed
  • save
  • give gold

[–]hamsolo474 1 point2 points3 points 4 years ago (0 children)

this is how i would do it, but this doesnt just 'check' this does it if it can
be done and prints NaN! if it cant.

If you just want it to check and do nothing else do the same thing in try but
save it as a var with a diff name that's not referenced and cleared shortly
after

 try:
    answer=int(answer)
    #clearme=int(answer)
    #clearme=0

except ValueError:
    print("NaN!")

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]chrisledet 1 point2 points3 points 4 years ago (0 children)

Ruby

OPTS = %w(+ - *)
NUM_OF_OPS  = 3
NUM_OF_INTS = 4

def quit?(input)
  input.downcase.strip == "q"
end

def random_opt
  OPTS[rand(0..OPTS.size-1)]
end

def generate_equation(from, to)
  integers, operators = [], []
  NUM_OF_OPS.times  { operators << random_opt }
  NUM_OF_INTS.times { integers  << rand(from..to) }
  integers.zip(operators).flatten.compact
end

low, high = gets.split
generate_new = true
answer, equation = nil, nil

loop do
  if generate_new
    equation = generate_equation(low.to_i, high.to_i).join(" ")
    answer   = eval(equation)
    generate_new = false
  end

  puts "> #{equation}"
  input = gets
  break if quit?(input)

  if input.to_i == answer
    puts "> Correct!"
    generate_new = true
  else
    puts "> Incorrect..."
  end
end

  • permalink
  • embed
  • save
  • give gold

[–]PolarisDiB 1 point2 points3 points 4 years ago (2 children)

Python 2.7. I had to look at other people's for some ideas, TIL eval() and how
to prompt within a while loop:

from random import randint

operators = {1: "+", 2: "-", 3: "*", 4: "/"}

def makeoperator():
    y = operators[randint(1,4)]
    return y

def makenumeral():
    x = randint(1,10)
    return x

def makeequation():
    return str(makenumeral()) + str(makeoperator()) + str(makenumeral()) + str(makeoperator()) + str(makenumeral()) + str(makeoperator()) + str(makenumeral())

while True:

    m = makeequation()
    print m
    n = eval(m)
    prompt = raw_input("> ")

    if prompt == "q" or prompt == "Q":
        quit()
    elif int(prompt) == n:
        print "Correct!"
        continue
    else:
        print "Incorrect..."
        continue

Advice/criticism welcome, especially toward how to clean it up and make it
shorter.

  • permalink
  • embed
  • save
  • give gold

[–]hamsolo474 1 point2 points3 points 4 years ago (1 child)

Three things I would change

makenumeral and makeoperator should output strings, it makes the code slightly
easier to read idc about speed but it would definitely save a few chars.

if prompt.lower() == 'q':

Saves a few chars, very readable and It's a good habit to get into again idk
about performance.

I also try to put my expected result as the first one I check for in a series
of if statements. Ordering them by probability of them occurring will save a
few cycles with a marginal performance gain.

Also not really a problem but i just think its weird you are saving the
operators in a dictionary but having them indexed by numbers. Why not just go
zero indexed and use a list? Probably more efficient, definitely save a few
chars. Have you seen /u/toodim's solution? He saves the operators in a string
and just uses substring indexing to ref individual operator.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]PolarisDiB 0 points1 point2 points 4 years ago (0 children)

    I also try to put my expected result as the first one I check for in a
    series of if statements. Ordering them by probability of them occurring
    will save a few cycles with a marginal performance gain.

That crashed it, actually. Originally I had it set up

if int(raw_input) == n:

elif raw_input == 'q':

and then while testing it when I input 'q', it would throw an AttributeError
about q not being an integer. I also thought it was sensible to make Else be
the "Incorrect...." statement as that way the user can't throw random strings
to mess with the program.

Here's with your suggestions:

from random import randint

operators = ["+", "-", "*", "/"]

def makeoperator():
    y = operators[randint(0,4)]
    return str(y)

def makenumeral():
    x = randint(1,10)
    return str(x)

def makeequation():
    return makenumeral() + makeoperator() + makenumeral() + makeoperator() + makenumeral() + makeoperator() + makenumeral()

while True:

    m = makeequation()
    print m
    n = eval(m)
    prompt = raw_input("> ")

    if prompt.lower() == "q":
        quit()
    elif int(prompt) == n:
        print "Correct!"
        continue
    else:
        print "Incorrect..."
        continue

(By the way the reason I did the dictionary is so that I would keep to randint
() instead of using something like .choice(), until I was switching it back to
a list and realized it was almost the exact same randint() so yeah, that was
just me overthinking it!)

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]zengargoyle 1 point2 points3 points 4 years ago (0 children)

A Perl programming language solution with a few neatos. Avoiding the easy out
via eval of the expression and instead abusing regular expressions (and their
eval) to both create the equation and to solve it. An operator map that tracks
precedence levels, a use of '·' MIDDLE DOT instead of 'x' or '*'. And using
named block for the redo-ness of retrying answers and equations.

#!/usr/bin/env perl
use strict;
use warnings;

use v5.16;

# want our program and teminal to have utf8 goodness
use utf8;
binmode STDOUT, ':encoding(UTF-8)';

my ($low, $high) = split ' ', <STDIN>;

# a mapping of our operators as an array of hashes in the
# order of their precedence level and the code to evaluate them.
my @op = (
    {
        '·' => sub { $_[0] * $_[1] },  # rfc1345(.M) \x{00b7} \N{MIDDLE DOT}
    },
    {
        '+' => sub { $_[0] + $_[1] },
        '-' => sub { $_[0] - $_[1] },
    },
);

my @ops = map keys %$_, @op;  # for rolling

# pick one random item from an array
sub roll { $_[rand(@_)] }

# our equation template: d == digit, o == operator
my $eqn_tmpl = 'd o d o d o d';

# named scopes and redo/next/last are handy
EQN: {

    # copy template and replace items with random suitable things
    # to create a random equation
    my $eqn = $eqn_tmpl;
    $eqn =~ s/d/roll($low..$high)/ge;
    $eqn =~ s/o/roll(@ops)/ge;

    # copy equation and solve it.
    # go through the array of operator precedence groupings
    # and create a match string (that escapes any operator that
    # might be a special character in regex).  match each
    # ( digit op digit ) group and replace with its solution.
    my $ans = $eqn;
    for my $ops ( @op ) {
        my $match = join '|', map quotemeta, keys %$ops;
        1 while $ans =~ s/(\d+) ($match) (\d+)/$ops->{$2}->($1,$3)/e;
    }

    ASK: {

        # show equation and get a guess
        say $eqn;  # print "--> $ans\n";  # debug
        my $guess = <>;
        chomp $guess;

        # maybe quit
        $guess =~ /^q/i && last EQN;

        # test guess and do another equation or try this one again
       if ($guess == $ans) { say "Correct"; redo EQN; }
       say "Try again";
       redo ASK;
    }
}

A sample game...

./081313_135_Easy_Arithmetic_Equations.pl
1 10
7 - 7 - 6 · 10
60
Try again
7 - 7 - 6 · 10
-60
Correct
7 · 8 - 2 · 5
46
Correct
9 - 10 · 1 · 2
q

  • permalink
  • embed
  • save
  • give gold

[–][deleted] 1 point2 points3 points 4 years ago* (0 children)

Here's mine in C++. It's probably incredibly verbose.

EDIT: I just now realized I could have put the random number generation into
operator_char();...

EDIT 2: I just modified this slightly to make it more efficient.

#include <iostream>
#include <ctime>
#include <cstdlib>
#include <cmath>

using std::cin;
using std::cout;
using std::string;

long long int get_num(long long int, long long int);
char operator_char();
long long int convert_to_integer(string);

int main()
{
    srand(time(0));
    long long int lower_limit, upper_limit;
    long long int correct_solution;
    long long int num_a, num_b, num_c, num_d;
    char op_a, op_b, op_c;
    string input;

    cin >> lower_limit >> upper_limit;

    while(tolower(input[0]) != 'q')
    {
        num_a = get_num(lower_limit, upper_limit);
        num_b = get_num(lower_limit, upper_limit);
        num_c = get_num(lower_limit, upper_limit);
        num_d = get_num(lower_limit, upper_limit);
        op_a = operator_char();
        op_b = operator_char();
        op_c = operator_char();

        cout << ">" << num_a << " " << op_a << " " << num_b << " "
               << op_b << " " << num_c << " " << op_c << " "
               << num_d << "\n";

        if(op_a == '*')
        {
            num_b *= num_a;
            num_a = 0;
        }

        if(op_b == '*')
        {
            num_c *= num_b;
            num_b = 0;
        }

        if(op_c == '*')
        {
            num_d *= num_c;
            num_c = 0;
        }

        switch(op_a)
        {
        case '+':
            num_b += num_a;
            num_a = 0;
            break;
        case '-':
             num_a -= num_b;
             num_b = 0;
             break;
        }

        switch(op_b)
        {
        case '+':
            num_c += num_b;
            num_b = 0;
            break;
        case '-':
            num_b -= num_c;
            num_c = 0;
            break;
        }

        switch(op_c)
        {
        case '+':
            num_d += num_c;
            num_c = 0;
            break;
        case '-':
            num_c -= num_d;
            num_d = 0;
            break;
        }

        correct_solution = num_a + num_b + num_c + num_d;
        cin >> input;

        if(tolower(input[0]) == 'q')
        {
            break;
        }
        else if(correct_solution == convert_to_integer(input))
        {
            cout << ">Correct!\n";
        }
        else
        {
            cout << ">Incorrect...\n";

            while(convert_to_integer(input) != correct_solution)
            {
                cin >> input;

                if(convert_to_integer(input) == correct_solution)
                {
                    cout << ">Correct!\n";
                }
                else if(tolower(input[0]) == 'q')
                {
                    break;
                }
                else
                {
                    cout << ">Incorrect...\n";
                }
            }
        }

    }

    cout << ">Thank you for using this program.";
    cin.get();
    return 0;
}

long long int get_num(long long int lower_limit, long long int upper_limit)
{
    return lower_limit + rand() % upper_limit;
}

char operator_char()
{
    short op = 1 + rand() % 3;

    switch(op)
    {
    case 1:
        return '+';
        break;
    case 2:
        return '-';
        break;
    case 3:
        return '*';
        break;
    }
}

long long int convert_to_integer(string input)
{
    long long int number;
    long long int total = 0;
    double power = -1;
    double power_of_10;

    for(short i = input.length() - 1; i >= 0; i--)
    {
        power++;
        power_of_10 = pow(10, power);
        number = (input[i] - '0') * power_of_10;
        total += number;
    }

    return total;
}

  • permalink
  • embed
  • save

[–]luz_ 1 point2 points3 points 4 years ago (0 children)

This one was tricky, Thought It would be easy but ended up spending many hours
doing this, rewritingmy solution a couple of times when i thought i got
everything wrong. Ended up with 114 lines in Java **Edit: not so experienced,
but why not posting.

import java.util.ArrayList;
import java.util.Scanner;

public class Main {
private Scanner scan;
private ArrayList<Integer> numbers;
private ArrayList<Character> operators;
private int max = 10;
private int min = 0;
private int n_numbers = 4;
private int n_signs = n_numbers - 1;

public Main() {
    scan = new Scanner(System.in);

}

public void init() {
    numbers = new ArrayList<Integer>();
    operators = new ArrayList<Character>();
    randNum();
    randSign();
    printString();
    mod();

}

public void randNum() {
    for ( int i = 0; i < n_numbers ; i++ ) {
        int rnd = (int) (Math.random() * max )+ 1 + min;
        numbers.add(rnd);
    }
}

public void randSign() {
    for (int i = 0; i < n_signs ; i++) {
    double rnd = Math.random();
    if (rnd < ((float)1 / 3))
        operators.add('+');
    else if ( rnd > ((float)1 / 3) && rnd < ((float)2 / 3))
        operators.add('-');
    else
        operators.add('*');
    }
}

public int indexMulti() {
    for ( int i = 0; i < operators.size(); i++) {
        if ( operators.get(i) == '*') {
            return i;
        }
    }
    return -1;
}

public void mod() {
    while (indexMulti() != -1 ) {
        int res =  numbers.get(indexMulti()) * numbers.get(indexMulti() + 1);
        int place = indexMulti();
        numbers.remove(place);
        operators.remove(place);
        numbers.set(place, res);
    }
}

public int add() {
    int res = numbers.get(0);
    for ( int i = 1; i < numbers.size(); i++) {
        if (operators.get(i - 1) == '+')
            res += numbers.get(i);
        else
            res -= numbers.get(i);
    }
    return res;

}

public void printString() {
    for ( int i = 0; i < operators.size(); i++) {
        System.out.print(numbers.get(i) + " " +  operators.get(i) + " ");
        if ( i == operators.size() -1) {
            System.out.println(numbers.get(operators.size()));
        }
    }
}

public String getAnswer() {
    init();
    return scan.next();
}

public void test() {
    while(true) {
        String answ = getAnswer();
        if (answ.equals("q")) {
            System.out.println("bye");
            System.exit(0);
        }
        if ( Integer.parseInt(answ) == add())
            System.out.println("Right!");
        else
            System.out.println("What?");
    }
}

public static void main( String args[] ) {
    Main program = new Main();
    program.min = Integer.parseInt(args[0]);
    program.max = Integer.parseInt(args[1]);
    program.test();

}
}

  • permalink
  • embed
  • save
  • give gold

[–]catchingExceptions 1 point2 points3 points 4 years ago (3 children)

Perl, with some lines from /u/diosio

#!usr/bin/perl
use strict;
use warnings;


my $equation = "";
while(<STDIN>){
    chomp;
    if(uc($_) eq "Q"){
        last;
    } elsif($equation eq ""){
        split(" ");
        my @operators = qw(+ - *);
        for(1 .. 4){
                    $equation .= $_[0] + int(rand($_[1]-$_[0] + 1));
                    $equation .= $operators[int(rand(3))] unless $_ == 4;
        }
        print ">$equation\n";
    } else {
        if(eval $equation == $_) {
            print ">Correct!\n";
            $equation = "";
        } else {
            print ">Incorrect...\n>$equation\n";
        }
    }
}

  • permalink
  • embed
  • save
  • give gold

[–]zengargoyle 1 point2 points3 points 4 years ago (2 children)

Doesn't run.

split() does not work like that. It's useless unless you assign it's return
value to something as warnings would have tell you when you try to run it.

Useless use of split in void context at foo.pl line 12.

You need to do something like:

    } elsif ($equation eq "") {
        my @lowhi = split(" ");
        my @operators = qw(+ - *);
        for(1 .. 4){
                    $equation .= $lowhi[0] + ...

And

                    $equation .= $operators[int(rand(3))] unless $_ == 4;
                   #$equation = $operators[rand(@operators)] unless ...

Is more idiomatic. @array returns the length in scalar context so 3 in this
case, and the int() is not needed, $foo[3.1415] is just $foo[3].

But your logic is wrong, you're trying to get a new low and high range every
time you make a new equation instead of just once at the start of the game. You
seem to be trying for this:

0 10
> 1+2+3+4
10
> Correct
0 2
> 1+2+1+0

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]catchingExceptions 0 points1 point2 points 4 years ago (1 child)

That is what I was going for, but that's what I get for only skimming through
the specification.

It runs for me, assigning the output of split to $_[0], and $_[1]. It gives a
warning about implicit split being deprecated, but still runs the program and
gives the right (for the wrong logic) response. Could the fact that I'm using
v5.8.8 cause this?

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]zengargoyle 1 point2 points3 points 4 years ago (0 children)

Yep, 5.8.8 is ancient the split() deprecation was finally over and done with in
5.12.0.

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]speakEvil 1 point2 points3 points 4 years ago (0 children)

Yes, I know this is terrible. But on the other hand, I've learned quite a bit.
Maybe I'll try to rewrite it after I sleep on it.

Common Lisp:

(defun horse (range)
       (let ((op nil) (n nil) (e nil) (r nil))
       (dotimes (j 3)
           (setf op (cons (elt '(+ - *) (random 3)) op)))
       (dotimes (j 4)
                     (setf n (cons (random range) n)))
       (setf e (map 'vector #'write-to-string (append op n) ))
       (setf r (cons (eval (read-from-string
             (concatenate 'string
                   "(" (elt e 1)
                     " (" (elt e 0) " " (elt e 3) " " (elt e 4) ") "
                     "(" (elt e 2) " " (elt e 5) " " (elt e 6) "))")))
             (concatenate 'string
                   "(" (elt e 3) (elt e 0) (elt e 4) ") "
                   (elt e 1)
                   " (" (elt e 5) (elt e 2) (elt e 6) ")")))
       r))

(defun beater (r)
       (let ((p nil) (q 'no))
            (loop
                (setf p (horse r))
                (setf q (read (format t "~A = " (cdr p))))
                (if (equal q (or 'q 'Q))
                    (return)
                    (if (equal q (car p))
                        (format t "That is correct.~&")
                        (format t "The number you were looking for was ~A.~&" (car p)))))))

CL-USER> (beater 5)
(2+4) + (2*3) = 12
That is correct.
(4*1) + (2*1) = 0
The number you were looking for was 6.
(0+1) + (3*3) = q

NIL

  • permalink
  • embed
  • save
  • give gold

[–][deleted] 1 point2 points3 points 4 years ago* (0 children)

Hooray for my first solution on /r/dailyprogrammer! I am also fairly new to
pragramming, so any criticism is welcome. Without much ado, here is my solution
in Python 3.2.2:

from random import randint, choice

def problemgen(lmin,lmax):
    n = 0
    p = []
    while n < 4:
        n += 1
        p.append (str(randint(lmin,lmax)))
        p.append (choice(['+','-','*']))
    del p[-1]
    return " ".join(p)

r = input('Range? (min - max) ').split('-')

while True:
    lprob = problemgen(int(r[0]),int(r[1]))
    lsolu = eval(lprob)
    lansw = input(lprob + " = ")

    if lansw == 'q' or lansw == 'Q':
        print('Quitting!')
        break
    elif int(lansw) != lsolu:
        while int(lansw) != lsolu:
            print('Wrong. Try again.')
            lansw = input(lprob + " = ")
        print('Correct!')
    else:
        print('Correct!')

[DEL:The only bug I noticed is that if you include 0 in the range of usable
integers and it randomly gets placed after a divisor operator, the "divide by
0" error breaks the program. That and:DEL] there is nothing to keep the player
from entering other invalid variables. But yeah, I think it works OK.

EDIT: Whoops, removed division. Didn't see that it wasn't required.

EDIT2: Streamlined the input prompt after looking at some of the other python
work

  • permalink
  • embed
  • save

[–]lukz2 0 1 point2 points3 points 4 years ago* (0 children)

Common Lisp

The interesting part is the calculation of the correct value of the expression.
We have eval() function in Common Lisp, but that requires an expression in
prefix form while what we generate as the problem is an expression in an infix
form. We thus need to program an evaluator for infix expressions.

(defvar *e*)

(defun mult ()
  (do ((a (pop *e*) (* a (pop *e*)))) ((not (eq '* (car *e*))) a) (pop *e*)))

(defun evaluate (*e*)
  (do ((a (mult) (if (eq '+ (pop *e*)) (+ a (mult)) (- a (mult)))))
      ((not *e*) a)))

(defun generate (lo hi &aux r)
  (dotimes (i 4 (cdr r)) (push (+ lo (random (- hi lo -1))) r)
    (push (nth (random 3) '(+ - *)) r)))

(defun give-problem (p &aux (e (evaluate p)))
  (do (a) ((progn (setf a (read (format t "~{~a ~}~%" p))) (eq a 'q)))
    (when (= a e) (format t "Correct~%") (return t))
    (format t "Incorrect~%")))

(defun main (&aux (lo (read)) (hi (read)))
  (do () ((not (give-problem (generate lo hi))))))

  • permalink
  • embed
  • save
  • give gold

[–]brandnew3773 1 point2 points3 points 4 years ago* (0 children)

My java solution. Took about 75 lines. Critiques and criticisms are much
appreciated. Also I don't understand why some people import the javascript eval
function. That seems to take away all of the difficulty of solving this
programming assignment.

import java.util.*;
public class ArithmaticGame {
static List<String> list = new ArrayList<String>(Arrays.AsList("*","+","-"));
static List<String> randOps = new ArrayList<String>();
static List<Integer> numbers = new ArrayList<Integer>();

public static void main(String[] arg){
    Scanner input = new Scanner(System.in);
    System.out.println("Please input a high and low int.");
    int high = input.nextInt();
    int low = input.nextInt();
    for(int i=0;i<4;i++){
        int rand = low + (int)(Math.random()*((high-low)+1));
        numbers.add(rand);
        int op = 0 + (int)(Math.random()*(3));
        randOps.add(list.get(op));
    }
    boolean play = true;
    while(play == true){
        String expression = numbers.get(0)+randOps.get(0)+numbers.get(1)+randOps.get(1)+numbers.get(2)+randOps.get(2)+numbers.get(3);
        System.out.print(expression+"\n"+"What is your answer?");
        int guess = input.nextInt();
            for(int h=0;h<randOps.size();h++){
                String op = randOps.get(h);
                while(expression.indexOf(op)!= -1){
                    int index = expression.indexOf(op);
                    List<Integer> indexes = getIndexes(expression,index);
                    String sub = expression.substring(indexes.get(0),indexes.get(1));
                    int answer = manipulateStrings(expression.substring(indexes.get(0),index),expression.substring(index+1,indexes.get(1)),op);
                    expression = expression.replace(sub,Integer.toString(answer));
                }
            }
            int finalAnswer = Integer.parseInt(expression);
            if(guess == finalAnswer){System.out.println("You're awesome. The answer was: "+finalAnswer);}
            else System.out.println("You suck. Go back to kindergarten! The answer was: " + finalAnswer);
        play = false;
    }
}
public static List<Integer> getIndexes(String expression, int index){
    List<Integer> indexes = new ArrayList<Integer>();
    int nextIndex;
    int curPrevIndex = 0;
    int curIndex = 100;
    for(int k=0;k<randOps.size();k++){
        String op = randOps.get(k);
        nextIndex = expression.indexOf(op);
        while(nextIndex != -1){
            if(nextIndex!= -1 && nextIndex > index){
                if (nextIndex < curIndex && nextIndex != -1){
                    curIndex = nextIndex;
                }
            }
            if(nextIndex < index && nextIndex != -1){
                if(nextIndex > curPrevIndex){
                    curPrevIndex = nextIndex;
                }
            }
            nextIndex = expression.indexOf(op,nextIndex+1);
            }
        }
    if(curIndex == 100) curIndex = expression.length();
    if(curPrevIndex!=0) curPrevIndex += 1;
    indexes.add(curPrevIndex);
    indexes.add(curIndex);
    return indexes;
}

public static int manipulateStrings(String one, String two, String op){
    int num1 = Integer.parseInt(one);
    int num2 = Integer.parseInt(two);
    int answer = 0;
    if(op=="+"){answer = num1+num2;}
    if(op=="*"){answer = num1*num2;}
    if(op=="-"){answer = num1-num2;}
    return answer;
}

}

  • permalink
  • embed
  • save
  • give gold

[–]bikko 1 point2 points3 points 4 years ago (0 children)

This is my first submission to dailyprogrammer and one of my first Node.js
programs!

Interesting parts:

  • Doesn't use eval()
  • Gives statistics, including speed, every 20 questions (and at end)
  • Includes some sanity-check assertions

Code:

#!/usr/bin/env node

'use strict'

var assert = require('assert')

//
// Returns a random integer from (min, max) inclusive.
//
var randomInt = function (min, max) {
  return Math.round(Math.random() * (max - min) + min)
}

//
// Creates a new arithmetic problem with 4 integer operands.
//
var ArithmeticQuestion = function (min, max) {
  var numOperands = randomInt(4, 4)
    , operators = ['+', '-', '*']
    , tokens = []

  var randomOperand = function () {
    return randomInt(min, max)
  }

  var randomOperator = function () {
    return operators[randomInt(0, operators.length - 1)]
  }

  for (var i = 0; i < numOperands; i++) {
    tokens.push(randomOperand())
    if (i < (numOperands - 1)) {
      tokens.push(randomOperator())
    }
  }
  this.expression = tokens.join(' ')
  tokens = this.performMultiplication(tokens)
  this.answer = this.performAddSubtract(tokens)
}

//
// Performs all multiplication operations for the given tokens.
//
ArithmeticQuestion.prototype.performMultiplication = function (tokens) {
  var result = []
  for (var i = 0; i < tokens.length; i++) {
    // Even indicies should be numbers, and odds should be operators.
    assert.ok(((i % 2) === 0 && typeof tokens[i] === 'number') || (typeof tokens[i] === 'string'))

    // If we're seeing a number, and we previously saw a multiplication
    // operator, then we have a multiplication to perform. Otherwise, we pass
    // through all tokens.
    if (typeof tokens[i] === 'number' && result.length >= 2 && result[result.length - 1] === '*') {
      // Remove operator and previous number.
      result.pop()
      result.push(result.pop() * tokens[i])
    }
    else {
      result.push(tokens[i])
    }
  }
  return result
}

//
// Performs all addition and subtraction operations for the given tokens.
//
ArithmeticQuestion.prototype.performAddSubtract = function (tokens) {
  var result = tokens[0]
  assert.ok(typeof result === 'number', 'First token should be number')
  for (var i = 1; i < tokens.length - 1; i += 2) {
    assert.ok(tokens[i] === '+' || tokens[i] === '-', 'Should only have + or - operators')

    if (tokens[i] === '+') {
      result += tokens[i + 1]
    }
    else if (tokens[i] === '-') {
      result -= tokens[i + 1]
    }
  }
  return result
}

//
// Tests an answer against the question.
//
ArithmeticQuestion.prototype.isAnswerCorrect = function (answer) {
  return answer === this.answer
}

ArithmeticQuestion.prototype.toString = function () {
  return this.expression
}

// -----------------------------------------------------------------------------

var readline = require('readline')

var Game = function (input, output) {
  this.rl = readline.createInterface(input, output)
  this.correctAnswers = 0
  this.incorrectAnswers = 0
}

Game.prototype.start = function () {
  this.rl.write('Please enter a numeric range for operands. Format: min max\n')
  this.rl.question('> ', (function (data) {
    var numbers = data.split(' ')

    this.min = parseInt(numbers[0], 10)
    this.max = parseInt(numbers[1], 10)
    if (isNaN(this.min) || isNaN(this.max)) {
      this.start()
    }
    else {
      this.startTime = process.hrtime()[0]
      this.newQuestion()
    }
  }).bind(this))
}

Game.prototype.newQuestion = function () {
  this.question = new ArithmeticQuestion(this.min, this.max)
  this.askQuestion()
}

Game.prototype.askQuestion = function () {
  this.rl.prompt();
  this.rl.question(this.question.toString() + '\n> ', (function (data) {
    var answer = parseInt(data, 10)

    if (isNaN(answer) && data.toLowerCase() === 'q') {
      // Quit!
      if ((this.correctAnswers + this.incorrectAnswers) > 0) {
        this.statistics()
        this.rl.write('Thanks for playing!\n')
      }
      this.rl.close()
      return
    }

    if (this.question.isAnswerCorrect(answer)) {
      this.rl.write('Correct!\n')
      this.correctAnswers++

      if ((this.correctAnswers + this.incorrectAnswers) % 20 == 0) {
        this.statistics()
      }
      this.newQuestion()
    }
    else {
      this.incorrectAnswers++
      this.rl.write('What?\n')
      this.askQuestion()
    }
  }).bind(this))
}

Game.prototype.statistics = function () {
  var totalAnswers = this.incorrectAnswers + this.correctAnswers
  var average = this.correctAnswers / totalAnswers * 100
  var elapsed = process.hrtime()[0] - this.startTime
  var perMinute = this.correctAnswers * 60 / elapsed

  this.rl.write("\nSTATISTICS: You have answered\n")
  this.rl.write('  correctly ' + this.correctAnswers + ' times, and\n')
  this.rl.write('incorrectly ' + this.incorrectAnswers + ' times,\n')
  this.rl.write('       over ' + elapsed + ' seconds.\n')
  this.rl.write('Speed: ' + perMinute + ' correct answers per minute\n')
  this.rl.write('Accuracy: ' + average + '%\n')
  this.rl.write('\n')
}


new Game(process.stdin, process.stdout).start()

Sample output:

~/src/study/arithmetic☠ ./arithmetic.js
Please enter a numeric range for operands. Format: min max
> 0 10
2 - 9 * 4 * 8
> -286
Correct!
7 + 9 + 0 + 1
> 0
What?
7 + 9 + 0 + 1
> 17
Correct!
7 - 6 - 2 + 9
> 8
Correct!
9 * 6 + 4 - 5
> 35
What?
9 * 6 + 4 - 5
> 53
Correct!
2 - 8 - 2 - 7
> -15
Correct!
0 * 8 + 3 - 4
> q

STATISTICS: You have answered
  correctly 5 times, and
incorrectly 2 times,
       over 71 seconds.
Speed: 4.225352112676056 correct answers per minute
Accuracy: 71.42857142857143%

Thanks for playing!
~/src/study/arithmetic☠ ./arithmetic.js
Please enter a numeric range for operands. Format: min max
> 1 10
7 - 4 + 4 * 2
> 0
What?
7 - 4 + 4 * 2
> q

STATISTICS: You have answered
  correctly 0 times, and
incorrectly 1 times,
       over 4 seconds.
Speed: 0 correct answers per minute
Accuracy: 0%

Thanks for playing!

  • permalink
  • embed
  • save
  • give gold

[–]htcorgasm0 0 1 point2 points3 points 4 years ago (0 children)

An inefficient and wordy C# solution.

namespace Arithmetic
{
class Program
{

    static int answer = 0;

    char[] opChars = new char[3] { 'x', '+', '-' };

    static void Main(string[] args)
    {
        bool go = true;
        bool correct = true;
        while (go == true)
        {
            Program program = new Program();
            Console.WriteLine(program.GenerateProblem());
            string input = Console.ReadLine();
            try
            {
                int userguess = Convert.ToInt32(input);

                if (userguess == answer)
                {
                    correct = true;
                    Console.WriteLine("Correct!");
                }
                else if (userguess != answer)
                {
                    correct = false;
                    Console.WriteLine("Wrong!");
                }

            }
            catch (FormatException e)
            {
                Console.WriteLine("Input must be a sequence of digits.");
            }
        }
    }

    public string GenerateProblem()
    {
        char[] ops = new char[3];
        int[] workingInts = new int[4];
        string problem = "";
        Random rand = new Random();
        for (int i = 1; i <= 4; i++)
        {
            int randomNumber = rand.Next(0, 10);
            workingInts[i - 1] = randomNumber;
            problem += randomNumber.ToString();
            if (i <= 3)
            {
                int operatorChar = rand.Next(0, 3);
                ops[i - 1] = opChars[operatorChar];
                problem += opChars[operatorChar];
            }
        }

        for (int i = 0; i < 3; i++)
        {
            if (ops[i] == 'x')
            {
                workingInts[i + 1] *= workingInts[i];
                workingInts[i] = workingInts[i + 1];
            }
        }

        for (int i = 0; i < 3; i++)
        {
            if (ops[i] == '+')
            {
                workingInts[i + 1] += workingInts[i];
            }
            else if (ops[i] == '-')
            {
                workingInts[i + 1] = workingInts[i] - workingInts[i + 1];
            }
            else
            {
                workingInts[i + 1] = workingInts[i];
            }
        }
        answer = workingInts[3];
        problem += " = ";
        return problem;
    }

   }

}

  • permalink
  • embed
  • save
  • give gold

[–]thisisnotmypenis 1 point2 points3 points 4 years ago (0 children)

I finally manage to complete this thing, firstly I hacked up a version in C
which didn't really work because of operator precedence, so I know I read about
RPN, shunting yard and how it could be used for easy parsing with respect to
operator precedence, the code is pretty messy just made it to work, but will
revisit to make a proper parser.

[C++] https://gist.github.com/yippee-ki-yay/6269898

  • permalink
  • embed
  • save
  • give gold

[–]Smith7929 1 point2 points3 points 4 years ago (0 children)

Python solution using a class... just 'cause, I guess.

#!/usr/bin/env python

import string
import random

class Arithmetic:
    """class that handles the game"""

    def __init__(self, questionNumber=20):
        self.question = ""
        self.answer = 0
        self.questionNumber = questionNumber
        self.attempts = 0
        self.correct = 0

    def getInput(self):
        """Get the input from the user and make sure it is properly formatted"""

        print "\n", self.question
        userInput = raw_input("\n>> ")
        userInput = "".join([x for x in userInput if x in string.digits])

        if userInput == "!help":
            self.helpText()
            self.getInput()

        try:
            userInputInt = int(userInput)
            return userInputInt
        except:
            print "I'm sorry, your input wasn't recognized. Let's try again."
            self.getInput()

    def helpText(self):
        """Print some helpful information about the game"""

        print "\nThere is no help. Stuff it.\n"

    def generateQuestion(self):
        """This will generate the equation to be asked"""

        question = "%i %s %i %s %i %s %i" % (random.randint(0,9), random.choice(["*","-","+"]),
                                             random.randint(0,9), random.choice(["*","-","+"]),
                                             random.randint(0,9), random.choice(["*","-","+"]),
                                             random.randint(0,9))

        self.question = question
        self.answer = eval(question)

    def checkAnswer(self, answer):
        """Checks if answer is right"""

        if answer == self.answer:
            return True
        else:
            return False


    def play(self):
        """Starts the game loop. Argument = number of questions"""
        print "\nWelcome to Arithmetic, where the questions are made up" \
                " and the points don't matter. Today we will be playing" \
                " a game of %s questions. Please submit" \
                " your answer in numerical form without any spacing. Let's" \
                " get started. Good luck! (type !help for additional aid)" % self.questionNumber

        self.generateQuestion()

        while self.correct < self.questionNumber:

            if self.attempts % 10 == 0:
                print "\nYou have answered %s correct out of %s tries.\n" % (self.correct, self.attempts)

            if self.checkAnswer(self.getInput()):
                print "\nRight!\n"
                self.correct += 1
                self.attempts += 1
                self.generateQuestion()
            else:
                print "\nWhat?\n"
                self.attempts += 1

        if self.correct == self.questionNumber:
            print "\nCongratulations! You have won!\n"


if __name__ == "__main__":
    arithmetic = Arithmetic(20)
    arithmetic.play()

  • permalink
  • embed
  • save
  • give gold

[–]higuyslol 1 point2 points3 points 4 years ago (0 children)

Learning Python -- actually implemented my own infix to postfix because I
didn't know the eval() function.

    #!/usr/bin/python
    from random import randint;
    import operator;


    class Stack():
        a = [];
        def push(self, item):
            Stack.a.append(item);
        def pop(self):
            return Stack.a.pop();
        def peek(self):
            if (len(Stack.a) > 0):
                return Stack.a[-1];
            else: return "x";
        def isEmpty(self):
            return len(Stack.a) == 0;
        def printList(self):
            print Stack.a;

    def getDelim(d):
        if (d == 0): d = '+';
        if (d == 1): d = '-';
        if (d == 2): d = '*';
        return d;

    def getVars(a, b):
        for i in range(0, len(a)):
            a[i] = randint(int(b[0]), int(b[1]));

    def toPostfix(eq):
        ifix = eq.split();
        s = Stack();
        pfix = '';


        for i in range(0, len(ifix)):
            if ifix[i] != "+" and ifix[i] != "-" and ifix[i] != "*":
                pfix += ifix[i];
            else:
                #if s.isEmpty() == True: break;
                if (s.peek() == "*"):
                    pfix+=s.pop();
                    s.push(ifix[i]);
                else:
                    if ifix[i] == "*":
                        s.push(ifix[i]);
                    else:
                        if s.isEmpty() == False:
                            pfix+=s.pop();
                        s.push(ifix[i]);

        while (s.isEmpty() == False):
            pfix+=s.pop()
        return pfix;

    def computePostfix(eq):
        pfix = list(eq);

        while len(pfix) > 1:
            for i in range (0, len(pfix)):
                if (pfix[i] == "+"):
                    pfix[i-2] = operator.add(int(pfix[i-2]), int(pfix[i-1]));
                    del pfix[i];
                    del pfix[i-1];
                    break;
                if (pfix[i] == "-"):
                    pfix[i-2] = operator.sub(int(pfix[i-2]), int(pfix[i-1]));
                    del pfix[i];
                    del pfix[i-1];
                    break;
                if (pfix[i] == "*"):
                    pfix[i-2] = operator.mul(int(pfix[i-2]), int(pfix[i-1]));
                    del pfix[i];
                    del pfix[i-1];
                    break;

        return pfix[0];

    input = '-';

    print 'Welcome to Reddit Math!'
    print 'select your range:'

    input = raw_input('>> ');
    b = input.split();

    while(input != 'q') :

        a = [None] * 4;
        getVars(a, b);

        c = [0, 2]
        d = [None] * 3;
        getVars(d, c);

        for i in range(0, len(d)):
            d[i] = getDelim(d[i]);

        eq = "" + str(a[0]) +  " " + d[0] + " " + str(a[1]) + " " + d[1] + " " + str(a[2]) + " " + d[2] + " " + str(a[3]);

        print eq;
        eq = toPostfix(eq);
        sol = computePostfix(eq);

        correct = 0;
        while correct == 0:
            input = raw_input('>> ');

            if( str(input) == "q"):
                correct = 2;
                print "Thanks for playing";
                break;
            elif (int(input) == int(sol)):
                correct = 1;
                print "Correct!";
            else:
                print "Incorrect...";

  • permalink
  • embed
  • save
  • give gold

[–]5hassay 1 point2 points3 points 4 years ago (0 children)

    equation

you mean expression! :)

python33

from random import seed, randint, choice


min, max = [int(i) for i in input("min, max (space delim): ").split()]
NUM_OPS = 3
OPS = ["+", "-", "*"]
NUM_INTS = 4
seed()
running = True
while running:
    i1, i2, i3, i4 = [randint(min, max) for i in range(NUM_INTS)]
    op1, op2, op3 = [choice(OPS) for i in range(NUM_OPS)]
    expr = "%i %s %i %s %i %s %i" % (i1, op1, i2, op2, i3, op3, i4)
    while True:
        print(expr)
        answ = input("")
        if answ.lower() == "q":
            running = False
            break
        elif int(answ) == eval(expr):
            print("Correct!")
            break
        else:
            print("Try Again")

  • permalink
  • embed
  • save
  • give gold

[–]Yamame 1 point2 points3 points 4 years ago* (0 children)

Python2 solution with simple sanity check

from sys import argv,exit
from random import randint

script, a, b = argv

op_list = ['+','-','*']
nu = [None] * 4; op = [None] * 4

br = int(a); tr = int(b)

while True:
    for i in range(4):
        nu[i] = randint(br,tr)
        op[i] = op_list[randint(0,2)]
    y = "%i %s %i %s %i %s %i" % (nu[0], op[0], nu[1], op[1], nu[2], op[2], nu[3])
    result = eval(y)

    while True:
       print '> %s' % y; ans = raw_input()
       if ans == 'q' or ans == 'Q': exit()
       elif ans.isdigit() == False: print "> Not a number, try again!"
       elif int(ans) == result: print "> Correct!"; break
       else: print "> False!"

I really appreciate your feedback :)

  • permalink
  • embed
  • save
  • give gold

[–]otsojaun 1 point2 points3 points 4 years ago (0 children)

Java. A bit late to the party

import java.util.Random;
import java.util.Scanner;

public class ArithmeticEquations {
    public static void main(String args[]){
        Scanner scan = new Scanner(System.in);
        int min = scan.nextInt();
        int max = scan.nextInt();
        int numbers[] = new int[4];
        char operators[] = new char[3];
        Random r = new Random();

        while (true){
            for (int i = 0; i < 4; i++)
                numbers[i] = min + r.nextInt(max - min + 1);

            String equation = numbers[0] + "";
            for (int j = 0; j < 3; j++){
                int k = r.nextInt(3);
                if (k != 2){
                    operators[j] = (k == 1) ? '+' : '-';
                    equation += " " + operators[j] + " " + numbers[j + 1];
                }
                else{
                    operators[j] = '*';
                    equation += " " + operators[j] + " " + numbers[j + 1];
                    numbers[j+1] *= numbers[j];
                    numbers[j] = 0;
                    if (j != 0){
                        operators[j] = operators[j - 1];
                        operators[j - 1] = '+';
                    }
                }
            }

            int result = numbers[0];
            for (int i = 1; i < 4; i++)
                result += operators[i - 1] == '-' ? -numbers[i] : numbers[i];

            boolean correct = false;
            while (!correct){
                System.out.println(equation);
                scan = new Scanner(System.in);
                String input = scan.next();
                if (input.equalsIgnoreCase("q"))
                    System.exit(0);
                correct = input.equalsIgnoreCase(result + "");
                if (correct)
                    System.out.println("Correct!");
                else
                    System.out.println("Incorrect!");
            }
        }
    }
}

  • permalink
  • embed
  • save
  • give gold

[–]Dysruption 1 point2 points3 points 4 years ago (1 child)

Ruby!

x,y = gets.chomp.split
r=*(x..y)
ops = [:+, :-, :*]
i = String.new
until i == "q"
  eq = %{#{r.sample} #{ops.sample} #{r.sample} #{ops.sample} #{r.sample} #{ops.sample} #{r.sample}}
  puts eq
  i = gets.chomp!
  eval(eq) == i.to_i ? puts "Correct!" : puts "Incorrect!"
end

  • permalink
  • embed
  • save
  • give gold

[–][deleted] 0 points1 point2 points 4 years ago (0 children)

Really cool

  • permalink
  • embed
  • save
  • parent

[–]monumentshorts 1 point2 points3 points 4 years ago (1 child)

F# with included unit test. I could've done the whole thing just using data
table, like other dynamic languages (so one line basically), but it was more
fun to generate the expression tree and evaluate it by hand.

Like the one haskell entry I saw here, I folded the expression tree to
represent the order of operations.

I just realized I didn't really tie in the IO part of it, oops

module fs

open NUnit.Framework
open FsUnit
open System
open System.Data

type Operation =
    | Mult
    | Sub
    | Add

let print = function
            | Mult -> "*"
            | Sub -> "-"
            | Add -> "+"

let op = function
            | Mult -> (*)
            | Sub -> (-)
            | Add -> (+)

type Expression =
    | Terminal of int
    | Expr of Expression * Operation * Expression

let rand = new System.Random()

let randNum min max = rand.Next(min, max)

let randomOperation () =
    match randNum 0 2 with
    | 0 -> Mult
    | 1 -> Sub
    | _ -> Add

let rec foldExpr expr opToEval =
    let evaluate a b = a |> op opToEval <| b
    match expr with
        | Expr(Terminal(item), targetOp, Expr(Terminal(item2), o, next))
            when targetOp = opToEval ->
                foldExpr (Expr(Terminal(evaluate item item2), o, next)) opToEval

        | Expr(Terminal(item), targetOp, Terminal(item2))
            when targetOp = opToEval ->
                Terminal(evaluate item item2)

        | Expr(i, o, next) -> Expr(foldExpr i opToEval, o, foldExpr next opToEval)

        | Terminal(i) -> Terminal(i)

let rec randomExpression min max length =
    match length with
        | 0 -> Terminal(randNum min max)
        | _ -> Expr(Terminal(randNum min max), randomOperation(), randomExpression min max (length - 1))

let rec display = function
        | Terminal(i) -> i.ToString()
        | Expr(left, op, right) ->
               System.String.Format("{0} {1} {2}", display left, print op, display right)

let orderofOps = [Mult;Sub;Add]

let eval e = List.fold foldExpr e orderofOps

[<Test>]
let arithmeticTest() =

    let dt = new DataTable()

    for i in [0..100] do
        let randomExpr = randomExpression 0 10 5

        let validationResult = dt.Compute(display randomExpr, "").ToString() |> Convert.ToInt32

        printfn "%s" (display randomExpr)

        eval randomExpr |> should equal <| Terminal(validationResult)

  • permalink
  • embed
  • save
  • give gold

[–]monumentshorts 0 points1 point2 points 4 years ago (0 children)

If anyone is interested, I did a walk through of the F# here: http://
onoffswitch.net/implementing-game-arithmetic/

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]MDTKBS 1 point2 points3 points 4 years ago (0 children)

A little late but hopefully thats ok

https://github.com/MDTKBS/r-dailyprogrammer/blob/master/135%5BEasy%5D/
ArithmeticEquations.cpp

  • permalink
  • embed
  • save
  • give gold

[–]MATTtheSEAHAWK 1 point2 points3 points 4 years ago* (0 children)

Redid this one (python 3):

from random import randint

#get number range
(x,y) = map(int, input("Enter a range of numbers:  ").split())

#testing loop
while 1:
    #generate random numbers and operators
    nums = [randint(x,y) for i in range(0,4)]
    ops = [['*','+','-'][randint(0,2)] for i in range(0,3)]
    #build expression
    exp = str(nums[0])+" "+ops[0]+" "
    exp += str(nums[1])+" "+ops[1]+" "
    exp += str(nums[2])+" "+ops[2]+" "+str(nums[3])
    #evaluate solution
    solution = eval(exp)
    #test the user until they're correct or they quit
    while 1:
        print("> "+exp)
        inp = input()
        if str(inp) in 'qQ':
            print("> Thanks for playing!")
            exit(0)
        if int(inp) == solution:
            print("> Correct!")
            break
            print("> Incorrect!")

  • permalink
  • embed
  • save
  • give gold

[–]skyangelisme0 1 1 point2 points3 points 4 years ago (0 children)

Python 2

from random import choice
st, ed = map(int, raw_input().split())
expressions = ["+", "-", "*", "/"]
numbers = [str(i) for i in xrange(min(st,ed), max(st,ed)+1)]
while True:
  ans, problem = "",""
  try:
    values = [choice(numbers)]
    for i in range(3):
      values.append(choice(expressions))
      values.append(choice(numbers))
    problem = " ".join(v for v in values)
    ans = eval(problem)
  except:
    pass
  print problem
  get = raw_input()
  if get.lower() == 'q': break
  else:
    print "Correct!" if get == str(ans) else "Incorrect..."

It will regenerate a problem if the solution is NaN. Otherwise, nothing
special; follows the problem description exactly.

  • permalink
  • embed
  • save
  • give gold

[–]thatusernameisalre 1 point2 points3 points 4 years ago* (0 children)

My non-modular Ruby solution:

Edit: Original code didn't repeat expression on incorrect answer...oops!

#!/usr/bin/env ruby

puts "> Range:"
range = gets.chomp.split.sort
operators = ["+", "-", "*"]
done = false
correct = false

until done do
    v = "(range[0]..range[1]).to_a.sample"
    o = "operators.sample"
    expression = "#{eval(v)} #{eval(o)} #{eval(v)} #{eval(o)} #{eval(v)} #{eval(o)} #{eval(v)}"

    until done or correct do
        puts "> " + expression
        answer = gets.chomp

        if answer.downcase == "q"
            done = true
        elsif answer.to_i == eval(expression)
            puts "> Correct!"
            correct = true
        else
            puts "> Incorrect..."
        end
    end

    if done
        puts "> Goodbye!"
    else
        correct = false
    end
end

  • permalink
  • embed
  • save
  • give gold

[–]134-IQ 1 point2 points3 points 4 years ago* (0 children)

I'm late to the game, but this is an expandable C++ version. You can choose
your range and your problem count.

#include <iostream>
#include <time.h>
#include <stdlib.h>
#include <new>

using namespace std;


int main () {

    srand(time(NULL));
    char opRange[] = { '+', '-', '*' };
    int minRange;
    int maxRange;
    int finalRange;
    int maxCount;

    cout << "Hello, welcome to the arithmetic generator! I can generate random arithmetic" << endl;
    cout << "problems from your choice of range (negative numbers too!)" << endl << endl << endl;
    cout << "How many problems do you want to solve today? ";
    cin >> maxCount; cout << endl;
    cout << "Please enter in your MIN range: ";
    cin >> minRange; cout << endl;
    cout << "Please enter in your MAX range: ";
    cin >> maxRange; cout << endl;

    cout << "Random numbers will be generated, in your range of: " << minRange << " to " << maxRange << endl << endl;

    finalRange = (maxRange - minRange) + 1;

    int * intRangePtr; // create a pointer
    intRangePtr = new (nothrow) int [finalRange]; // point intRangePtr to our dynamic array. I used (nothrow) to catch any memory allocation errors.

    if (intRangePtr == 0)
       cout << "Error: Memory could not be allocated! Check your MIN and MAX range" << endl;
    else {
        int min = minRange;
        for (int i = 0; i < finalRange; i++, min++)
            intRangePtr[i] = min;

    int rightCount = 0;
    int wrongCount = 0;

    int a, b, c, d; // our four integers.
    char aa, bb, cc; // our three operators
    int answer, guess;
    int m, n, o;


    cout << "Please enter in the correct answer." << endl;

    while ((rightCount + wrongCount) < maxCount ) {
        a = intRangePtr[rand () % finalRange];
        b = intRangePtr[rand () % finalRange];
        c = intRangePtr[rand () % finalRange];
        d = intRangePtr[rand () % finalRange];

        m = rand () % 3; aa = opRange[m];
        n = rand () % 3; bb = opRange[n];
        o = rand () % 3; cc = opRange[o];


        cout <<" ("<<a<<") " << aa <<" ("<<b<<") "<< bb <<" ("<<c<<") "<< cc <<" ("<<d<<") "<< endl;

            if      (aa == '+' && bb == '+' && cc == '+')
                answer = a + b + c + d;
            else if (aa == '+' && bb == '+' && cc == '-')
                answer = a + b + c - d;
            else if (aa == '+' && bb == '+' && cc == '*')
                answer = a + b + c * d;
            //                                          //
            else if (aa == '+' && bb == '-' && cc == '+')
                answer = a + b - c + d;
            else if (aa == '+' && bb == '-' && cc == '-')
                answer = a + b - c - d;
            else if (aa == '+' && bb == '-' && cc == '*')
                answer = a + b - c * d;
            //                                          //
            else if (aa == '+' && bb == '*' && cc == '+')
                answer = a + b * c + d;
            else if (aa == '+' && bb == '*' && cc == '-')
                answer = a + b * c - d;
            else if (aa == '+' && bb == '*' && cc == '*')
                answer = a + b * c * d;
            //                                          //
            else if (aa == '-' && bb == '+' && cc == '+')
                answer = a - b + c + d;
            else if (aa == '-' && bb == '+' && cc == '-')
                answer = a - b + c - d;
            else if (aa == '-' && bb == '+' && cc == '*')
                answer = a - b + c * d;
            //                                          //
            else if (aa == '-' && bb == '-' && cc == '+')
                answer = a - b - c + d;
            else if (aa == '-' && bb == '-' && cc == '-')
                answer = a - b - c - d;
            else if (aa == '-' && bb == '-' && cc == '*')
                answer = a - b - c * d;
            //                                          //
            else if (aa == '-' && bb == '*' && cc == '+')
                answer = a - b * c + d;
            else if (aa == '-' && bb == '*' && cc == '-')
                answer = a - b * c - d;
            else if (aa == '-' && bb == '*' && cc == '*')
                answer = a - b * c * d;
            //                                          //
            else if (aa == '*' && bb == '+' && cc == '+')
                answer = a * b + c + d;
            else if (aa == '*' && bb == '+' && cc == '-')
                answer = a * b + c - d;
            else if (aa == '*' && bb == '+' && cc == '*')
                answer = a * b + c * d;
            //                                          //
            else if (aa == '*' && bb == '-' && cc == '+')
                answer = a * b - c + d;
            else if (aa == '*' && bb == '-' && cc == '-')
                answer = a * b - c - d;
            else if (aa == '*' && bb == '-' && cc == '*')
                answer = a * b - c * d;
            //                                          //
            else if (aa == '*' && bb == '*' && cc == '+')
                answer = a * b * c + d;
            else if (aa == '*' && bb == '*' && cc == '-')
                answer = a * b * c - d;
            else if (aa == '*' && bb == '*' && cc == '*')
                answer = a * b * c * d;
            else
                cout << "134-IQ missed one" << endl;

        cin >> guess;

        if ( guess == answer ) {
            cout << "Correct!" << endl << endl;
            rightCount++;
        }
        else {
            cout << "Wrong!" << endl << endl;
            wrongCount++;
        }
        continue;


        }
        cout << "Right answers: " << rightCount << endl;
        cout << "Wrong answers: " << wrongCount << endl;

    }

    return 0;
}

  • permalink
  • embed
  • save
  • give gold

[–]pbl24 1 point2 points3 points 4 years ago (0 children)

Python and lambdas:

nums = lambda l, u: map(lambda n : random.randint(l, u), [0] * 3)
ops = lambda: [ [ '+', '-', '*'][random.randint(0, 2)] for s in range(0, 2) ]
solve = lambda eq: (' '.join(eq), int(eval(' '.join(eq))))
gen = lambda nums, ops: solve([ str(nums.pop(0)) if i % 2 == 0 else ops.pop(0) for i in range((len(nums) * 2) - 1) ])

def run(l, u):
  again = False
  while True:
    if not again:
      eq = gen(nums(l, u), ops())

    print eq[0]

    input = raw_input('')
    if input is 'q':
      break

    again = eq[1] != int(input)
    print ('Correct!' if not again else 'Try Again')


run(int(sys.argv[1]), int(sys.argv[2]))

  • permalink
  • embed
  • save
  • give gold

[–]Amnestic 1 point2 points3 points 4 years ago (0 children)

First time I try one of the challenges. Had to make a few hacks here and there,
also I figure this could've been written much shorter.

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

import javax.script.ScriptEngineManager;
import javax.script.ScriptEngine;
import javax.script.ScriptException;

public class Arithmetic {
        public static void main(String[] args) {
        int argumentOne = Integer.parseInt(args[0]);
        int argumentTwo = Integer.parseInt(args[1]);

        while(true){
            String[] expression = generateExpression(argumentOne, argumentTwo);
            generateQuestion(expression);
        }

    }


    private static void generateQuestion(String[] expression) {
        while(true){
            // Ask user the question
            System.out.println(expression[0]);

            // Input
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

            String answer = null;

            try {
                    answer = br.readLine();
        } catch (IOException e) {
            e.printStackTrace();
        }

        if(answer.equals("q") || answer.equals("Q")){
            System.exit(0);
        }

        answer = answer + ".0";

        if (answer.equals(expression[1])){
            System.out.println("Correct!");
            break;
        }else {
            System.out.println("Incorrect...");
        }
    }
}


private static String[] generateExpression(int argumentOne, int argumentTwo){
    String[] tempEquation = new String[2];

    int[] numbers = generateNumbers(argumentOne, argumentTwo);
    String[] operators = generateOperator();


    // Expression as a string
    tempEquation[0] = (numbers[0] + " " + operators[0] + " " + numbers[1] + " " + operators[1] + " " + numbers[2] + " " + operators[2] + " " + numbers[3]);

    // Calculate the expression (dirty, dirty javascript, didn't bother to rewrite solution)
    String resultTemp = (numbers[0] + operators[0] + numbers[1] + operators[1] + numbers[2] + operators[2]  + numbers[3]);
    ScriptEngineManager mgr = new ScriptEngineManager();
    ScriptEngine engine = mgr.getEngineByName("JavaScript");

    Double result = null;

    try {
        result = (Double) engine.eval(resultTemp);
    } catch (ScriptException e) {
        e.printStackTrace();
    }

    tempEquation[1] = result.toString();

    return tempEquation;
}

private static String[] generateOperator(){
    String[] tempOperators = new String[4];

    for(int i = 0; i < 3; i++){
        int operatorNumber = (int) (Math.random() * (3));
        switch (operatorNumber) {
            case 0 : tempOperators[i] = "*";
            break;

            case 1 : tempOperators[i] = "+";
            break;

            case 2 : tempOperators[i] = "-";
            break;
        }
    }

    return tempOperators;
}

private static int[] generateNumbers(int argumentOne, int argumentTwo) {
    int[] tempNumber = new int[4];
    for(int i = 0; i < 4; i++){
        tempNumber[i] = generateNumber(argumentOne, argumentTwo);
    }
    return tempNumber;
}


private static int generateNumber(int min, int max) {
    return min + (int) (Math.random() * (max));
}

}

  • permalink
  • embed
  • save
  • give gold

[–]nofingerpointing 1 point2 points3 points 4 years ago (0 children)

My solution in Ruby 2.0.0. I had to peek into other questions for the eval
trick :)

OPS = %w(+ - *)

def generate_number
  return (2 + rand(8)).to_s
end

def generate_operator
  return OPS[rand(OPS.length)]
end

def generate_equation
  equation_length = 2 + rand(3)
  equation_ops = []
  equation_numbers = [] << generate_number

  (equation_length - 1).times {
    equation_ops << generate_operator
    equation_numbers << generate_number
  }

  equation = equation_numbers.each_with_index
    .flat_map { |x, idx| (idx < equation_length - 1) ? [x, equation_ops[idx]] : [x] }
      .join(" ")

  return equation, eval(equation)
end

equation, result = generate_equation

while(true) do
  p equation
  asnwer = gets.chomp

  p "Bye!" and break if asnwer.downcase == "q"
  p "Incorrect!" and next if asnwer.to_i != result
  p "Correct!"

  equation, result = generate_equation
end

  • permalink
  • embed
  • save
  • give gold

[–]odhran666 1 point2 points3 points 4 years ago (0 children)

A Lua solution :

math.randomseed(os.time())
local ops = {'+', '-', '*'}

function create_expression(mn, mx)
    return {    math.random(mn, mx), ops[math.random(#ops)],
                math.random(mn, mx), ops[math.random(#ops)],
                math.random(mn, mx), ops[math.random(#ops)], math.random(mn, mx)}
end

print("Enter min and max values : ")
local minmax = {}
for i in string.gmatch(io.read(), "%d+") do
    minmax[#minmax + 1] = tonumber(i)
end

while true do
    local expr = table.concat(create_expression(minmax[1],minmax[2]), " ")
    local answer = loadstring("return " .. expr)()
    print(expr)
    while true do
        local input = io.read()
        if input == "q" or input == "Q" then return end
        local in_answer = tonumber(string.gmatch(input, "%S+")())
        if in_answer == answer then
            print("Correct!\n")
            break
        else
            print("Incorrect!\n\n" .. expr)
        end
    end
end

  • permalink
  • embed
  • save
  • give gold

[–]deathmangos 1 point2 points3 points 4 years ago (0 children)

Better late than never. Used eval(), it was hard enough for me as it is.
Javascript:

//This handles displaying to page elements
var Display = function() {
    Display.problem = function(string) {
        document.getElementById('equations').innerHTML = string + '<br>';
    }
    Display.feedback = function(string) {
        document.getElementById('feedback').innerHTML = string + '<br>';
    }
    Display.feedback.add = function(string) {
        document.getElementById('feedback').innerHTML += string + '<br>';
    }
    Display.answerField = function(string) {
        document.getElementById('answerField').value = string;
    }
    return Display;
};

var show = new Display();

var rMin = 0;
var rMax = 0;
var answer = 0;

function setRange(form) {
    rMin = parseFloat(form.minRange.value);
    rMax = parseFloat(form.maxRange.value);
    show.problem(randomEq(rMin, rMax));
    show.feedback(''); //Clears feedback
    show.answerField(''); //Clears user answer field
    return false; // So the form submit doesn't reload the page
}

function randomInteger(from, to) {
    return Math.floor(Math.random() * (to - from + 1) + from);
}

function randomOperator() {
    var operators = ["+", "-", "*"];
    return operators[Math.floor(Math.random() * operators.length)];
}

function randomEq(min, max) {
    var n = [];
    while (n.length < 4) {
        n[n.length] = randomInteger(min, max);
    }
    var eq = n[0] + randomOperator() + n[1] + randomOperator() + n[2] + randomOperator() + n[3];
    answer = eval(eq);
    return eq;
}

function evalAnswer(userAnswer) {
    if (parseFloat(userAnswer.value) === answer) {
        show.feedback.add("That's right!<br>The answer is " + answer)
    } else if (userAnswer.value === 'q' || userAnswer.value === 'Q') {
        show.feedback.add("Bye!");
    } else {
        show.feedback.add("Try again <br>")
    }
    return false; // So the form submit doesn't reload the page
}

HTML:

<!DOCTYPE html>
<html>
    <head>
        <title>Arithmetic Equations</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>
    <body>
        <div>
            <form id="userRange" onsubmit="return setRange(userRange)">
                Please enter a range:
                <input type="text" name="minRange" size="1" value="0" autocomplete="off"> -
                <input type="text" name="maxRange" size="1" value="10" autocomplete="off">
                <input type="submit" name="startBtn" value="Get new problem"/>
            </form>
        </div>
        <div id='equations'></div>
        <div>
            <form onsubmit="return evalAnswer(answerField)"> =
                <input id="answerField" type="text" size="1" value="" autocomplete="off">
            </form>
        </div>
        <div id='feedback'></div>
        <footer>
            <script src="js.js"></script>
        </footer>
    </body>
</html>

  • permalink
  • embed
  • save
  • give gold

[–]dznqbit 1 point2 points3 points 4 years ago (0 children)

Python github

# http://www.reddit.com/r/dailyprogrammer/comments/1k7s7p/081313_challenge_135_easy_arithmetic_equations/

import random
import string

class arithmetic():
  def run(self):
    bounds  = [int(x) for x in string.split(raw_input(), " ")]

    while 1 == 1:
      equation  = self.build_equation(bounds)
      answer    = self.answer(equation)

      if answer == "q":
        break
      else:
        print("Correct!")

  def build_equation(self, bounds):
    numbers = [random.randrange(min(bounds), max(bounds)) for i in range(4)]

    equation = reduce(
      lambda memo, num:
        ' '.join([memo, random.choice(["+", "-", "*"]), str(num)]) if len(memo) > 0 else str(num),
      numbers,
      ""
    )

    return equation

  def answer(self, equation):
    solution = eval(equation)

    print(equation)
    user_input = raw_input().lower()

    while user_input not in ["q", str(solution)]:
      print("Incorrect...")
      print(equation)
      user_input = raw_input().lower()

    return user_input

arithmetic().run()

  • permalink
  • embed
  • save
  • give gold

[–]vape 1 point2 points3 points 4 years ago (0 children)

Very late but I'll submit it anyway. Python 3 solution with no error checking
so I could keep the code short.

import random
from itertools import zip_longest

def get_operation(a, b):
    ops = ['+', '-', '*']
    random.shuffle(ops)
    nums = [str(random.randint(a, b)) for i in list(range(4))]

    tups = zip_longest(nums, ops)
    return " ".join([item for tup in tups for item in tup if item is not None]) #interleave ops and nums, and extract items from list of tuples

def main():
    while True:
        print("> Enter two integers: ")
        inp = input()
        if inp.lower() == 'q':
            break

        op = get_operation(*[int(i) for i in inp.split(' ')][:2])
        print("> op: {0}".format(op))
        user_result = input()
        if user_result.lower() == 'q':
            break

        user_result_is_correct = eval(op) == int(user_result)
        print("correct!" if user_result_is_correct else "incorrect...")


if __name__ == "__main__":
    main()

  • permalink
  • embed
  • save
  • give gold

[–]mentalorigami 1 point2 points3 points 4 years ago (0 children)

Python 2.7 with a quick (and lazy) scoring system.

import random

def Arithmetic(minNum, maxNum):
    wins = 0
    losses = 0

    while True:
        operators = ['-','+','*']
        equation = ''


        for i in range(3):
            equation += str(random.randint(minNum, maxNum)) + ' '
            equation += str(random.choice(operators)) + ' '
        equation += str(random.randint(minNum, maxNum))

        print equation
        answer = raw_input('Your solution? \n>')

        if answer in 'qQ':
            print 'You scored: ' + str(wins) + '\nWith ' \
                + str(wins + losses) + \
                ' tries, for an average of %.1f' \
                %((wins * 100) / (wins + losses))
            break
        elif int(answer) == eval(equation):
            print "Correct."
            wins = wins + 1
        else:
            print "Incorrect."
            losses = losses + 1

  • permalink
  • embed
  • save
  • give gold

[–]milliDavids 1 point2 points3 points 4 years ago (0 children)

Python3

def arithmetic_equation():
"""
The user will input two integers. These integers will be the inclusive range of numbers that the arithmetic
equation will use. The arithmetic equation will generate random simple math equations that it will try to have
the user answer. If the user is correct, it outputs "Correct!" and if they are wrong it will output "Wrong!" and
will have the user try again. If the user inputs 'q' or 'Q' the program will quit.
"""

bottom_range, top_range = input('Input the range of integers separated by a single space. ').split(' ')
bottom_range = int(bottom_range)
top_range = int(top_range)
operators = ['+', '-', '*']
user_answer = 'lol'
print("You can quit at any time by typing in and upper or lower case 'q'.")
while user_answer.lower() != 'q':
    exit = False
    equation = ''
    for eq in range(4):
        equation += str(randrange(bottom_range, top_range+1)) + ' ' + operators[randrange(3)] + ' '
    equation = equation[:-2]
    equation_answer = eval(equation)
    while not exit:
        user_answer = input('What is the answer of: ' + equation + ' ')
        if user_answer.lower() == 'q':
            exit = True
        elif int(user_answer) == equation_answer:
            print('Correct!')
            exit = True
        else:
            print('Incorrect')

arithmetic_equation()

  • permalink
  • embed
  • save
  • give gold

[–]lets_see_exhibit_A 1 point2 points3 points 4 years ago (0 children)

Java:

 import java.util.Random;
import java.util.Scanner;
import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 public class Easy136 {

public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    String[] operators = {"+","-","*"};
    Random random = new Random();
    int min = scanner.nextInt();
    int max = scanner.nextInt();
    scanner.nextLine();
    while(true){
        int lastNum = random.nextInt(max-min+1) + min;
        String expressionString = "" + lastNum + " ";
        String expression = "" + lastNum;
        for(int i = 0; i < 3; i++){
            String oper = operators[random.nextInt(3)];
            int constant = random.nextInt(max-min+1);
            expressionString += oper + " " + constant + " ";
            if(oper.equals("*")){
                expression = expression.substring(0, expression.length() - ("" + lastNum).length()) + lastNum * constant;
                lastNum = lastNum * constant;
            }
            else{
                expression += oper + constant;
                lastNum = constant;
            }
        }
        int index = expression.length();
        int plus = expression.indexOf('+');
        int minus = expression.indexOf('-');
        if(minus > -1 && plus > -1)
            index = Math.min(plus, minus);
        else if (minus > -1 || plus > -1)
            index = Math.max(plus, minus);
        int total = Integer.parseInt(expression.substring(0,index));
        Matcher matcher = Pattern.compile("[\\-\\+]\\d+").matcher(expression);
        while(matcher.find()){
            total += Integer.parseInt(matcher.group());
        }
        System.out.println(expressionString);
        while(Integer.parseInt(scanner.nextLine())!=total)
            System.out.println("Incorrect");
        System.out.println("Correct!");
    }

}

 }

  • permalink
  • embed
  • save
  • give gold

[–]kate_katie_kat 1 point2 points3 points 4 years ago (0 children)

Ruby

class Output
  def initialize
     @range = gets.chomp.split(/ /).map!{|n| n.to_i}
  end

  def random_number
    rand(@range[0]..@range[1])
  end

  def random_operator
    [:+, :-, :*].sample
  end

  def equation
    eq = "#{random_number}"
    3.times {eq << " #{random_operator} #{random_number}"}
    eq
  end
end

class Game
  def initialize
    @output = Output.new
  end

  def play
    while true
      question = @output.equation
      evaluate_question(question)
    end
  end

  def evaluate_question(question)
    puts question
    answer = gets.chomp
    if answer.downcase == 'q'
      exit
    elsif answer.chomp.to_i == eval(question)
      puts "Correct!"
    else
      puts "Try again!"
      evaluate_question(question)
    end
  end
end

Game.new.play

  • permalink
  • embed
  • save
  • give gold

[–]Hanse00 1 point2 points3 points 4 years ago (0 children)

Python 2.7

import random
new = 1

numbers = raw_input().split(" ")

while True:
    if new == 1:
        equation_list = []
        for i in range(4):
            if i != 0:
                sign = random.randint(0, 2)
                if sign == 0:
                    equation_list.append("+")
                elif sign == 1:
                    equation_list.append("-")
                elif sign == 2:
                    equation_list.append("*")
            equation_list.append(str(random.randint(int(numbers[0]), int(numbers[1]))))

        equation = "".join(equation_list)
        equation = eval(equation)

    for thing in equation_list:
        print thing,
    print ""

    answer = raw_input()
    if answer == "q" or answer == "Q":
        break
    else:
        answer = int(answer)
        if answer == equation:
            print "Correct!"
            new = 1
        else:
            print "Wrong!"
            new = 0

  • permalink
  • embed
  • save
  • give gold

[–]RangeruDangeru 1 point2 points3 points 4 years ago* (0 children)

Not the best solution, but a solution. Definitely longer than I would have
liked.

Python 3.3

import random
import itertools


def rand_ops(n):
    return [random.choice("+-*") for _ in range(n)]


def rand_ints(a, b, n):
    return [str(random.randint(a, b)) for _ in range(n)]


def rand_expr(constants, operators):
    expr = ""
    raw_expr = list(itertools.zip_longest(constants, operators))

    for num, op in raw_expr:
        expr += (" {} {}".format(num, op)) if op else " {}".format(num)

    return expr.lstrip(" ")


def play(expr, stats):
    print("\n" + expr)

    user_answer = input("Your answer: ")

    if user_answer == "q" or user_answer == "Q":
        return False

    elif int(user_answer) == eval(expr):
        print("Correct!")
        stats["correct"] += 1

        return True

    else:
        print("Try Again...")
        stats["incorrect"] += 1

        return play(expr, stats)


def main(range_min, range_max, stats):
    while True:
        constants = rand_ints(range_min, range_max, 4)
        operators = rand_ops(3)

        expr = rand_expr(constants, operators)

        if not play(expr, stats):
            return


if __name__ == '__main__':
    stats = {"correct": 0, "incorrect": 0}

    range_min, range_max = (int(value)
        for value in input("Enter range: ").split()
    )

    main(range_min, range_max, stats)

    print("--------\nCorrect: {}\nIncorrect: {}"
        .format(stats["correct"], stats["incorrect"])
    )

  • permalink
  • embed
  • save
  • give gold

[–]luizpericolo 1 point2 points3 points 4 years ago (0 children)

My python submission. I got lazy when I though of the possibility of writing an
expression parser and eval() rocks. Maybe someone could create a slightly
different version of this challenge on an intermediate level where the
arithmetic expression can have paranthesis and any number of constants. (L
Systems FTW)

# -*- coding: utf-8  -*-

def generate_equation(low, high):
    import random

    # The template that will be used to create the arithmetic expression. ('C' is a  placeholder for constants and
    #   'O' is a placeholder for operators.
    template_equation = "C O C O C O C"
    consts = range(low, high)
    operators = ['+','-','*','/']

    for i in range(0, template_equation.count("C")):
        template_equation = template_equation.replace("C", str(random.choice(consts)),1)

    for i in range(0, template_equation.count("O")):
        template_equation = template_equation.replace("O", str(random.choice(operators)),1)

    return (template_equation, eval(template_equation))

def do_game(low, high):


    while True:

        equation, right_value = generate_equation(int(low), int(high))
        print "> {0}".format(equation)
        answer = raw_input()

        if answer in 'qQ':
            break
        elif answer.isdigit():
            if int(answer) == right_value:
                print '> Correct!'
            else:
                print '> Incorrect ...'
        else:
            print 'Give an integer response next time!'

if __name__ == "__main__":
    low, high = raw_input("Please enter the lower and upper bound for the integers separated by space:").split(' ')

    do_game(low, high)

  • permalink
  • embed
  • save
  • give gold

[–]VerifiedMyEmail 1 point2 points3 points 4 years ago* (0 children)

JavaScript run in the console

function game(minimum, maximum) {
  const AMOUNT_OF_NUMBERS = new Number(4),
        AMOUNT_OF_OPERATORS = new Number(3),
        OPERATOR_OPTIONS = new Array('-', '*', '+')
  var numbers = new Array,
      operators = new Array,
      tempIndex = new Number,
      equation = new String,
      guess = new String
  while (!/q/i.test(guess)) {
    for (var i = 0; i < AMOUNT_OF_NUMBERS; i++) {
      numbers[i] = parseInt(Math.random() * maximum)
    }
    for (var l = 0; l < AMOUNT_OF_OPERATORS; l++) {
      tempIndex = parseInt(Math.random() * OPERATOR_OPTIONS.length)
      operators[l] = OPERATOR_OPTIONS[tempIndex]
    }
    equation = numbers[0] + ' ' + operators[0] + ' ' +
               numbers[1] + ' ' + operators[1] + ' ' +
               numbers[2] + ' ' + operators[2] + ' ' +
               numbers[3]
    while (parseInt(guess) != eval(equation) && !/q/i.test(guess)) {
      guess = prompt(equation + ' try again')
      console.log('Incorrect :(')
    }
    if (parseInt(guess) == eval(equation)) {
      console.log('Correct :)')
    }
  }
}

game(0, 10)

  • permalink
  • embed
  • save
  • give gold

[–]brvisi 1 point2 points3 points 4 years ago (0 children)

in C++: This was a tricky one.

#include <cstdlib>
#include <iostream>
#include <ctime>
#include <vector>
#include <sstream>
#include <string>

int RandomInt(int nRangeInit, int nRangeFinal)
{
    return (rand() % (nRangeFinal - nRangeInit + 1)) + nRangeInit;
}

char RandomOperator()
{
    int nRandom;
    nRandom = RandomInt(0, 8);
    if (nRandom<3) { return '+'; }
    if (nRandom>=3 && nRandom<6) { return '-'; }
    if (nRandom>=6 && nRandom<9) { return '*'; }
}

bool RandomEquation(int nRangeInit, int nRangeFinal)
{
    std::vector<int> members;
    std::vector<char> operators;
    std::vector<int>::iterator it_members;
    std::vector<char>::iterator it_operators;
    int nResult=0;
    std::string strInput=" ";
    std::string strEq=" ";

    for (int iii=0; iii<4; iii++)
        members.push_back(RandomInt(nRangeInit, nRangeFinal));

    for (int iii=0; iii<3; iii++)
        operators.push_back(RandomOperator());

    std::stringstream ss;
    strEq = "> ";
    for (it_members=members.begin(), it_operators=operators.begin();
                it_members!=members.end(), it_operators!=operators.end();
                it_members++, it_operators++)
    {
        ss.str(std::string());
        ss << *it_members;
        strEq += ss.str() + " " + *it_operators + " ";
    }
    ss.str(std::string());
    ss << *it_members;
    strEq += ss.str() + " = ";

    for(it_members=members.begin(), it_operators=operators.begin();
         it_operators!=operators.end(); )
    {
        if (*it_operators == '*') {
            *(it_members+1) *= *it_members;
            it_operators = operators.erase(it_operators);
            it_members = members.erase(it_members);
            if (it_operators == operators.end()) { break; }
            if (it_members == members.end()) { break; }
        }
        else {
        it_operators++;
        it_members++;
        }
    }

    nResult = *members.begin();
    for (it_members=members.begin()+1, it_operators=operators.begin();
             it_operators!=operators.end(); it_operators++, it_members++)
    {
        if (*it_operators == '+') { nResult += *it_members; }
        if (*it_operators == '-') { nResult -= *it_members; }
    }

    std::cout << strEq;
    while(std::cin >> strInput)
    {
        if (nResult==atoi(strInput.c_str()))
        {
            std::cout << "> Correct..." << std::endl;
            return true;
        }
        else
        {
            if (strInput=="q" || strInput == "Q") { return false; }
            std::cout << "> Incorrect..." << std::endl << strEq;
        }
    }
}

int main()
{
    int nRangeInit=0, nRangeFinal=0;
    srand(time(0));

    std::cin >> nRangeInit >> nRangeFinal;

    while(RandomEquation(nRangeInit,nRangeFinal));
    return 0;
}

  • permalink
  • embed
  • save
  • give gold

[–]bobjrsenior 0 points1 point2 points 4 years ago* (0 children)

I made my solution in Java. It is pretty messy, but here it is. edit: Decided
to add comments and refine the code a little.

import java.util.Scanner;
import java.util.Random;
import java.util.ArrayList;

public class Driver {
    public static void main(String [] args){
        Scanner k = new Scanner(System.in);
        Random gen = new Random();
        //operation index
        String[] opsInd = {"+", "-", "*"};
        //Correct/Incorrect stats
        int[] stats = {0, 0};
        //Defines if the program should keep going
        boolean cont = true;
        //Define bounds
        System.out.print("Min val: ");
        int min = k.nextInt();
        System.out.print("Max val: ");
        int max = k.nextInt();
        if(min > max){
            int temp = min;
            min = max;
            max = temp;
        }
        //Makes the scanner work right
        k.nextLine();
        //Cycles the program
        while(cont == true){
            //Lists hold the numbers in the equation and the operations
            ArrayList<Integer> nums = new ArrayList<Integer>();
            ArrayList<Integer> ops = new ArrayList<Integer>();
            //Generate the numbers/operations and print them
            for(int e = 0; e < 4; e ++){
                nums.add(gen.nextInt(max - min));
                System.out.print(nums.get(e));
                //There is one less operation than number
                if(e < 3){
                    ops.add(gen.nextInt(3));
                    System.out.print(" " + opsInd[ops.get(e)] + " ");
                }

            }
            System.out.println();
            //Search through the operations for multiplaication
            for(int e = 0; e < ops.size(); e ++){
                //If an operation is *
                if(ops.get(e) == 2){
                    //set the number before the * to the product of
                    //the number before the * and the number after it
                    nums.set(e, nums.get(e) * nums.get(e + 1));
                    //remove the * and the next number to restucture the equation
                    nums.remove(e + 1);
                    ops.remove(e);
                    //ex: 4 + 3 * 8 >> 4 + 24 * 8 >> 4 + 24
                    e --;
                    //Devalue the loop int by 1 since the number of operators deceased
                    //and everything was pushed to the left
                }
            }
            //Start the sum with the first number in the equation
            //(which only has + and - now)
            int sum = nums.get(0);
            //Cycle through the nums
            for(int e = 1; e < nums.size(); e ++){
                //If the associated operator is +, add the value to sum
                if(ops.get(e - 1) == 0){
                    sum += nums.get(e);
                }
                //Operator is -, then subtract from sum
                else if(ops.get(e - 1) == 1){
                    sum -= nums.get(e);
                }
            }
            //Make sure answer has a value, so loop can run without error
            int answer = sum + 1;
            while(answer != sum){
                //Ask for an answer as a string
                System.out.print("Answer: ");
                String ansraw = k.nextLine();
                //If the user inputs q or Q, then quit
                if(ansraw.equals("q") || ansraw.equals("Q")){
                    cont = false;
                    break;
                }
                //Convert the answer into an int
                else{
                    answer = Integer.parseInt(ansraw);
                }
                //If it's correct, then say it is and update/display stats
                if(answer == sum){
                    stats[0] ++;
                    System.out.println("Correct\nTotal Correct: " + stats[0] + "\nTotal Incorrect: " + stats[1]);
                }
                //If it is wrong, display that it is and update stats
                else{
                    stats[1] ++;
                    System.out.println("Incorrect, Try Again");
                }
            }
        }
        k.close();
    }
}

  • permalink
  • embed
  • save
  • give gold

[–]pteek 0 points1 point2 points 4 years ago* (0 children)

Here is my solution in C.

[DEL:I spent one hour to think of a way to make the program exit only if q or Q
is pressed. I can't figure out how to handle the input when the expected input
is of two types and both can't be discarded until they are checked what they
are.:DEL]

[DEL:I am not very good with strings, so there might be a easy solution I
missed.:DEL]

Okay, some reading helped and I have fixed the exit problem. Added and edited
code is commented as such.

Please comment and provide your feedback.

Note: The commented printfs were used for early troubleshooting.

#include <stdio.h>
#include <time.h>
#include <stdlib.h>

struct problem{
    int a,b,c,d;
    char x,y,z;
}problem;

void genrate(int, int);
int calculate();

int main(){
    srand(time(NULL)); //Initialize the random number generator, this only need to be done once per execution.
    int cnt,from,to,sol,exit=0;
    char test; //ADDED to fix the xit problem
    scanf("%d %d", &from, &to);
    while(exit != 1){
        //printf("from %d to %d\n", from, to);
        genrate(from, to+1); //to+1 is to make sure "to" is also included in the genrated numbers
        sol = calculate();
        //printf("Solution is %d\n", sol);
        while(1){
            printf("> %d %c %d %c %d %c %d\n", problem.a, problem.x, problem.b, problem.y, problem.c, problem.z, problem.d);
            while(scanf("%d", &cnt) != 1){ // ADDED to fix the exit problem
                test = getchar(); //if scanf doesn't read one and ONLY one integer, we come here. The failed input in input buffer is read via getchar
                if(test == 'q' || test == 'Q'){//If it is q or Q, program will exit
                    exit = 1;
                    break;
                }
                printf("Wrong input, try again\n");//if it is not q or Q, the suer will be asked to type another input
            }
            if(exit == 1)
                break;
            //printf("you enetred %d\n", cnt);
            if(cnt != sol)
                printf("Try Again\n");
            else{
                printf("Correct!\n");
                break;
            }
        }
    }

    return 0;
}

void genrate(int from, int to){
    int diff;
    diff = to - from;
    //Randomising varibles a, b, c and d
    problem.a = (from + ((rand()) % diff ) );
    problem.b = (from + ((rand()) % diff ) );
    problem.c = (from + ((rand()) % diff ) );
    problem.d = (from + ((rand()) % diff ) );
    //sol = 0;

    //printf("Genrated a %d b %d c %d d %d\n", problem.a, problem.b, problem.c, problem.d);
    //Randomising x operator
    int temp;
    temp = rand();
    if(temp > (2*RAND_MAX)/3)
        problem.x = '+';
    else if(temp > RAND_MAX/3)
        problem.x = '-';
    else
        problem.x = '*';
    //Randomising y operator
    temp = rand();
    if(temp > (2*RAND_MAX)/3)
        problem.y = '+';
    else if(temp > RAND_MAX/3)
        problem.y = '-';
    else
        problem.y = '*';
    //Randomising z operator
    temp = rand();
    if(temp > (2*RAND_MAX)/3)
        problem.z = '+';
    else if(temp > RAND_MAX/3)
        problem.z = '-';
    else
        problem.z = '*';
    //printf("Genrated x %c y %c z %c\n", problem.x, problem.y, problem.z);
}

int calculate(){
    //printf("Starting solution\n");
    struct problem tmpproblem;
    tmpproblem = problem;
    //printf("Temp problem struct is:\n");
    //printf("tmpproblem a %d b %d c %d d %d\n", tmpproblem.a, tmpproblem.b, tmpproblem.c, tmpproblem.d);
    //printf("tmpproblem x %c y %c z %c\n", tmpproblem.x, tmpproblem.y, tmpproblem.z);
    if(tmpproblem.x == '-'){
        tmpproblem.b = 0 - tmpproblem.b;
        //printf("x is -, set b to %d\n", tmpproblem.b);
    }
    if(tmpproblem.y == '-'){
        tmpproblem.c = 0 - tmpproblem.c;
        //printf("y is -, set c to %d\n", tmpproblem.c);
    }
    if(tmpproblem.z == '-'){
        tmpproblem.d = 0 - tmpproblem.d;
        //printf("z is -, set d to %d\n", tmpproblem.d);
    }
    if(tmpproblem.x == '*'){
        tmpproblem.b = tmpproblem.a * tmpproblem.b;
        tmpproblem.a = 0;
        //printf("x is *, set b to %d and a to 0\n", tmpproblem.b);
    }
    if(tmpproblem.y == '*'){
        tmpproblem.c = tmpproblem.b * tmpproblem.c;
        tmpproblem.b = 0;
        //printf("y is *, set c to %d and b to 0\n", tmpproblem.c);
    }
    if(tmpproblem.z == '*'){
        tmpproblem.d = tmpproblem.c * tmpproblem.d;
        tmpproblem.c = 0;
        //printf("z is *, set d to %d and c to 0\n", tmpproblem.d);
    }
    //printf("Done with manipulation, retuning a+b+c+d\n");
    return tmpproblem.a + tmpproblem.b + tmpproblem.c + tmpproblem.d;
}

Output:

-74 55
> 54 + -64 + -66 - 50
45
Try Again
> 54 + -64 + -66 - 50
66
Try Again
> 54 + -64 + -66 - 50
44
Try Again
> 54 + -64 + -66 - 50
-126
Correct!
> -72 + 52 - 26 - 47
-93
Correct!
> 48 + 6 - 46 - 1
7
Correct!
> 23 - -35 + 12 * -5
-2
Correct!
> -19 * -2 - -13 + 55
q

  • permalink
  • embed
  • save
  • give gold

[–][deleted] 0 points1 point2 points 4 years ago (1 child)

any tips on how to set order of operations preference in java?

  • permalink
  • embed
  • save

[–]spfy 0 points1 point2 points 4 years ago (0 children)

Multiplication always goes first, but addition and subtraction have the same
preference. So, just go through your equation and solve all of the
multiplications, then just add everything from left to right.

I have a pretty simple solution here

  • permalink
  • embed
  • save
  • parent
  • give gold

[–]TweenageDream 0 points1 point2 points 4 years ago* (0 children)

I'm a bit late to the party but here is my solution in Ruby

OPERATORS = ["*", "-", "+"]
ints = Range.new(*gets.chomp.split(" ").map(&:to_i)).to_a
input, make_new = "", true
until input.downcase == "q" do
    eq = 4.times.reduce(""){|str|"#{str} #{ints.sample} #{OPERATORS.sample} "}.chop.chop if make_new
    ans = eval eq
    puts "> #{eq}"
    input = gets.chomp
    next if input.downcase == "q"
    if input.to_i == ans
        make_new = true
        puts "> Correct!"
    else
        make_new = false
        puts "> incorrect..."
    end
end

  • permalink
  • embed
  • save
  • give gold

[–]roddz 0 points1 point2 points 4 years ago (0 children)

My first attempt at one of these in java be gentle.

package Classes;

import java.util.Scanner;
import java.util.Timer;

import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;

public class ArithmaticEquasions
{
public ArithmaticEquasions() throws NumberFormatException,          ScriptException, InterruptedException {
    boolean stop = false;

    Scanner kybd = new Scanner(System.in);
    int lowRange,highRange;

    System.out.println("input lower and higher range of integers to work with");
    lowRange = kybd.nextInt();
    highRange = kybd.nextInt();
    int n = highRange-lowRange+1;

    while(!stop)
    {
        stop = true;
        int[] timer = new int[20];
        int[] attempt = new int[20];

            int[] mostIncorrect = new int[2];
            int[] nums = new int[4];
            for(int i = 0;i<nums.length;i++){
                nums[i] = lowRange + (int)(Math.random() * n);
            }

            String[] oper = new String[3];
            oper[0]="+";
            oper[1]="-";
            oper[2]="*";


            for(int x = 0;x<10;x++){
                StringBuilder sb = new StringBuilder();
                for(int i= 0; i <nums.length;i++)
                {
                    int rnd = (int)(Math.random() * 3);
                    if(i<3){
                        sb.append(nums[i]+"  "+oper[rnd]+" ");
                    }
                    else{
                        sb.append(nums[i]);
                    }
                }

                ScriptEngineManager mgr = new ScriptEngineManager();
                ScriptEngine engine =    mgr.getEngineByName("JavaScript");
                String sAns =   engine.eval(sb.toString()).toString();
                double dAns = Double.parseDouble(sAns);
                int ans = (int)dAns;
                System.out.println(">"+sb.toString());
                System.out.println(ans);
                long startTime =0;
                boolean corr = false;
                int attempts = 1;
                int tmp = 0;
                while(!corr)
                {
                    startTime = System.currentTimeMillis();
                    int playAns = kybd.nextInt();
                    if(playAns==ans)
                    {
                        corr = true;
                        attempts++;
                        System.out.println(">Correct!");
                    }
                    else
                    {
                         System.out.println(">Incorrect!");
                        attempts++;
                        System.out.println(">Try again "+sb.toString());
                        tmp = tmp +1;
                    }

                }
                if(tmp>mostIncorrect[1])
                {
                    mostIncorrect[0] = x+1;
                    mostIncorrect[1] = tmp;
                }
                long endTime   = System.currentTimeMillis();
                timer[x] = (int) (endTime - startTime);
                attempt[x] = attempts;

            }
        double avgTime = 0;
        int avgAttempts= 0;
        for(int i =0;i<20;i++)
        {
            avgTime = avgTime+timer[i];
            avgAttempts = avgAttempts+attempt[i];
        }
        avgAttempts = avgAttempts/20;
        avgTime = avgTime/20;
        System.out.println(">Average Time to answer = "+avgTime/1000+"seconds"+
                "\n>Average number of attempts per question = "+ avgAttempts);
        if(mostIncorrect[0]!=0){
        System.out.println(">Answer which took most attempts was question "+mostIncorrect[0]+" this took "+mostIncorrect[1]+" attempts");
        }
        System.out.println("Would you like another round? (Y/N)");
        String again = kybd.next();
        if(again.equalsIgnoreCase("y"))
        {
            stop = false;
        }
            Thread.sleep(1000);
    }
    System.out.println("Thanks for playing!");
}
}

  • permalink
  • embed
  • save
  • give gold

[–]dabarnes 1 point2 points3 points 4 years ago* (0 children)

java

I made this in high school for some project, not using the script engine...
converts the equation to postfix and then does that math. It doesn't acutally
do what the Daily programmer output asks but it has all the methods to do the
math

edit: It also followed order of operations and handles ()'s and It was from my
high school comp sci class, an android calculator.

public String compute() {
    return doMath(Infix(str.toString().trim().replaceAll(" ", "")));
}

public boolean isNumber(char c) {
    String check = "0123456789";
    return check.indexOf((int) c) != -1 ? true : false;
}

// takes the postfix string and does math!
public String doMath(String input) {
    this.str = new StringBuffer();
    Stack<Token> left = new Stack<Token>();
    Stack<Token> right = new Stack<Token>();

    String[] tokens = input.split(" ");

    for (String tmp : tokens) {
        left.push(new Token(tmp));
    }
    do {
        while (!left.isEmpty()) {
            Token temp = left.pop();
            if (temp.isOperator) {
                if (left.peek().isOperator) {
                    right.push(temp);
                } else {
                    Token temp2 = left.pop();
                    if (!left.peek().isOperator) {
                        right.push(new Token(runOperation(temp.operator,
                                        temp2.value, left.pop().value)));
                    } else {
                        right.push(temp);
                        right.push(temp2);
                    }
                 }
            } else {
                right.push(temp);
            }
        }
        Token temp = right.pop();
        if (!temp.isOperator && right.isEmpty()) {
            return "=" + temp.value;
        } else {
            left.push(temp);
            while (!right.isEmpty()) {
                left.push(right.pop());
            }
        }
    } while (!left.isEmpty());
    return "";
}

public double runOperation(char opr, double num1, double num2) {
    switch (opr) {
        case '*':
            return num2 * num1;
        case '/':
            return num2 / num1;
        case '-':
            return num2 - num1;
        case '+':
            return num2 + num1;
        case '^':
            return Math.pow(num2, num1);
        default:
            return 0.0;
    }
}

public static String Infix(String input) {
    if (input == null)
        return "";
    char[] in = input.toCharArray();
    Stack<Character> stack = new Stack<Character>();
    StringBuilder out = new StringBuilder();

    for (int i = 0; i < in.length; i++) {
        switch (in[i]) {
            case '+':
            case '-':
                while (!stack.empty()
                        && (stack.peek() == '*' || stack.peek() == '/')) {
                    out.append(' ');
                    out.append(stack.pop());
                }
                out.append(' ');
                stack.push(in[i]);
                break;
            case '*':
            case '/':
                out.append(' ');
                stack.push(in[i]);
                break;
            case '(':
                stack.push(in[i]);
                break;
            case ')':
                while (!stack.empty() && stack.peek() != '(') {
                    out.append(' ');
                    out.append(stack.pop());
                }
                stack.pop();
                break;
            default:
                out.append(in[i]);
                break;
        }
    }
    while (!stack.isEmpty())
        out.append(' ').append(stack.pop());
    return out.toString();
}

  • permalink
  • embed
  • save
  • give gold

[–]Davess1 0 points1 point2 points 4 years ago (0 children)

quick python one: x = str(input(": ")) print(eval(x))

  • permalink
  • embed
  • save
  • give gold

  • about
  • blog
  • about
  • advertising
  • careers

  • help
  • site rules
  • Reddit help center
  • wiki
  • reddiquette
  • mod guidelines
  • contact us

  • apps & tools
  • Reddit for iPhone
  • Reddit for Android
  • mobile website
  • buttons

  • <3
  • reddit gold
  • redditgifts

Use of this site constitutes acceptance of our User Agreement and Privacy
Policy. (C) 2018 reddit inc. All rights reserved.

REDDIT and the ALIEN Logo are registered trademarks of reddit inc.

Advertise - technology

[pixel]

π Rendered by PID 39492 on app-124  at 2018-05-09 20:37:07.816151+00:00 running
4b07d45 country code: CH.

